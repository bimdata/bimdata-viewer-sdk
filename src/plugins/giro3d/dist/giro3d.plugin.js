(function(){"use strict";try{if(typeof document!="undefined"){var e=document.createElement("style");e.appendChild(document.createTextNode(".bimdata-giro3d[data-v-b898538f]{width:100%;height:100%;position:relative;overflow:hidden}.bimdata-giro3d__viewer[data-v-b898538f]{width:100%;height:100%;display:block;touch-action:none}")),document.head.appendChild(e)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "135";
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;
const GLSL1 = "100";
const GLSL3 = "300 es";
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp$1(x, y, t) {
  return (1 - t) * x + t * y;
}
function damp(x, y, lambda, dt) {
  return lerp$1(x, y, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max) {
  if (x <= min)
    return 0;
  if (x >= max)
    return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min)
    return 0;
  if (x >= max)
    return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0)
    _seed = s % 2147483647;
  _seed = _seed * 16807 % 2147483647;
  return (_seed - 1) / 2147483646;
}
function degToRad$1(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg$1(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
var MathUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp: clamp$1,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp: lerp$1,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad: degToRad$1,
  radToDeg: radToDeg$1,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler
});
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
Vector2.prototype.isVector2 = true;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = true;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max)
      max = array[i];
  }
  return max;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(type, buffer2) {
  return new TYPED_ARRAYS[type](buffer2);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function hashString(str, seed = 0) {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
}
let textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding2 = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding2;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i = 0, l = image.length; i < l; i++) {
            if (image[i].isDataTexture) {
              url.push(serializeImage(image[i].image));
            } else {
              url.push(serializeImage(image[i]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (JSON.stringify(this.userData) !== "{}")
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
Vector4.prototype.isVector4 = true;
class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options = {}) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.image = { width, height, depth: 1 };
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.image = { ...this.texture.image };
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(width, height, count) {
    super(width, height);
    const texture = this.texture;
    this.texture = [];
    for (let i = 0; i < count; i++) {
      this.texture[i] = texture.clone();
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i = 0, il = this.texture.length; i < il; i++) {
        this.texture[i].image.width = width;
        this.texture[i].image.height = height;
        this.texture[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }
  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    this.texture.length = 0;
    for (let i = 0, il = source.texture.length; i < il; i++) {
      this.texture[i] = source.texture[i].clone();
    }
    return this;
  }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(width, height, options = {}) {
    super(width, height, options);
    this.samples = 4;
    this.ignoreDepthForMultisampleCopy = options.ignoreDepth !== void 0 ? options.ignoreDepth : true;
    this.useRenderToTexture = options.useRenderToTexture !== void 0 ? options.useRenderToTexture : false;
    this.useRenderbuffer = this.useRenderToTexture === false;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    this.useRenderToTexture = source.useRenderToTexture;
    this.useRenderbuffer = source.useRenderbuffer;
    return this;
  }
}
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerp(qa, qb, qm, t) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm.slerpQuaternions(qa, qb, t);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q, p) {
    if (p !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    this.copy(qa).slerp(qb, t);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(
      sqrt1u1 * Math.cos(u2),
      sqrtu1 * Math.sin(u3),
      sqrtu1 * Math.cos(u3),
      sqrt1u1 * Math.sin(u2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = true;
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x, y = this.y, z = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v, w);
    }
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$1(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
Vector3.prototype.isVector3 = true;
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector2) {
    this.min.sub(vector2);
    this.max.add(vector2);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box$3.copy(geometry.boundingBox);
      _box$3.applyMatrix4(object.matrixWorld);
      this.union(_box$3);
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere2) {
    this.clampPoint(sphere2.center, _vector$b);
    return _vector$b.distanceToSquared(sphere2.center) <= sphere2.radius * sphere2.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = true;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$3 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p12 = v1.dot(_testAxis);
    const p22 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p12, p22), Math.min(p0, p12, p22)) > r) {
      return false;
    }
  }
  return true;
}
const _box$2 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _toFarthestPoint = /* @__PURE__ */ new Vector3();
const _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere2) {
    this.center.copy(sphere2.center);
    this.radius = sphere2.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere2) {
    const radiusSum = this.radius + sphere2.radius;
    return sphere2.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere2) {
    _toFarthestPoint.subVectors(sphere2.center, this.center).normalize().multiplyScalar(sphere2.radius);
    this.expandByPoint(_v1$6.copy(sphere2.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere2.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere2) {
    return sphere2.center.equals(this.center) && sphere2.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere2, target) {
    _vector$a.subVectors(sphere2.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere2.radius * sphere2.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere2) {
    return this.distanceSqToPoint(sphere2.center) <= sphere2.radius * sphere2.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m, n) {
    if (n !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    this.set(
      1,
      0,
      0,
      x,
      0,
      1,
      0,
      y,
      0,
      0,
      1,
      z,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale2) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale2.x, sy = scale2.y, sz = scale2.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale2) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale2.x = sx;
    scale2.y = sy;
    scale2.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
Matrix4.prototype.isMatrix4 = true;
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp$1(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp$1(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp$1(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp$1(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp$1(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp$1(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$1.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$1 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale2 = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale2
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector2) {
    return vector2.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector2) {
    return vector2.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data = cache2[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$1 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p12, p22, p32, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p12, p22, p32, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
let materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.format = RGBAFormat;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.format !== RGBAFormat)
      data.format = this.format;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.format = source.format;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Material.prototype.isMaterial = true;
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
class Color {
  constructor(r, g, b) {
    if (g === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }
  setHSL(h, s, l) {
    h = euclideanModulo(h, 1);
    s = clamp$1(s, 0, 1);
    l = clamp$1(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    return this;
  }
  setStyle(style2) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style2 + " will be ignored.");
      }
    }
    let m;
    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style2)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s, l);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style2)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style2 && style2.length > 0) {
      return this.setColorName(style2);
    }
    return this;
  }
  setColorName(style2) {
    const hex = _colorKeywords[style2.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style2);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    const r = this.r, g = this.g, b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp$1(_hslA.h, _hslB.h, alpha);
    const s = lerp$1(_hslA.s, _hslB.s, alpha);
    const l = lerp$1(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  copyColorsArray(colors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  }
  copyVector2sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector2 = vectors[i];
      if (vector2 === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
        vector2 = new Vector2();
      }
      array[offset++] = vector2.x;
      array[offset++] = vector2.y;
    }
    return this;
  }
  copyVector3sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector2 = vectors[i];
      if (vector2 === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
        vector2 = new Vector3();
      }
      array[offset++] = vector2.x;
      array[offset++] = vector2.y;
      array[offset++] = vector2.z;
    }
    return this;
  }
  copyVector4sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector2 = vectors[i];
      if (vector2 === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
        vector2 = new Vector4();
      }
      array[offset++] = vector2.x;
      array[offset++] = vector2.y;
      array[offset++] = vector2.z;
      array[offset++] = vector2.w;
    }
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
}
BufferAttribute.prototype.isBufferAttribute = true;
class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
class Float64BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized);
  }
}
let _id = 0;
const _m1 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$1 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _id++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start2, count, materialIndex = 0) {
    this.groups.push({
      start: start2,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start2, count) {
    this.drawRange.start = start2;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector2) {
    _obj.lookAt(vector2);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start2 = group.start;
      const count = group.count;
      for (let j = start2, jl = start2 + count; j < jl; j += 3) {
        handleTriangle(
          indices[j + 0],
          indices[j + 1],
          indices[j + 2]
        );
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp2.x;
      tangents[v * 4 + 1] = tmp2.y;
      tangents[v * 4 + 2] = tmp2.z;
      tangents[v * 4 + 3] = w;
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start2 = group.start;
      const count = group.count;
      for (let j = start2, jl = start2 + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      );
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    if (source.parameters !== void 0)
      this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
BufferGeometry.prototype.isBufferGeometry = true;
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray();
const _sphere$3 = /* @__PURE__ */ new Sphere();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _tempB = /* @__PURE__ */ new Vector3();
const _tempC = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _morphB = /* @__PURE__ */ new Vector3();
const _morphC = /* @__PURE__ */ new Vector3();
const _uvA$1 = /* @__PURE__ */ new Vector2();
const _uvB$1 = /* @__PURE__ */ new Vector2();
const _uvC$1 = /* @__PURE__ */ new Vector2();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start2 = Math.max(group.start, drawRange.start);
            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start2, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start2 = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start2, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start2 = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j = start2, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start2 = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i = start2, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Mesh.prototype.isMesh = true;
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA$1.fromBufferAttribute(position, a);
  _vB$1.fromBufferAttribute(position, b);
  _vC$1.fromBufferAttribute(position, c);
  const morphInfluences = object.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b, _vB$1);
    object.boneTransform(c, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);
      _uvB$1.fromBufferAttribute(uv2, b);
      _uvC$1.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector2 = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector2[u] = x * udir;
          vector2[v] = y * vdir;
          vector2[w] = depthHalf;
          vertices.push(vector2.x, vector2.y, vector2.z);
          vector2[u] = 0;
          vector2[v] = 0;
          vector2[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector2.x, vector2.y, vector2.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false
      // set to use shader texture LOD
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  }
}
ShaderMaterial.prototype.isShaderMaterial = true;
let Camera$1 = class Camera extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Camera$1.prototype.isCamera = true;
class PerspectiveCamera extends Camera$1 {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
PerspectiveCamera.prototype.isPerspectiveCamera = true;
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding2) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding2);
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
CubeTexture.prototype.isCubeTexture = true;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options = dummy;
    }
    super(size, size, options);
    options = options || {};
    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere2) {
    return this.distanceToPoint(sphere2.center) - sphere2.radius;
  }
  projectPoint(point, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere2) {
    return sphere2.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = true;
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p12 = new Plane(), p22 = new Plane(), p32 = new Plane(), p42 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p12, p22, p32, p42, p5];
  }
  set(p0, p12, p22, p32, p42, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p12);
    planes[2].copy(p22);
    planes[3].copy(p32);
    planes[4].copy(p42);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere2) {
    const planes = this.planes;
    const center = sphere2.center;
    const negRadius = -sphere2.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer2 = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer2);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    }
    return {
      buffer: buffer2,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer2, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer2);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count
        );
      } else {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
        );
      }
      updateRange.count = -1;
    }
  }
  function get2(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get2,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common$2 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common: common$2,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // standard, physical
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  }
};
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 0 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularIntensity: { value: 0 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render2(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render2
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache2 = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache2[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache2;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer2 = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(34962, buffer2);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i) * bytesPerElement
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(34962, buffer2);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i * bytesPerElement
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset2();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset2() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset: reset2,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode2;
  function setMode(value) {
    mode2 = value;
  }
  function render2(start2, count) {
    gl.drawArrays(mode2, start2, count);
    info.update(count, mode2, 1);
  }
  function renderInstances(start2, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode2, start2, count, primcount);
    info.update(count, mode2, primcount);
  }
  this.setMode = setMode;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get2(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class OrthographicCamera extends Camera$1 {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = true;
class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
}
RawShaderMaterial.prototype.isRawShaderMaterial = true;
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX);
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
const MAX_SAMPLES = 20;
const ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null)
      this._cubemapShader.dispose();
    if (this._equirectShader !== null)
      this._equirectShader.dispose();
    for (let i = 0; i < _lodPlanes.length; i++) {
      _lodPlanes[i].dispose();
    }
  }
  // private interface
  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    const params2 = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params2);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params2);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      _setViewport(
        cubeUVRenderTarget,
        col * SIZE_MAX,
        i > 2 ? SIZE_MAX : 0,
        SIZE_MAX,
        SIZE_MAX
      );
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _setEncoding(uniform, texture) {
    uniform.value = ENCODINGS[texture.encoding];
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    if (!isCubeTexture) {
      uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
    }
    this._setEncoding(uniforms["inputEncoding"], texture);
    this._setEncoding(uniforms["outputEncoding"], cubeUVRenderTarget.texture);
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i = 1; i < TOTAL_LODS; i++) {
      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i == 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = LOD_MAX - lodIn;
    this._setEncoding(blurUniforms["inputEncoding"], targetIn.texture);
    this._setEncoding(blurUniforms["outputEncoding"], targetIn.texture);
    const outputSize = _sizeLods[lodOut];
    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _isLDR(texture) {
  if (texture === void 0 || texture.type !== UnsignedByteType)
    return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes2 = [];
  const _sizeLods2 = [];
  const _sigmas2 = [];
  let lod = LOD_MAX;
  for (let i = 0; i < TOTAL_LODS; i++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods2.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
    } else if (i == 0) {
      sigma = 0;
    }
    _sigmas2.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    _lodPlanes2.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
}
function _createRenderTarget(params2) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params2);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: { "n": maxSamples },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "texelSize": { value: texelSize },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "inputEncoding": { value: ENCODINGS[LinearEncoding] },
      "outputEncoding": { value: ENCODINGS[LinearEncoding] }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function _getEncodings() {
  return (
    /* glsl */
    `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get2(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (cubeUVmaps.has(texture)) {
          return cubeUVmaps.get(texture).texture;
        } else {
          const image = texture.image;
          if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
            const currentRenderTarget = renderer.getRenderTarget();
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer);
            const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
            cubeUVmaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return renderTarget.texture;
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i = 0; i < length; i++) {
      if (image[i] !== void 0)
        count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get: get2,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get2(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get: get2,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode2;
  function setMode(value) {
    mode2 = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render2(start2, count) {
    gl.drawElements(mode2, count, type, start2 * bytesPerElement);
    info.update(count, mode2, 1);
  }
  function renderInstances(start2, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode2, count, type, start2 * bytesPerElement, primcount);
    info.update(count, mode2, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render2 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode2, instanceCount) {
    render2.calls++;
    switch (mode2) {
      case 4:
        render2.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render2.lines += instanceCount * (count / 2);
        break;
      case 3:
        render2.lines += instanceCount * (count - 1);
        break;
      case 2:
        render2.lines += instanceCount * count;
        break;
      case 0:
        render2.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode2);
        break;
    }
  }
  function reset2() {
    render2.frame++;
    render2.calls = 0;
    render2.triangles = 0;
    render2.points = 0;
    render2.lines = 0;
  }
  return {
    memory,
    render: render2,
    programs: null,
    autoReset: true,
    reset: reset2,
    update
  };
}
class DataTexture2DArray extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array)
    denominator = 127;
  else if (array instanceof Int16Array)
    denominator = 32767;
  else if (array instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector3();
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const numberOfMorphTargets = geometry.morphAttributes.position.length;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== numberOfMorphTargets) {
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal || [];
        const numberOfVertices = geometry.attributes.position.count;
        const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
        let width = numberOfVertices * numberOfVertexData;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer2 = new Float32Array(width * height * 4 * numberOfMorphTargets);
        const texture = new DataTexture2DArray(buffer2, width, height, numberOfMorphTargets);
        texture.format = RGBAFormat;
        texture.type = FloatType;
        const vertexDataStride = numberOfVertexData * 4;
        for (let i = 0; i < numberOfMorphTargets; i++) {
          const morphTarget = morphTargets[i];
          const morphNormal = morphNormals[i];
          const offset = width * height * 4 * i;
          for (let j = 0; j < morphTarget.count; j++) {
            morph.fromBufferAttribute(morphTarget, j);
            if (morphTarget.normalized === true)
              denormalize(morph, morphTarget);
            const stride = j * vertexDataStride;
            buffer2[offset + stride + 0] = morph.x;
            buffer2[offset + stride + 1] = morph.y;
            buffer2[offset + stride + 2] = morph.z;
            buffer2[offset + stride + 3] = 0;
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer2[offset + stride + 4] = morph.x;
              buffer2[offset + stride + 5] = morph.y;
              buffer2[offset + stride + 6] = morph.z;
              buffer2[offset + stride + 7] = 0;
            }
          }
        }
        entry = {
          count: numberOfMorphTargets,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
      }
      let morphInfluencesSum = 0;
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i = 0; i < length; i++) {
          influences[i] = [i, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i = 0; i < length; i++) {
        const influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }
      influences.sort(absNumericalSort);
      for (let i = 0; i < 8; i++) {
        if (i < length && influences[i][1]) {
          workInfluences[i][0] = influences[i][0];
          workInfluences[i][1] = influences[i][1];
        } else {
          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i = 0; i < 8; i++) {
        const influence = workInfluences[i];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i, morphNormals[index]);
          }
          morphInfluences[i] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
            geometry.deleteAttribute("morphTarget" + i);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
            geometry.deleteAttribute("morphNormal" + i);
          }
          morphInfluences[i] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
class DataTexture3D extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture3D.prototype.isDataTexture3D = true;
const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache2 = this.cache;
  if (cache2[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache2[0] = v;
}
function setValueV2f(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache2[0] = v.x;
      cache2[1] = v.y;
    }
  } else {
    if (arraysEqual(cache2, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV3f(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache2[0] !== v.r || cache2[1] !== v.g || cache2[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache2[0] = v.r;
      cache2[1] = v.g;
      cache2[2] = v.b;
    }
  } else {
    if (arraysEqual(cache2, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueV4f(gl, v) {
  const cache2 = this.cache;
  if (v.x !== void 0) {
    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache2[0] = v.x;
      cache2[1] = v.y;
      cache2[2] = v.z;
      cache2[3] = v.w;
    }
  } else {
    if (arraysEqual(cache2, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache2, v);
  }
}
function setValueM2(gl, v) {
  const cache2 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache2, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache2, v);
  } else {
    if (arraysEqual(cache2, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache2, elements);
  }
}
function setValueM3(gl, v) {
  const cache2 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache2, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache2, v);
  } else {
    if (arraysEqual(cache2, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache2, elements);
  }
}
function setValueM4(gl, v) {
  const cache2 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache2, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache2, v);
  } else {
    if (arraysEqual(cache2, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache2, elements);
  }
}
function setValueV1i(gl, v) {
  const cache2 = this.cache;
  if (cache2[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache2[0] = v;
}
function setValueV2i(gl, v) {
  const cache2 = this.cache;
  if (arraysEqual(cache2, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache2, v);
}
function setValueV3i(gl, v) {
  const cache2 = this.cache;
  if (arraysEqual(cache2, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache2, v);
}
function setValueV4i(gl, v) {
  const cache2 = this.cache;
  if (arraysEqual(cache2, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache2, v);
}
function setValueV1ui(gl, v) {
  const cache2 = this.cache;
  if (cache2[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache2[0] = v;
}
function setValueV2ui(gl, v) {
  const cache2 = this.cache;
  if (arraysEqual(cache2, v))
    return;
  gl.uniform2uiv(this.addr, v);
  copyArray(cache2, v);
}
function setValueV3ui(gl, v) {
  const cache2 = this.cache;
  if (arraysEqual(cache2, v))
    return;
  gl.uniform3uiv(this.addr, v);
  copyArray(cache2, v);
}
function setValueV4ui(gl, v) {
  const cache2 = this.cache;
  if (arraysEqual(cache2, v))
    return;
  gl.uniform4uiv(this.addr, v);
  copyArray(cache2, v);
}
function setValueT1(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache2 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache2[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache2[0] = unit;
  }
  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units2 = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units2);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units2[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const n = v.length;
  const units2 = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units2);
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || emptyTexture3d, units2[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units2 = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units2);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units2[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const n = v.length;
  const units2 = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units2);
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyTexture2dArray, units2[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache2 = this.cache;
  if (data instanceof Float32Array && cache2.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache2, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match2 = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match2[1];
    const idIsIndex = match2[2] === "]", subscript = match2[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  const u = this.map[name];
  if (u !== void 0)
    u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  const v = object[name];
  if (v !== void 0)
    this.setValue(gl, name, v);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i], v = values[u.id];
    if (v.needsUpdate !== false) {
      u.setValue(gl, v.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r = [];
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values)
      r.push(u);
  }
  return r;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding2) {
  switch (encoding2) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding2);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl.getShaderSource(shader));
}
function getTexelDecodingFunction(functionName, encoding2) {
  const components = getEncodingComponents(encoding2);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding2) {
  const components = getEncodingComponents(encoding2);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match2, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match2, start2, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match2, start2, end, snippet);
}
function loopReplacer(match2, start2, end, snippet) {
  let string = "";
  for (let i = parseInt(start2); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.format === RGBFormat ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.specularColorMap ? getTexelDecodingFunction("specularColorMapTexelToLinear", parameters.specularColorMapEncoding) : "",
      parameters.sheenColorMap ? getTexelDecodingFunction("sheenColorMapTexelToLinear", parameters.sheenColorMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
      );
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoat",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    ,
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "alphaTest",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "morphTargetsCount",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "format",
    "specularIntensityMap",
    "specularColorMap",
    "specularColorMapEncoding",
    "transmission",
    "transmissionMap",
    "thicknessMap",
    "sheen",
    "sheenColorMap",
    "sheenColorMapEncoding",
    "sheenRoughnessMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding2;
    if (map && map.isTexture) {
      encoding2 = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding2 = map.texture.encoding;
    } else {
      encoding2 = LinearEncoding;
    }
    return encoding2;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      specularColorMapEncoding: getTextureEncodingFromMap(material.specularColorMap),
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenColorMapEncoding: getTextureEncodingFromMap(material.sheenColorMap),
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
      morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
      morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      format: material.format,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(hashString(parameters.fragmentShader));
      array.push(hashString(parameters.vertexShader));
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get2(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  const defaultProgram = { id: -1 };
  function init2() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort2(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init: init2,
    push,
    unshift,
    finish,
    sort: sort2
  };
}
function WebGLRenderLists(properties) {
  let lists = /* @__PURE__ */ new WeakMap();
  function get2(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache2 = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i = 0; i < 9; i++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, physicallyCorrectLights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++)
      state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity * scaleFactor;
        g += color.g * intensity * scaleFactor;
        b += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache2.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache2.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache2.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash2 = state.hash;
    if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash2.directionalLength = directionalLength;
      hash2.pointLength = pointLength;
      hash2.spotLength = spotLength;
      hash2.rectAreaLength = rectAreaLength;
      hash2.hemiLength = hemiLength;
      hash2.numDirectionalShadows = numDirectionalShadows;
      hash2.numPointShadows = numPointShadows;
      hash2.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init2() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init: init2,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get2(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units2) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units2) {
        gl.polygonOffset(factor, units2);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units2;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset2() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    texStorage2D,
    texSubImage2D,
    scissor,
    viewport,
    reset: reset2
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils2, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const hasMultisampledRenderToTexture = extensions.has("WEBGL_multisampled_render_to_texture");
  const MultisampledRenderToTextureExtension = hasMultisampledRenderToTexture ? extensions.get("WEBGL_multisampled_render_to_texture") : void 0;
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale2 = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale2 = maxSize / Math.max(image.width, image.height);
    }
    if (scale2 < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor2 = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor2(scale2 * image.width);
        const height = floor2(scale2 * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i = 0, il = texture.length; i < il; i++) {
        const attachmentProperties = properties.get(texture[i]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format);
    let glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils2.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils2.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
    } else {
      const levels = getMipLevels(texture, image, supportsMips);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      if (mipmaps.length > 0 && supportsMips) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          if (useTexStorage) {
            state.texSubImage2D(3553, i, 0, 0, glFormat, glType, mipmap);
          } else {
            state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
          }
        }
        texture.generateMipmaps = false;
      } else {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
          }
          state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        }
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i = 0; i < 6; i++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
      } else {
        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format), glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i = 0; i < 6; i++) {
        mipmaps = cubeImage[i].mipmaps;
        for (let j = 0; j < mipmaps.length; j++) {
          const mipmap = mipmaps[j];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
    } else {
      mipmaps = texture.mipmaps;
      for (let i = 0; i < 6; i++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            const mipmapImage = mipmap.image[i].image;
            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
          }
        }
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils2.convert(texture.format);
    const glType = utils2.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(36160, framebuffer);
    if (renderTarget.useRenderToTexture) {
      MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else {
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample || renderTarget.useRenderToTexture) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (renderTarget.useRenderToTexture) {
          MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && renderTarget.useRenderbuffer) {
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils2.convert(texture.format);
      const glType = utils2.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && renderTarget.useRenderbuffer) {
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i = 0, il = textures.length; i < il; i++) {
            const attachmentProperties = properties.get(textures[i]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (renderTarget.useRenderbuffer) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils2.convert(texture.format);
          const glType = utils2.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.useRenderbuffer) {
      if (isWebGL2) {
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        const invalidationArray = [36064];
        const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        if (!renderTarget.ignoreDepthForMultisampleCopy) {
          if (renderTarget.depthBuffer)
            mask |= 256;
          if (renderTarget.stencilBuffer)
            mask |= 1024;
        }
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        if (renderTarget.ignoreDepthForMultisampleCopy) {
          _gl.invalidateFramebuffer(36008, [depthStyle]);
          _gl.invalidateFramebuffer(36009, [depthStyle]);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        _gl.invalidateFramebuffer(36008, invalidationArray);
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && (renderTarget.useRenderbuffer || renderTarget.useRenderToTexture) ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p) {
    let extension;
    if (p === UnsignedByteType)
      return 5121;
    if (p === UnsignedShort4444Type)
      return 32819;
    if (p === UnsignedShort5551Type)
      return 32820;
    if (p === UnsignedShort565Type)
      return 33635;
    if (p === ByteType)
      return 5120;
    if (p === ShortType)
      return 5122;
    if (p === UnsignedShortType)
      return 5123;
    if (p === IntType)
      return 5124;
    if (p === UnsignedIntType)
      return 5125;
    if (p === FloatType)
      return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return 6406;
    if (p === RGBFormat)
      return 6407;
    if (p === RGBAFormat)
      return 6408;
    if (p === LuminanceFormat)
      return 6409;
    if (p === LuminanceAlphaFormat)
      return 6410;
    if (p === DepthFormat)
      return 6402;
    if (p === DepthStencilFormat)
      return 34041;
    if (p === RedFormat)
      return 6403;
    if (p === RedIntegerFormat)
      return 36244;
    if (p === RGFormat)
      return 33319;
    if (p === RGIntegerFormat)
      return 33320;
    if (p === RGBIntegerFormat)
      return 36248;
    if (p === RGBAIntegerFormat)
      return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }
}
ArrayCamera.prototype.isArrayCamera = true;
class Group extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
}
Group.prototype.isGroup = true;
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
}
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
DepthTexture.prototype.isDepthTexture = true;
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    const hasMultisampledRenderToTexture = renderer.extensions.has("WEBGL_multisampled_render_to_texture");
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let isMultisample = false;
    let xrFrame = null;
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const inputSourcesMap = /* @__PURE__ */ new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight
          );
        } else {
          isMultisample = attributes.antialias;
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? 35056 : 33189;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
          }
          const projectionlayerInit = {
            colorFormat: attributes.alpha || isMultisample ? 32856 : 32849,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          if (isMultisample) {
            newRenderTarget = new WebGLMultisampleRenderTarget(
              glProjLayer.textureWidth,
              glProjLayer.textureHeight,
              {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                stencilBuffer: attributes.stencil,
                ignoreDepth: glProjLayer.ignoreDepthValues,
                useRenderToTexture: hasMultisampledRenderToTexture
              }
            );
          } else {
            newRenderTarget = new WebGLRenderTarget(
              glProjLayer.textureWidth,
              glProjLayer.textureHeight,
              {
                format: attributes.alpha ? RGBAFormat : RGBFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                stencilBuffer: attributes.stencil,
                ignoreDepth: glProjLayer.ignoreDepthValues
              }
            );
          }
        }
        this.setFoveation(0);
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        inputSourcesMap.set(inputSources[i], controllers[i]);
      }
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          const camera = cameras[i];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      }
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        const controller = controllers[i];
        const inputSource = inputSources[i];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    refreshUniformsStandard(uniforms, material);
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _currentDrawBuffers = [];
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    if ("setAttribute" in _canvas2)
      _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils2, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils2 = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    _currentDrawBuffers[0] = 1029;
    info = new WebGLInfo();
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils2, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
    }
  }
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, geometry, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true)
        xr.updateCamera(camera);
      camera = xr.getCamera();
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera.isArrayCamera) {
      const cameras = camera.cameras;
      for (let i = 0, l = cameras.length; i < l; i++) {
        const camera2 = cameras[i];
        renderScene(currentRenderList, scene, camera2, camera2.viewport);
      }
    } else {
      renderScene(currentRenderList, scene, camera);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene, camera, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene, camera);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
  }
  function renderTransmissionPass(opaqueObjects, scene, camera) {
    if (_transmissionRenderTarget === null) {
      const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
      const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
      _transmissionRenderTarget = new renderTargetType(1024, 1024, {
        generateMipmaps: true,
        type: utils2.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping,
        useRenderToTexture: extensions.has("WEBGL_multisampled_render_to_texture")
      });
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    material.onBeforeRender(_this, scene, camera, geometry, object, group);
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = FrontSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = /* @__PURE__ */ new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(object, parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
  }
  function setProgram(camera, scene, geometry, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding2 = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
    const morphTargets = !!geometry.morphAttributes.position;
    const morphNormals = !!geometry.morphAttributes.normal;
    const morphTargetsCount = !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding2) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(
          _gl,
          "logDepthBufFC",
          2 / (Math.log(camera.far + 1) / Math.LN2)
        );
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(
            _gl,
            _vector3.setFromMatrixPosition(camera.matrixWorld)
          );
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (!!geometry && (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0)) {
      morphtargets.update(object, geometry, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture;
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__hasExternalTextures = true;
    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (renderTarget.useRenderToTexture) {
          console.warn("render-to-texture extension was disabled because an external texture was provided");
          renderTarget.useRenderToTexture = false;
          renderTarget.useRenderbuffer = true;
        }
      }
    }
  };
  this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    let useDefaultFramebuffer = true;
    if (renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
        state.bindFramebuffer(36160, null);
        useDefaultFramebuffer = false;
      } else if (renderTargetProperties.__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      } else if (renderTargetProperties.__hasExternalTextures) {
        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
      }
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.useRenderbuffer) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      let needsUpdate = false;
      if (renderTarget) {
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures2 = renderTarget.texture;
          if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== 36064) {
            for (let i = 0, il = textures2.length; i < il; i++) {
              _currentDrawBuffers[i] = 36064 + i;
            }
            _currentDrawBuffers.length = textures2.length;
            needsUpdate = true;
          }
        } else {
          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
            _currentDrawBuffers[0] = 36064;
            _currentDrawBuffers.length = 1;
            needsUpdate = true;
          }
        }
      } else {
        if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
          _currentDrawBuffers[0] = 1029;
          _currentDrawBuffers.length = 1;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          _gl.drawBuffers(_currentDrawBuffers);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
        }
      }
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer2, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils2.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils2.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils2.convert(textureFormat), utils2.convert(textureType), buffer2);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    let glFormat = utils2.convert(texture.format);
    if (capabilities.isWebGL2) {
      if (glFormat === 6407)
        glFormat = 32849;
      if (glFormat === 6408)
        glFormat = 32856;
    }
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils2.convert(dstTexture.format);
    const glType = utils2.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils2.convert(dstTexture.format);
    const glType = utils2.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image.width);
    _gl.pixelStorei(32878, image.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
WebGLRenderer.prototype.isWebGLRenderer = true;
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class FogExp2 {
  constructor(color, density = 25e-5) {
    this.name = "";
    this.color = new Color(color);
    this.density = density;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
FogExp2.prototype.isFogExp2 = true;
class Fog {
  constructor(color, near = 1, far = 1e3) {
    this.name = "";
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
Fog.prototype.isFog = true;
class Scene extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
}
Scene.prototype.isScene = true;
class InterleavedBuffer {
  constructor(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
InterleavedBuffer.prototype.isInterleavedBuffer = true;
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.applyMatrix4(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.applyNormalMatrix(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.transformDirection(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  setX(index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }
  setY(index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  }
  setZ(index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }
  getX(index) {
    return this.data.array[index * this.data.stride + this.offset];
  }
  getY(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  }
  getZ(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  }
  getW(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  }
  setXY(index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
class SpriteMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
}
SpriteMaterial.prototype.isSpriteMaterial = true;
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3();
const _worldScale = /* @__PURE__ */ new Vector3();
const _mvPosition = /* @__PURE__ */ new Vector3();
const _alignedPosition = /* @__PURE__ */ new Vector2();
const _rotatedPosition = /* @__PURE__ */ new Vector2();
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
const _vA = /* @__PURE__ */ new Vector3();
const _vB = /* @__PURE__ */ new Vector3();
const _vC = /* @__PURE__ */ new Vector3();
const _uvA = /* @__PURE__ */ new Vector2();
const _uvB = /* @__PURE__ */ new Vector2();
const _uvC = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
}
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale2, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale2);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /* @__PURE__ */ new Vector3();
const _v2$1 = /* @__PURE__ */ new Vector3();
class LOD extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;
    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, { distance, object });
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$2.setFromMatrixPosition(camera.matrixWorld);
      _v2$1.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false)
      data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
}
const _basePosition = /* @__PURE__ */ new Vector3();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector$5 = /* @__PURE__ */ new Vector3();
const _matrix = /* @__PURE__ */ new Matrix4();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  copy(source) {
    super.copy(source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector2 = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector2.x = skinWeight.getX(i);
      vector2.y = skinWeight.getY(i);
      vector2.z = skinWeight.getZ(i);
      vector2.w = skinWeight.getW(i);
      const scale2 = 1 / vector2.manhattanLength();
      if (scale2 !== Infinity) {
        vector2.multiplyScalar(scale2);
      } else {
        vector2.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector2.x, vector2.y, vector2.z, vector2.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  boneTransform(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(target).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
}
SkinnedMesh.prototype.isSkinnedMesh = true;
class Bone extends Object3D {
  constructor() {
    super();
    this.type = "Bone";
  }
}
Bone.prototype.isBone = true;
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding2) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding2);
    this.image = { data, width, height };
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture.prototype.isDataTexture = true;
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse2 = new Matrix4();
      if (this.bones[i]) {
        inverse2.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse2);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = ceilPowerOfTwo(size);
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size;
    return this;
  }
  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    super(array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _mesh = /* @__PURE__ */ new Mesh();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }
  copy(source) {
    super.copy(source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
InstancedMesh.prototype.isInstancedMesh = true;
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = true;
const _start$1 = /* @__PURE__ */ new Vector3();
const _end$1 = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start$1.fromBufferAttribute(positionAttribute, i - 1);
          _end$1.fromBufferAttribute(positionAttribute, i);
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start2 = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start2, l = end - 1; i < l; i += step) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          vStart.fromBufferAttribute(positionAttribute, a);
          vEnd.fromBufferAttribute(positionAttribute, b);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start2 = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i = start2, l = end - 1; i < l; i += step) {
          vStart.fromBufferAttribute(positionAttribute, i);
          vEnd.fromBufferAttribute(positionAttribute, i + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
}
Line.prototype.isLine = true;
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start.fromBufferAttribute(positionAttribute, i);
          _end.fromBufferAttribute(positionAttribute, i + 1);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
}
LineSegments.prototype.isLineSegments = true;
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = true;
let PointsMaterial$1 = class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
PointsMaterial$1.prototype.isPointsMaterial = true;
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3();
let Points$1 = class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial$1()) {
    super();
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start2 = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start2, il = end; i < il; i++) {
          const a = index.getX(i);
          _position$2.fromBufferAttribute(positionAttribute, a);
          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        const start2 = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i = start2, l = end; i < l; i++) {
          _position$2.fromBufferAttribute(positionAttribute, i);
          testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
};
Points$1.prototype.isPoints = true;
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
class VideoTexture extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
}
VideoTexture.prototype.isVideoTexture = true;
class CompressedTexture extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding2) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding2);
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
CompressedTexture.prototype.isCompressedTexture = true;
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
}
CanvasTexture.prototype.isCanvasTexture = true;
class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex2.x;
        vertexBuffer[i + 1] = vertex2.y;
        vertexBuffer[i + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i + 2] += 1;
          if (x2 < 0.2)
            uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector2, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector2.x === 0 && vector2.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector2) {
      return Math.atan2(vector2.z, -vector2.x);
    }
    function inclination(vector2) {
      return Math.atan2(-vector2.y, Math.sqrt(vector2.x * vector2.x + vector2.z * vector2.z));
    }
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      // (1/, , 0)
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      // (, 0, 1/)
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }
}
const _v0 = new Vector3();
const _v1$1 = new Vector3();
const _normal = new Vector3();
const _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        const { a, b, c } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash2 = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash2 in edgeData)) {
            edgeData[hash2] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
}
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache2 = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache2.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache2.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache2;
    return cache2;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0)
      t1 = 0;
    if (t2 > 1)
      t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp$1(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp$1(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
EllipseCurve.prototype.isEllipseCurve = true;
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
}
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init2(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init2(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init2(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
const tmp$1 = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p32;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp$1.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp$1;
    }
    const p12 = points[intPoint % l];
    const p22 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p32 = points[(intPoint + 2) % l];
    } else {
      tmp$1.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p32 = tmp$1;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p12), pow);
      let dt1 = Math.pow(p12.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p32), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p12.x, p22.x, p32.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p12.y, p22.y, p32.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p12.z, p22.z, p32.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p12.x, p22.x, p32.x, this.tension);
      py.initCatmullRom(p0.y, p12.y, p22.y, p32.y, this.tension);
      pz.initCatmullRom(p0.z, p12.z, p22.z, p32.z, this.tension);
    }
    point.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t, p0, p12, p22, p32) {
  const v0 = (p22 - p0) * 0.5;
  const v1 = (p32 - p12) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p12 - 2 * p22 + v0 + v1) * t3 + (-3 * p12 + 3 * p22 - 2 * v0 - v1) * t2 + v0 * t + p12;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p12, p22) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p12) + QuadraticBezierP2(t, p22);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p12, p22, p32) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p12) + CubicBezierP2(t, p22) + CubicBezierP3(t, p32);
}
class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve.prototype.isCubicBezierCurve = true;
class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
LineCurve.prototype.isLineCurve = true;
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
      QuadraticBezier(t, v0.z, v1.z, v2.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p12 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p32 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p12.x, p22.x, p32.x),
      CatmullRom(weight, p0.y, p12.y, p22.y, p32.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
}
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }
      i++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y);
    return this;
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start2, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start2, end, dim) > 0) {
    for (i = start2; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start2; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals$2(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start2, end) {
  if (!start2)
    return start2;
  if (!end)
    end = start2;
  let p = start2, again;
  do {
    again = false;
    if (!p.steiner && (equals$2(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  let p = start2;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals$2(a, b) && intersects$2(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start2 = b;
    }
    p = p.next;
  } while (p !== start2);
  return filterPoints(p);
}
function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
  let a = start2;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start2);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start2, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start2 = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start2, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  if (hx === qx)
    return m;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start2, minX, minY, invSize) {
  let p = start2;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start2);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start2) {
  let p = start2, leftmost = start2;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals$2(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals$2(p12, p22) {
  return p12.x === p22.x && p12.y === p22.y;
}
function intersects$2(p12, q1, p22, q2) {
  const o1 = sign$1(area(p12, q1, p22));
  const o2 = sign$1(area(p12, q1, q2));
  const o3 = sign$1(area(p22, q2, p12));
  const o4 = sign$1(area(p22, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p12, p22, q1))
    return true;
  if (o2 === 0 && onSegment(p12, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p22, p12, q2))
    return true;
  if (o4 === 0 && onSegment(p22, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects$2(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start2, end, dim) {
  let sum = 0;
  for (let i = start2, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      let depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      if (options.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start2 = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 0);
      }
      function buildSideFaces() {
        const start2 = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0)
            k = contour2.length - 1;
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp$1(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin;
        vertex2.y = points[j].y;
        vertex2.z = points[j].x * cos;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base2 = j + i * points.length;
        const a = base2;
        const b = base2 + points.length;
        const c = base2 + points.length + 1;
        const d = base2 + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.computeVertexNormals();
    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n = new Vector3();
      const base2 = segments * points.length * 3;
      for (let i = 0, j = 0; i < points.length; i++, j += 3) {
        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2];
        n2.x = normals[base2 + j + 0];
        n2.y = normals[base2 + j + 1];
        n2.z = normals[base2 + j + 2];
        n.addVectors(n1, n2).normalize();
        normals[j + 0] = normals[base2 + j + 0] = n.x;
        normals[j + 1] = normals[base2 + j + 1] = n.y;
        normals[j + 2] = normals[base2 + j + 2] = n.z;
      }
    }
  }
  static fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + i / thetaSegments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex2 = shapeVertices[i];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex2 = new Vector3();
    const normal = new Vector3();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex2.z = tube * Math.sin(v);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p,
      q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3();
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = i / tubularSegments * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);
        vertex2.x = P1.x + (cx * N.x + cy * B.x);
        vertex2.y = P1.y + (cx * N.y + cy * B.y);
        vertex2.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u, p5, q2, radius2, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q2 / p5 * u;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  static fromJSON(data) {
    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      const N = frames.normals[i];
      const B = frames.binormals[i];
      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P.x + radius * normal.x;
        vertex2.y = P.y + radius * normal.y;
        vertex2.z = P.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start2 = new Vector3();
      const end = new Vector3();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const groupStart = group.start;
          const groupCount = group.count;
          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + (j + 1) % 3);
              start2.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start2, end, edges) === true) {
                vertices.push(start2.x, start2.y, start2.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j;
            const index2 = 3 * i + (j + 1) % 3;
            start2.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start2, end, edges) === true) {
              vertices.push(start2.x, start2.y, start2.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
}
function isUniqueEdge(start2, end, edges) {
  const hash1 = `${start2.x},${start2.y},${start2.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start2.x},${start2.y},${start2.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1, hash2);
    return true;
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry
});
class ShadowMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
}
ShadowMaterial.prototype.isShadowMaterial = true;
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp$1(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = 0;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._sheen = 0;
    this._clearcoat = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.ior = source.ior;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
class MeshToonMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
}
MeshToonMaterial.prototype.isMeshToonMaterial = true;
class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
}
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var Materials = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial: PointsMaterial$1,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
const AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function(array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    const n = times.length;
    const result = new Array(n);
    for (let i = 0; i !== n; ++i)
      result[i] = i;
    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;
      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j]);
        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    }
    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(
            targetTrack.values,
            valueStart,
            referenceValue,
            0,
            targetTrack.values,
            valueStart
          );
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push(
        (i + numMorphTargets - 1) % numMorphTargets,
        i,
        (i + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache$1 = {
  enabled: false,
  files: {},
  add: function(key, file2) {
    if (this.enabled === false)
      return;
    this.files[key] = file2;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform2) {
      urlModifier = transform2;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file2) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file2)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
const loading = {};
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache$1.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad)
          onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    });
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        return new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i = 0, il = callbacks.length; i < il; i++) {
                    const callback = callbacks[i];
                    if (callback.onProgress)
                      callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
      } else {
        throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
      }
    }).then((stream) => {
      const response = new Response(stream);
      switch (this.responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, this.mimeType);
          });
        case "json":
          return response.json();
        default:
          return response.text();
      }
    }).then((data) => {
      Cache$1.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onLoad)
          callback.onLoad(data);
      }
      this.manager.itemEnd(url);
    }).catch((err) => {
      const callbacks = loading[url];
      delete loading[url];
      for (let i = 0, il = callbacks.length; i < il; i++) {
        const callback = callbacks[i];
        if (callback.onError)
          callback.onError(err);
      }
      this.manager.itemError(url);
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class AnimationLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const animations = [];
    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }
    return animations;
  }
}
class CompressedTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(url[i], function(buffer2) {
        const texDatas = scope.parse(buffer2, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(url, function(buffer2) {
        const texDatas = scope.parse(buffer2, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f = 0; f < faces; f++) {
            images[f] = { mipmaps: [] };
            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache$1.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache$1.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(urls[i], function(image) {
        texture.images[i] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  }
}
class DataTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer2) {
      const texData = scope.parse(buffer2);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      if (texData.generateMipmaps !== void 0) {
        texture.generateMipmaps = texData.generateMipmaps;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
Light.prototype.isLight = true;
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
}
HemisphereLight.prototype.isHemisphereLight = true;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = true;
class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
SpotLight.prototype.isSpotLight = true;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = true;
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
PointLight.prototype.isPointLight = true;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
DirectionalLight.prototype.isDirectionalLight = true;
class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
}
AmbientLight.prototype.isAmbientLight = true;
class RectAreaLight extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
RectAreaLight.prototype.isRectAreaLight = true;
class SphericalHarmonics3 {
  constructor() {
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal, target) {
    const x = normal.x, y = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }
    return this;
  }
  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }
    return array;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal, shBasis) {
    const x = normal.x, y = normal.y, z = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
LightProbe.prototype.isLightProbe = true;
class MaterialLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const textures = this.textures;
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name);
      }
      return textures[name];
    }
    const material = new Materials[json.type]();
    if (json.uuid !== void 0)
      material.uuid = json.uuid;
    if (json.name !== void 0)
      material.name = json.name;
    if (json.color !== void 0 && material.color !== void 0)
      material.color.setHex(json.color);
    if (json.roughness !== void 0)
      material.roughness = json.roughness;
    if (json.metalness !== void 0)
      material.metalness = json.metalness;
    if (json.sheen !== void 0)
      material.sheen = json.sheen;
    if (json.sheenColor !== void 0)
      material.sheenColor = new Color().setHex(json.sheenColor);
    if (json.sheenRoughness !== void 0)
      material.sheenRoughness = json.sheenRoughness;
    if (json.emissive !== void 0 && material.emissive !== void 0)
      material.emissive.setHex(json.emissive);
    if (json.specular !== void 0 && material.specular !== void 0)
      material.specular.setHex(json.specular);
    if (json.specularIntensity !== void 0)
      material.specularIntensity = json.specularIntensity;
    if (json.specularColor !== void 0 && material.specularColor !== void 0)
      material.specularColor.setHex(json.specularColor);
    if (json.shininess !== void 0)
      material.shininess = json.shininess;
    if (json.clearcoat !== void 0)
      material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== void 0)
      material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.transmission !== void 0)
      material.transmission = json.transmission;
    if (json.thickness !== void 0)
      material.thickness = json.thickness;
    if (json.attenuationDistance !== void 0)
      material.attenuationDistance = json.attenuationDistance;
    if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0)
      material.attenuationColor.setHex(json.attenuationColor);
    if (json.fog !== void 0)
      material.fog = json.fog;
    if (json.flatShading !== void 0)
      material.flatShading = json.flatShading;
    if (json.blending !== void 0)
      material.blending = json.blending;
    if (json.combine !== void 0)
      material.combine = json.combine;
    if (json.side !== void 0)
      material.side = json.side;
    if (json.shadowSide !== void 0)
      material.shadowSide = json.shadowSide;
    if (json.opacity !== void 0)
      material.opacity = json.opacity;
    if (json.format !== void 0)
      material.format = json.format;
    if (json.transparent !== void 0)
      material.transparent = json.transparent;
    if (json.alphaTest !== void 0)
      material.alphaTest = json.alphaTest;
    if (json.depthTest !== void 0)
      material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0)
      material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0)
      material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== void 0)
      material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== void 0)
      material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== void 0)
      material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== void 0)
      material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== void 0)
      material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== void 0)
      material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== void 0)
      material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== void 0)
      material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== void 0)
      material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0)
      material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0)
      material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0)
      material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0)
      material.rotation = json.rotation;
    if (json.linewidth !== 1)
      material.linewidth = json.linewidth;
    if (json.dashSize !== void 0)
      material.dashSize = json.dashSize;
    if (json.gapSize !== void 0)
      material.gapSize = json.gapSize;
    if (json.scale !== void 0)
      material.scale = json.scale;
    if (json.polygonOffset !== void 0)
      material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0)
      material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0)
      material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.dithering !== void 0)
      material.dithering = json.dithering;
    if (json.alphaToCoverage !== void 0)
      material.alphaToCoverage = json.alphaToCoverage;
    if (json.premultipliedAlpha !== void 0)
      material.premultipliedAlpha = json.premultipliedAlpha;
    if (json.visible !== void 0)
      material.visible = json.visible;
    if (json.toneMapped !== void 0)
      material.toneMapped = json.toneMapped;
    if (json.userData !== void 0)
      material.userData = json.userData;
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === "number") {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }
    if (json.uniforms !== void 0) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            break;
          case "m4":
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json.defines !== void 0)
      material.defines = json.defines;
    if (json.vertexShader !== void 0)
      material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0)
      material.fragmentShader = json.fragmentShader;
    if (json.extensions !== void 0) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }
    if (json.shading !== void 0)
      material.flatShading = json.shading === 1;
    if (json.size !== void 0)
      material.size = json.size;
    if (json.sizeAttenuation !== void 0)
      material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0)
      material.map = getTexture(json.map);
    if (json.matcap !== void 0)
      material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0)
      material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== void 0)
      material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0)
      material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0)
      material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0)
      material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0)
      material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0)
      material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0)
      material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0)
      material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0)
      material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0)
      material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0)
      material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0)
      material.specularMap = getTexture(json.specularMap);
    if (json.specularIntensityMap !== void 0)
      material.specularIntensityMap = getTexture(json.specularIntensityMap);
    if (json.specularColorMap !== void 0)
      material.specularColorMap = getTexture(json.specularColorMap);
    if (json.envMap !== void 0)
      material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== void 0)
      material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0)
      material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== void 0)
      material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== void 0)
      material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0)
      material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0)
      material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0)
      material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0)
      material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== void 0)
      material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== void 0)
      material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== void 0)
      material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== void 0)
      material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.transmissionMap !== void 0)
      material.transmissionMap = getTexture(json.transmissionMap);
    if (json.thicknessMap !== void 0)
      material.thicknessMap = getTexture(json.thicknessMap);
    if (json.sheenColorMap !== void 0)
      material.sheenColorMap = getTexture(json.sheenColorMap);
    if (json.sheenRoughnessMap !== void 0)
      material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
}
class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.substr(0, index + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
class BufferGeometryLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json2, uuid) {
      if (interleavedBufferMap[uuid] !== void 0)
        return interleavedBufferMap[uuid];
      const interleavedBuffers = json2.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer2 = getArrayBuffer(json2, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer2);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json2, uuid) {
      if (arrayBufferMap[uuid] !== void 0)
        return arrayBufferMap[uuid];
      const arrayBuffers = json2.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;
    if (index !== void 0) {
      const typedArray = getTypedArray(index.type, index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== void 0)
        bufferAttribute.name = attribute.name;
      if (attribute.usage !== void 0)
        bufferAttribute.setUsage(attribute.usage);
      if (attribute.updateRange !== void 0) {
        bufferAttribute.updateRange.offset = attribute.updateRange.offset;
        bufferAttribute.updateRange.count = attribute.updateRange.count;
      }
      geometry.setAttribute(key, bufferAttribute);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center = new Vector3();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name)
      geometry.name = json.name;
    if (json.userData)
      geometry.userData = json.userData;
    return geometry;
  }
}
class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      let json = null;
      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== void 0)
          onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      const metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  }
  async loadAsync(url, onProgress) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    const text = await loader.loadAsync(url, onProgress);
    const json = JSON.parse(text);
    const metadata = json.metadata;
    if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
      throw new Error("THREE.ObjectLoader: Can't load " + url);
    }
    return await scope.parseAsync(json);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function() {
      if (onLoad !== void 0)
        onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid] instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false)
        onLoad(object);
    }
    return object;
  }
  async parseAsync(json) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = await this.parseImagesAsync(json.images);
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function(child) {
      if (child.isBone)
        bones[child.uuid] = child;
    });
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries = {};
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];
        switch (data.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data);
            break;
          case "Geometry":
            console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
            break;
          default:
            if (data.type in Geometries) {
              geometry = Geometries[data.type].fromJSON(data, shapes);
            } else {
              console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
            }
        }
        geometry.uuid = data.uuid;
        if (data.name !== void 0)
          geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== void 0)
          geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json, textures) {
    const cache2 = {};
    const materials = {};
    if (json !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.type === "MultiMaterial") {
          const array = [];
          for (let j = 0; j < data.materials.length; j++) {
            const material = data.materials[j];
            if (cache2[material.uuid] === void 0) {
              cache2[material.uuid] = loader.parse(material);
            }
            array.push(cache2[material.uuid]);
          }
          materials[data.uuid] = array;
        } else {
          if (cache2[data.uuid] === void 0) {
            cache2[data.uuid] = loader.parse(data);
          }
          materials[data.uuid] = cache2[data.uuid];
        }
      }
    }
    return materials;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== void 0) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          images[image.uuid] = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                images[image.uuid].push(deserializedImage);
              } else {
                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
        } else {
          const deserializedImage = deserializeImage(image.url);
          if (deserializedImage !== null) {
            images[image.uuid] = deserializedImage;
          }
        }
      }
    }
    return images;
  }
  async parseImagesAsync(json) {
    const scope = this;
    const images = {};
    let loader;
    async function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return await loader.loadAsync(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          images[image.uuid] = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = await deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                images[image.uuid].push(deserializedImage);
              } else {
                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
        } else {
          const deserializedImage = await deserializeImage(image.url);
          if (deserializedImage !== null) {
            images[image.uuid] = deserializedImage;
          }
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === "number")
        return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    const textures = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        let texture;
        const image = images[data.image];
        if (Array.isArray(image)) {
          texture = new CubeTexture(image);
          if (image.length === 6)
            texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture(image.data, image.width, image.height);
          } else {
            texture = new Texture(image);
          }
          if (image)
            texture.needsUpdate = true;
        }
        texture.uuid = data.uuid;
        if (data.name !== void 0)
          texture.name = data.name;
        if (data.mapping !== void 0)
          texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== void 0)
          texture.offset.fromArray(data.offset);
        if (data.repeat !== void 0)
          texture.repeat.fromArray(data.repeat);
        if (data.center !== void 0)
          texture.center.fromArray(data.center);
        if (data.rotation !== void 0)
          texture.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0)
          texture.format = data.format;
        if (data.type !== void 0)
          texture.type = data.type;
        if (data.encoding !== void 0)
          texture.encoding = data.encoding;
        if (data.minFilter !== void 0)
          texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0)
          texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0)
          texture.anisotropy = data.anisotropy;
        if (data.flipY !== void 0)
          texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== void 0)
          texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0)
          texture.unpackAlignment = data.unpackAlignment;
        if (data.userData !== void 0)
          texture.userData = data.userData;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data, geometries, materials, textures, animations) {
    let object;
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === void 0)
        return void 0;
      if (Array.isArray(name)) {
        const array = [];
        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials[name];
    }
    function getTexture(uuid) {
      if (textures[uuid] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined texture", uuid);
      }
      return textures[uuid];
    }
    let geometry, material;
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          } else {
            object.background = getTexture(data.background);
          }
        }
        if (data.environment !== void 0) {
          object.environment = getTexture(data.environment);
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== void 0)
          object.focus = data.focus;
        if (data.zoom !== void 0)
          object.zoom = data.zoom;
        if (data.filmGauge !== void 0)
          object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0)
          object.filmOffset = data.filmOffset;
        if (data.view !== void 0)
          object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== void 0)
          object.zoom = data.zoom;
        if (data.view !== void 0)
          object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        break;
      case "PointLight":
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case "SpotLight":
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== void 0)
          object.bindMode = data.bindMode;
        if (data.bindMatrix !== void 0)
          object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== void 0)
          object.skeleton = data.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        const instanceColor = data.instanceColor;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
        if (instanceColor !== void 0)
          object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points$1(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0)
      object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0)
        object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate)
        object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== void 0)
        object.position.fromArray(data.position);
      if (data.rotation !== void 0)
        object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0)
        object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0)
        object.scale.fromArray(data.scale);
    }
    if (data.castShadow !== void 0)
      object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0)
      object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.bias !== void 0)
        object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== void 0)
        object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== void 0)
        object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0)
        object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0)
        object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0)
      object.visible = data.visible;
    if (data.frustumCulled !== void 0)
      object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0)
      object.renderOrder = data.renderOrder;
    if (data.userData !== void 0)
      object.userData = data.userData;
    if (data.layers !== void 0)
      object.layers.mask = data.layers;
    if (data.children !== void 0) {
      const children = data.children;
      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials, textures, animations));
      }
    }
    if (data.animations !== void 0) {
      const objectAnimations = data.animations;
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i];
        object.animations.push(animations[uuid]);
      }
    }
    if (data.type === "LOD") {
      if (data.autoUpdate !== void 0)
        object.autoUpdate = data.autoUpdate;
      const levels = data.levels;
      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0)
      return;
    object.traverse(function(child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
  /* DEPRECATED */
  setTexturePath(value) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(value);
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options) {
    this.options = options;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache$1.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache$1.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e) {
      if (onError)
        onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
let _context;
const AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        const bufferCopy = buffer2.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
class AmbientLightProbe extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
AmbientLightProbe.prototype.isAmbientLightProbe = true;
const _eyeRight = /* @__PURE__ */ new Matrix4();
const _eyeLeft = /* @__PURE__ */ new Matrix4();
const _projectionMatrix = /* @__PURE__ */ new Matrix4();
class StereoCamera {
  constructor() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(camera) {
    const cache2 = this._cache;
    const needsUpdate = cache2.focus !== camera.focus || cache2.fov !== camera.fov || cache2.aspect !== camera.aspect * this.aspect || cache2.near !== camera.near || cache2.far !== camera.far || cache2.zoom !== camera.zoom || cache2.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache2.focus = camera.focus;
      cache2.fov = camera.fov;
      cache2.aspect = camera.aspect * this.aspect;
      cache2.near = camera.near;
      cache2.far = camera.far;
      cache2.zoom = camera.zoom;
      cache2.eyeSep = this.eyeSep;
      _projectionMatrix.copy(camera.projectionMatrix);
      const eyeSepHalf = cache2.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache2.near / cache2.focus;
      const ymax = cache2.near * Math.tan(DEG2RAD * cache2.fov * 0.5) / cache2.zoom;
      let xmin, xmax;
      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;
      xmin = -ymax * cache2.aspect + eyeSepOnProjection;
      xmax = ymax * cache2.aspect + eyeSepOnProjection;
      _projectionMatrix.elements[0] = 2 * cache2.near / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(_projectionMatrix);
      xmin = -ymax * cache2.aspect - eyeSepOnProjection;
      xmax = ymax * cache2.aspect - eyeSepOnProjection;
      _projectionMatrix.elements[0] = 2 * cache2.near / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
}
class Clock {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
}
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
const _position$1 = /* @__PURE__ */ new Vector3();
const _quaternion$1 = /* @__PURE__ */ new Quaternion();
const _scale$1 = /* @__PURE__ */ new Vector3();
const _orientation$1 = /* @__PURE__ */ new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
    }
  }
}
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
}
const _position = /* @__PURE__ */ new Vector3();
const _quaternion = /* @__PURE__ */ new Quaternion();
const _scale = /* @__PURE__ */ new Vector3();
const _orientation = /* @__PURE__ */ new Vector3();
class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false)
      return;
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
}
class AudioAnalyser {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }
    return value / data.length;
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(accuIndex, weight) {
    const buffer2 = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer2[offset + i] = buffer2[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer2, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(weight) {
    const buffer2 = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer2, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(accuIndex) {
    const stride = this.valueSize, buffer2 = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(
        buffer2,
        offset,
        originalValueOffset,
        1 - weight,
        stride
      );
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer2, offset, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer2[i] !== buffer2[i + stride]) {
        binding.setValue(buffer2, offset);
        break;
      }
    }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const binding = this.binding;
    const buffer2 = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer2, originalValueOffset);
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer2[i] = buffer2[originalValueOffset + i % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  // mix functions
  _select(buffer2, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer2[dstOffset + i] = buffer2[srcOffset + i];
      }
    }
  }
  _slerp(buffer2, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer2, dstOffset, buffer2, dstOffset, buffer2, srcOffset, t);
  }
  _slerpAdditive(buffer2, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer2, workOffset, buffer2, dstOffset, buffer2, srcOffset);
    Quaternion.slerpFlat(buffer2, dstOffset, buffer2, dstOffset, buffer2, workOffset, t);
  }
  _lerp(buffer2, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer2[j] = buffer2[j] * s + buffer2[srcOffset + i] * t;
    }
  }
  _lerpAdditive(buffer2, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer2[j] = buffer2[j] + buffer2[srcOffset + i] * t;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
const _supportedObjectNames = ["material", "materials", "bones"];
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer2, offset) {
    buffer2[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer2, offset) {
    const source = this.resolvedProperty;
    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer2[offset++] = source[i];
    }
  }
  _getValue_arrayElement(buffer2, offset) {
    buffer2[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer2, offset) {
    this.resolvedProperty.toArray(buffer2, offset);
  }
  // Direct
  _setValue_direct(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer2[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer2[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer2[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationObjectGroup {
  constructor() {
    this.uuid = generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // remove & forget
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0)
      return bindings[index];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
}
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  // State & Scheduling
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode2, repetitions) {
    this.loop = mode2;
    this.repetitions = repetitions;
    return this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
}
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(
          PropertyBinding.create(root, trackName, path),
          track.ValueTypeName,
          track.getValueSize()
        );
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0]
        );
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        this._controlInterpolantsResultBuffer
      );
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  // get an existing action
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  // advance the time and update apply the animation
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  // remove a targeted clip from the cache
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class Uniform {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
class GLBufferAttribute {
  constructor(buffer2, type, itemSize, elementSize, count) {
    this.buffer = buffer2;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setBuffer(buffer2) {
    this.buffer = buffer2;
    return this;
  }
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  setCount(count) {
    this.count = count;
    return this;
  }
}
GLBufferAttribute.prototype.isGLBufferAttribute = true;
class Raycaster {
  constructor(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction) {
    this.ray.set(origin, direction);
  }
  setFromCamera(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects2, true);
    }
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(clamp$1(y / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(radius = 1, theta = 0, y = 0) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  }
  set(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$4 = /* @__PURE__ */ new Vector2();
class Box2 {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector2) {
    this.min.sub(vector2);
    this.max.add(vector2);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
Box2.prototype.isBox2 = true;
const _startP = /* @__PURE__ */ new Vector3();
const _startEnd = /* @__PURE__ */ new Vector3();
class Line3 {
  constructor(start2 = new Vector3(), end = new Vector3()) {
    this.start = start2;
    this.end = end;
  }
  set(start2, end) {
    this.start.copy(start2);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = clamp$1(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$3 = /* @__PURE__ */ new Vector3();
class SpotLightHelper extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new BufferGeometry();
    const positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p12 = i / l * Math.PI * 2;
      const p22 = j / l * Math.PI * 2;
      positions.push(
        Math.cos(p12),
        Math.sin(p12),
        1,
        Math.cos(p22),
        Math.sin(p22),
        1
      );
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$3);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
}
const _vector$2 = /* @__PURE__ */ new Vector3();
const _boneMatrix = /* @__PURE__ */ new Matrix4();
const _matrixWorldInv = /* @__PURE__ */ new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    super(geometry, material);
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
}
const _vector$1 = /* @__PURE__ */ new Vector3();
const _color1 = /* @__PURE__ */ new Color();
const _color2 = /* @__PURE__ */ new Color();
class HemisphereLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    if (this.color === void 0)
      this.material.vertexColors = true;
    const position = geometry.getAttribute("position");
    const colors = new Float32Array(position.count * 3);
    geometry.setAttribute("color", new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      const colors = mesh.geometry.getAttribute("color");
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i = 0, l = colors.count; i < l; i++) {
        const color = i < l / 2 ? _color1 : _color2;
        colors.setXYZ(i, color.r, color.g, color.b);
      }
      colors.needsUpdate = true;
    }
    mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
}
class PolarGridHelper extends LineSegments {
  constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const vertices = [];
    const colors = [];
    for (let i = 0; i <= radials; i++) {
      const v = i / radials * (Math.PI * 2);
      const x = Math.sin(v) * radius;
      const z = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z);
      const color = i & 1 ? color1 : color2;
      colors.push(color.r, color.g, color.b);
      colors.push(color.r, color.g, color.b);
    }
    for (let i = 0; i <= circles; i++) {
      const color = i & 1 ? color1 : color2;
      const r = radius - radius / circles * i;
      for (let j = 0; j < divisions; j++) {
        let v = j / divisions * (Math.PI * 2);
        let x = Math.sin(v) * r;
        let z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "PolarGridHelper";
  }
}
const _v1 = /* @__PURE__ */ new Vector3();
const _v2 = /* @__PURE__ */ new Vector3();
const _v3 = /* @__PURE__ */ new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === void 0)
      size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([
      -size,
      size,
      0,
      size,
      size,
      0,
      size,
      -size,
      0,
      -size,
      -size,
      0,
      -size,
      size,
      0
    ], 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    _v1.setFromMatrixPosition(this.light.matrixWorld);
    _v2.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3.subVectors(_v2, _v1);
    this.lightPlane.lookAt(_v2);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2);
    this.targetLine.scale.z = _v3.length();
  }
}
const _vector = /* @__PURE__ */ new Vector3();
const _camera = /* @__PURE__ */ new Camera$1();
class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
    const vertices = [];
    const colors = [];
    const pointMap = {};
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    addLine("n1", "n2", colorFrustum);
    addLine("n2", "n4", colorFrustum);
    addLine("n4", "n3", colorFrustum);
    addLine("n3", "n1", colorFrustum);
    addLine("f1", "f2", colorFrustum);
    addLine("f2", "f4", colorFrustum);
    addLine("f4", "f3", colorFrustum);
    addLine("f3", "f1", colorFrustum);
    addLine("n1", "f1", colorFrustum);
    addLine("n2", "f2", colorFrustum);
    addLine("n3", "f3", colorFrustum);
    addLine("n4", "f4", colorFrustum);
    addLine("p", "n1", colorCone);
    addLine("p", "n2", colorCone);
    addLine("p", "n3", colorCone);
    addLine("p", "n4", colorCone);
    addLine("u1", "u2", colorUp);
    addLine("u2", "u3", colorUp);
    addLine("u3", "u1", colorUp);
    addLine("c", "t", colorTarget);
    addLine("p", "c", colorCross);
    addLine("cn1", "cn2", colorCross);
    addLine("cn3", "cn4", colorCross);
    addLine("cf1", "cf2", colorCross);
    addLine("cf3", "cf4", colorCross);
    function addLine(a, b, color) {
      addPoint(a, color);
      addPoint(b, color);
    }
    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors.push(color.r, color.g, color.b);
      if (pointMap[id] === void 0) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    super(geometry, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix)
      this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1, h = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
    setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
    setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
    setPoint("n4", pointMap, geometry, _camera, w, h, -1);
    setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
    setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
    setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
    setPoint("f4", pointMap, geometry, _camera, w, h, 1);
    setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
    }
  }
}
const _box = /* @__PURE__ */ new Box3();
class BoxHelper extends LineSegments {
  constructor(object, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.object = object;
    this.type = "BoxHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      _box.setFromObject(this.object);
    }
    if (_box.isEmpty())
      return;
    const min = _box.min;
    const max = _box.max;
    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  }
}
class Box3Helper extends LineSegments {
  constructor(box, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.box = box;
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty())
      return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
}
class PlaneHelper extends Line {
  constructor(plane, size = 1, hex = 16776960) {
    const color = hex;
    const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size;
    const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
  }
  updateMatrixWorld(force) {
    let scale2 = -this.plane.constant;
    if (Math.abs(scale2) < 1e-8)
      scale2 = 1e-8;
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale2);
    this.children[0].material.side = scale2 < 0 ? BackSide : FrontSide;
    this.lookAt(this.plane.normal);
    super.updateMatrixWorld(force);
  }
}
const _axis = /* @__PURE__ */ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  // dir is assumed to be normalized
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: false }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
}
class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "AxesHelper";
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color = new Color();
    const array = this.geometry.attributes.color.array;
    color.set(xAxisColor);
    color.toArray(array, 0);
    color.toArray(array, 3);
    color.set(yAxisColor);
    color.toArray(array, 6);
    color.toArray(array, 9);
    color.set(zAxisColor);
    color.toArray(array, 12);
    color.toArray(array, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class ShapePath {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
    return this;
  }
  lineTo(x, y) {
    this.currentPath.lineTo(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath2 = inSubpaths[i];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
            continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x)
              return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0)
              return true;
            if (perpEdge < 0)
              continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y)
            continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
            return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0)
      return [];
    if (noHoles === true)
      return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx])
          mainIdx++;
        newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
          mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
      }
    }
    if (!newShapes[0])
      return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx)
                toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous)
          newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
}
const _floatView = new Float32Array(1);
const _int32View = new Int32Array(_floatView.buffer);
class DataUtils {
  // Converts float32 to float16 (stored as uint16 value).
  static toHalfFloat(val) {
    if (val > 65504) {
      console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504.");
      val = 65504;
    }
    _floatView[0] = val;
    const x = _int32View[0];
    let bits = x >> 16 & 32768;
    let m = x >> 12 & 2047;
    const e = x >> 23 & 255;
    if (e < 103)
      return bits;
    if (e > 142) {
      bits |= 31744;
      bits |= (e == 255 ? 0 : 1) && x & 8388607;
      return bits;
    }
    if (e < 113) {
      m |= 2048;
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    bits += m & 1;
    return bits;
  }
}
const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;
function MeshFaceMaterial(materials) {
  console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
  return materials;
}
function MultiMaterial(materials = []) {
  console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
  materials.isMultiMaterial = true;
  materials.materials = materials;
  materials.clone = function() {
    return materials.slice();
  };
  return materials;
}
function PointCloud(geometry, material) {
  console.warn("THREE.PointCloud has been renamed to THREE.Points.");
  return new Points$1(geometry, material);
}
function Particle(material) {
  console.warn("THREE.Particle has been renamed to THREE.Sprite.");
  return new Sprite(material);
}
function ParticleSystem(geometry, material) {
  console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
  return new Points$1(geometry, material);
}
function PointCloudMaterial(parameters) {
  console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial$1(parameters);
}
function ParticleBasicMaterial(parameters) {
  console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial$1(parameters);
}
function ParticleSystemMaterial(parameters) {
  console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial$1(parameters);
}
function Vertex(x, y, z) {
  console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
  return new Vector3(x, y, z);
}
function DynamicBufferAttribute(array, itemSize) {
  console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}
function Int8Attribute(array, itemSize) {
  console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
  return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
  console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
  return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
  console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
  return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
  console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
  return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
  console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
  return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
  console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
  return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
  console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
  return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
  console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
  return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
  console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
  return new Float64BufferAttribute(array, itemSize);
}
Curve.create = function(construct2, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct2.prototype = Object.create(Curve.prototype);
  construct2.prototype.constructor = construct2;
  construct2.prototype.getPoint = getPoint;
  return construct2;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
function AxisHelper(size) {
  console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
  return new AxesHelper(size);
}
function BoundingBoxHelper(object, color) {
  console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
  return new BoxHelper(object, color);
}
function EdgesHelper(object, hex) {
  console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== void 0 ? hex : 16777215 }));
}
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function WireframeHelper(object, hex) {
  console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== void 0 ? hex : 16777215 }));
}
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
function XHRLoader(manager) {
  console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
  return new FileLoader(manager);
}
function BinaryTextureLoader(manager) {
  console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
  return new DataTextureLoader(manager);
}
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere2) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere2);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector2) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector2.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector2) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector2.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector2) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector2.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector2) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector2.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector2) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector2.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere2) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere2);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a, b, c, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a, b, c, target);
};
Triangle.normal = function(a, b, c, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a, b, c, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options);
};
Shape.prototype.makeGeometry = function(options) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m);
};
Vector3.prototype.getScaleFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start2, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start2, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Uniform.prototype.onUpdate = function() {
  console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
  return this;
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    },
    set: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
function WebGLRenderTargetCube(width, height, options) {
  console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
  return new WebGLCubeRenderTarget(width, options);
}
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file2) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file2, function(buffer2) {
    scope.setBuffer(buffer2);
  });
  return this;
};
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
function CanvasRenderer() {
  console.error("THREE.CanvasRenderer has been removed");
}
function JSONLoader() {
  console.error("THREE.JSONLoader has been removed.");
}
const SceneUtils = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }
};
function LensFlare() {
  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}
function ParametricGeometry() {
  console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js");
  return new BufferGeometry();
}
function TextGeometry() {
  console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js");
  return new BufferGeometry();
}
function FontLoader() {
  console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
}
function Font() {
  console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
}
function ImmediateRenderObject() {
  console.error("THREE.ImmediateRenderObject has been removed.");
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
const three_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping,
  AddEquation,
  AddOperation,
  AdditiveAnimationBlendMode,
  AdditiveBlending,
  AlphaFormat,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  AmbientLightProbe,
  AnimationClip,
  AnimationLoader,
  AnimationMixer,
  AnimationObjectGroup,
  AnimationUtils,
  ArcCurve,
  ArrayCamera,
  ArrowHelper,
  Audio,
  AudioAnalyser,
  AudioContext,
  AudioListener,
  AudioLoader,
  AxesHelper,
  AxisHelper,
  BackSide,
  BasicDepthPacking,
  BasicShadowMap,
  BinaryTextureLoader,
  Bone,
  BooleanKeyframeTrack,
  BoundingBoxHelper,
  Box2,
  Box3,
  Box3Helper,
  BoxBufferGeometry: BoxGeometry,
  BoxGeometry,
  BoxHelper,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  ByteType,
  Cache: Cache$1,
  Camera: Camera$1,
  CameraHelper,
  CanvasRenderer,
  CanvasTexture,
  CatmullRomCurve3,
  CineonToneMapping,
  CircleBufferGeometry: CircleGeometry,
  CircleGeometry,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorKeyframeTrack,
  CompressedTexture,
  CompressedTextureLoader,
  ConeBufferGeometry: ConeGeometry,
  ConeGeometry,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeTextureLoader,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CubicInterpolant,
  CullFaceBack,
  CullFaceFront,
  CullFaceFrontBack,
  CullFaceNone,
  Curve,
  CurvePath,
  CustomBlending,
  CustomToneMapping,
  CylinderBufferGeometry: CylinderGeometry,
  CylinderGeometry,
  Cylindrical,
  DataTexture,
  DataTexture2DArray,
  DataTexture3D,
  DataTextureLoader,
  DataUtils,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DefaultLoadingManager,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DirectionalLightHelper,
  DiscreteInterpolant,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  DodecahedronGeometry,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicBufferAttribute,
  DynamicCopyUsage,
  DynamicDrawUsage,
  DynamicReadUsage,
  EdgesGeometry,
  EdgesHelper,
  EllipseCurve,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  ExtrudeGeometry,
  FaceColors,
  FileLoader,
  FlatShading,
  Float16BufferAttribute,
  Float32Attribute,
  Float32BufferAttribute,
  Float64Attribute,
  Float64BufferAttribute,
  FloatType,
  Fog,
  FogExp2,
  Font,
  FontLoader,
  FrontSide,
  Frustum,
  GLBufferAttribute,
  GLSL1,
  GLSL3,
  GammaEncoding,
  GreaterDepth,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  GridHelper,
  Group,
  HalfFloatType,
  HemisphereLight,
  HemisphereLightHelper,
  HemisphereLightProbe,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  IcosahedronGeometry,
  ImageBitmapLoader,
  ImageLoader,
  ImageUtils,
  ImmediateRenderObject,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  Int16Attribute,
  Int16BufferAttribute,
  Int32Attribute,
  Int32BufferAttribute,
  Int8Attribute,
  Int8BufferAttribute,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  InterpolateSmooth,
  InvertStencilOp,
  JSONLoader,
  KeepStencilOp,
  KeyframeTrack,
  LOD,
  LatheBufferGeometry: LatheGeometry,
  LatheGeometry,
  Layers,
  LensFlare,
  LessDepth,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  Light,
  LightProbe,
  Line,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineDashedMaterial,
  LineLoop,
  LinePieces,
  LineSegments,
  LineStrip,
  LinearEncoding,
  LinearFilter,
  LinearInterpolant,
  LinearMipMapLinearFilter,
  LinearMipMapNearestFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearToneMapping,
  Loader,
  LoaderUtils,
  LoadingManager,
  LoopOnce,
  LoopPingPong,
  LoopRepeat,
  LuminanceAlphaFormat,
  LuminanceFormat,
  MOUSE,
  Material,
  MaterialLoader,
  Math: MathUtils,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshFaceMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MultiMaterial,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipMapLinearFilter,
  NearestMipMapNearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColors,
  NoToneMapping,
  NormalAnimationBlendMode,
  NormalBlending,
  NotEqualDepth,
  NotEqualStencilFunc,
  NumberKeyframeTrack,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OctahedronBufferGeometry: OctahedronGeometry,
  OctahedronGeometry,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PCFShadowMap,
  PCFSoftShadowMap,
  PMREMGenerator,
  ParametricGeometry,
  Particle,
  ParticleBasicMaterial,
  ParticleSystem,
  ParticleSystemMaterial,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneBufferGeometry: PlaneGeometry,
  PlaneGeometry,
  PlaneHelper,
  PointCloud,
  PointCloudMaterial,
  PointLight,
  PointLightHelper,
  Points: Points$1,
  PointsMaterial: PointsMaterial$1,
  PolarGridHelper,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  PolyhedronGeometry,
  PositionalAudio,
  PropertyBinding,
  PropertyMixer,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  Quaternion,
  QuaternionKeyframeTrack,
  QuaternionLinearInterpolant,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBDEncoding,
  RGBEEncoding,
  RGBEFormat,
  RGBFormat,
  RGBIntegerFormat,
  RGBM16Encoding,
  RGBM7Encoding,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RectAreaLight,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  RingBufferGeometry: RingGeometry,
  RingGeometry,
  SRGB8_ALPHA8_ASTC_10x10_Format,
  SRGB8_ALPHA8_ASTC_10x5_Format,
  SRGB8_ALPHA8_ASTC_10x6_Format,
  SRGB8_ALPHA8_ASTC_10x8_Format,
  SRGB8_ALPHA8_ASTC_12x10_Format,
  SRGB8_ALPHA8_ASTC_12x12_Format,
  SRGB8_ALPHA8_ASTC_4x4_Format,
  SRGB8_ALPHA8_ASTC_5x4_Format,
  SRGB8_ALPHA8_ASTC_5x5_Format,
  SRGB8_ALPHA8_ASTC_6x5_Format,
  SRGB8_ALPHA8_ASTC_6x6_Format,
  SRGB8_ALPHA8_ASTC_8x5_Format,
  SRGB8_ALPHA8_ASTC_8x6_Format,
  SRGB8_ALPHA8_ASTC_8x8_Format,
  Scene,
  SceneUtils,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShadowMaterial,
  Shape,
  ShapeBufferGeometry: ShapeGeometry,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  ShortType,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  SmoothShading,
  Sphere,
  SphereBufferGeometry: SphereGeometry,
  SphereGeometry,
  Spherical,
  SphericalHarmonics3,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Sprite,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticCopyUsage,
  StaticDrawUsage,
  StaticReadUsage,
  StereoCamera,
  StreamCopyUsage,
  StreamDrawUsage,
  StreamReadUsage,
  StringKeyframeTrack,
  SubtractEquation,
  SubtractiveBlending,
  TOUCH,
  TangentSpaceNormalMap,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TetrahedronGeometry,
  TextGeometry,
  Texture,
  TextureLoader,
  TorusBufferGeometry: TorusGeometry,
  TorusGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TorusKnotGeometry,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  TubeBufferGeometry: TubeGeometry,
  TubeGeometry,
  UVMapping,
  Uint16Attribute,
  Uint16BufferAttribute,
  Uint32Attribute,
  Uint32BufferAttribute,
  Uint8Attribute,
  Uint8BufferAttribute,
  Uint8ClampedAttribute,
  Uint8ClampedBufferAttribute,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShort565Type,
  UnsignedShortType,
  VSMShadowMap,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  Vertex,
  VertexColors,
  VideoTexture,
  WebGL1Renderer,
  WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets,
  WebGLMultisampleRenderTarget,
  WebGLRenderTarget,
  WebGLRenderTargetCube,
  WebGLRenderer,
  WebGLUtils,
  WireframeGeometry,
  WireframeHelper,
  WrapAroundEnding,
  XHRLoader,
  ZeroCurvatureEnding,
  ZeroFactor,
  ZeroSlopeEnding,
  ZeroStencilOp,
  sRGBEncoding
}, Symbol.toStringTag, { value: "Module" }));
const _changeEvent = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
class OrbitControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    if (domElement === void 0)
      console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document)
      console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale2;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale2 = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("pointercancel", onPointerCancel);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove);
      scope.domElement.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale2 = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    const panUp = function() {
      const v = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale2 /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale2 *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove);
        scope.domElement.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false)
        return;
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("pointercancel", onPointerCancel);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
}
class MapControls extends OrbitControls {
  constructor(object, domElement) {
    super(object, domElement);
    this.screenSpacePanning = false;
    this.mouseButtons.LEFT = MOUSE.PAN;
    this.mouseButtons.RIGHT = MOUSE.ROTATE;
    this.touches.ONE = TOUCH.PAN;
    this.touches.TWO = TOUCH.DOLLY_ROTATE;
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var Instance$1 = {};
var interopRequireDefaultExports = {};
var interopRequireDefault = {
  get exports() {
    return interopRequireDefaultExports;
  },
  set exports(v) {
    interopRequireDefaultExports = v;
  }
};
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var _typeofExports = {};
var _typeof$1 = {
  get exports() {
    return _typeofExports;
  },
  set exports(v) {
    _typeofExports = v;
  }
};
(function(module) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(obj);
  }
  module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$1);
var classCallCheckExports = {};
var classCallCheck = {
  get exports() {
    return classCallCheckExports;
  },
  set exports(v) {
    classCallCheckExports = v;
  }
};
var hasRequiredClassCallCheck;
function requireClassCallCheck() {
  if (hasRequiredClassCallCheck)
    return classCallCheckExports;
  hasRequiredClassCallCheck = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(classCallCheck);
  return classCallCheckExports;
}
var createClassExports = {};
var createClass = {
  get exports() {
    return createClassExports;
  },
  set exports(v) {
    createClassExports = v;
  }
};
var hasRequiredCreateClass;
function requireCreateClass() {
  if (hasRequiredCreateClass)
    return createClassExports;
  hasRequiredCreateClass = 1;
  (function(module) {
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(createClass);
  return createClassExports;
}
var assertThisInitializedExports = {};
var assertThisInitialized = {
  get exports() {
    return assertThisInitializedExports;
  },
  set exports(v) {
    assertThisInitializedExports = v;
  }
};
var hasRequiredAssertThisInitialized;
function requireAssertThisInitialized() {
  if (hasRequiredAssertThisInitialized)
    return assertThisInitializedExports;
  hasRequiredAssertThisInitialized = 1;
  (function(module) {
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(assertThisInitialized);
  return assertThisInitializedExports;
}
var inheritsExports = {};
var inherits = {
  get exports() {
    return inheritsExports;
  },
  set exports(v) {
    inheritsExports = v;
  }
};
var setPrototypeOfExports = {};
var setPrototypeOf = {
  get exports() {
    return setPrototypeOfExports;
  },
  set exports(v) {
    setPrototypeOfExports = v;
  }
};
var hasRequiredSetPrototypeOf;
function requireSetPrototypeOf() {
  if (hasRequiredSetPrototypeOf)
    return setPrototypeOfExports;
  hasRequiredSetPrototypeOf = 1;
  (function(module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p5) {
        o2.__proto__ = p5;
        return o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o, p);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(setPrototypeOf);
  return setPrototypeOfExports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits)
    return inheritsExports;
  hasRequiredInherits = 1;
  (function(module) {
    var setPrototypeOf2 = requireSetPrototypeOf();
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        setPrototypeOf2(subClass, superClass);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(inherits);
  return inheritsExports;
}
var possibleConstructorReturnExports = {};
var possibleConstructorReturn = {
  get exports() {
    return possibleConstructorReturnExports;
  },
  set exports(v) {
    possibleConstructorReturnExports = v;
  }
};
var hasRequiredPossibleConstructorReturn;
function requirePossibleConstructorReturn() {
  if (hasRequiredPossibleConstructorReturn)
    return possibleConstructorReturnExports;
  hasRequiredPossibleConstructorReturn = 1;
  (function(module) {
    var _typeof2 = _typeofExports["default"];
    var assertThisInitialized2 = requireAssertThisInitialized();
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof2(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return assertThisInitialized2(self2);
    }
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(possibleConstructorReturn);
  return possibleConstructorReturnExports;
}
var getPrototypeOfExports = {};
var getPrototypeOf = {
  get exports() {
    return getPrototypeOfExports;
  },
  set exports(v) {
    getPrototypeOfExports = v;
  }
};
var hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  if (hasRequiredGetPrototypeOf)
    return getPrototypeOfExports;
  hasRequiredGetPrototypeOf = 1;
  (function(module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf3(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(getPrototypeOf);
  return getPrototypeOfExports;
}
const require$$8$1 = /* @__PURE__ */ getAugmentedNamespace(three_module);
function globals$1(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4;
var PJD_NODATUM = 5;
var SRS_WGS84_SEMIMAJOR = 6378137;
var SRS_WGS84_SEMIMINOR = 6356752314e-3;
var SRS_WGS84_ESQUARED = 0.0066943799901413165;
var SEC_TO_RAD = 484813681109536e-20;
var HALF_PI = Math.PI / 2;
var SIXTH = 0.16666666666666666;
var RA4 = 0.04722222222222222;
var RA6 = 0.022156084656084655;
var EPSLN = 1e-10;
var D2R$1 = 0.017453292519943295;
var R2D = 57.29577951308232;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
var SPI = 3.14159265359;
var exports$2 = {};
exports$2.greenwich = 0;
exports$2.lisbon = -9.131906111111;
exports$2.paris = 2.337229166667;
exports$2.bogota = -74.080916666667;
exports$2.madrid = -3.687938888889;
exports$2.rome = 12.452333333333;
exports$2.bern = 7.439583333333;
exports$2.jakarta = 106.807719444444;
exports$2.ferro = -17.666666666667;
exports$2.brussels = 4.367975;
exports$2.stockholm = 18.058277777778;
exports$2.athens = 23.7163375;
exports$2.oslo = 10.722916666667;
const units = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
function projStr(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split("=");
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v) {
      self2.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self2.lat0 = v * D2R$1;
    },
    lat_1: function(v) {
      self2.lat1 = v * D2R$1;
    },
    lat_2: function(v) {
      self2.lat2 = v * D2R$1;
    },
    lat_ts: function(v) {
      self2.lat_ts = v * D2R$1;
    },
    lon_0: function(v) {
      self2.long0 = v * D2R$1;
    },
    lon_1: function(v) {
      self2.long1 = v * D2R$1;
    },
    lon_2: function(v) {
      self2.long2 = v * D2R$1;
    },
    alpha: function(v) {
      self2.alpha = parseFloat(v) * D2R$1;
    },
    gamma: function(v) {
      self2.rectified_grid_angle = parseFloat(v);
    },
    lonc: function(v) {
      self2.longc = v * D2R$1;
    },
    x_0: function(v) {
      self2.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self2.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self2.k0 = parseFloat(v);
    },
    k: function(v) {
      self2.k0 = parseFloat(v);
    },
    a: function(v) {
      self2.a = parseFloat(v);
    },
    b: function(v) {
      self2.b = parseFloat(v);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v) {
      self2.zone = parseInt(v, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v) {
      self2.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self2.to_meter = parseFloat(v);
    },
    units: function(v) {
      self2.units = v;
      var unit = match(units, v);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self2.from_greenwich = v * D2R$1;
    },
    pm: function(v) {
      var pm = match(exports$2, v);
      self2.from_greenwich = (pm ? pm : parseFloat(v)) * D2R$1;
    },
    nadgrids: function(v) {
      if (v === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self2.axis = v;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
function Parser(text) {
  if (typeof text !== "string") {
    throw new Error("not a string");
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ",") {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === "]") {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === "[") {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = "";
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === "PARAMETER") {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj[key] = v;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      v[0] = ["name", v[0]];
      mapit(obj, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}
var D2R = 0.017453292519943295;
function rename(obj, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params2.length === 3) {
      obj[outName] = params2[2](obj[outName]);
    }
  }
}
function d2r(input) {
  return input * D2R;
}
function cleanWKT(wkt2) {
  if (wkt2.type === "GEOGCS") {
    wkt2.projName = "longlat";
  } else if (wkt2.type === "LOCAL_CS") {
    wkt2.projName = "identity";
    wkt2.local = true;
  } else {
    if (typeof wkt2.PROJECTION === "object") {
      wkt2.projName = Object.keys(wkt2.PROJECTION)[0];
    } else {
      wkt2.projName = wkt2.PROJECTION;
    }
  }
  if (wkt2.AXIS) {
    var axisOrder = "";
    for (var i = 0, ii = wkt2.AXIS.length; i < ii; ++i) {
      var axis = [wkt2.AXIS[i][0].toLowerCase(), wkt2.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt2.axis = axisOrder;
    }
  }
  if (wkt2.UNIT) {
    wkt2.units = wkt2.UNIT.name.toLowerCase();
    if (wkt2.units === "metre") {
      wkt2.units = "meter";
    }
    if (wkt2.UNIT.convert) {
      if (wkt2.type === "GEOGCS") {
        if (wkt2.DATUM && wkt2.DATUM.SPHEROID) {
          wkt2.to_meter = wkt2.UNIT.convert * wkt2.DATUM.SPHEROID.a;
        }
      } else {
        wkt2.to_meter = wkt2.UNIT.convert;
      }
    }
  }
  var geogcs = wkt2.GEOGCS;
  if (wkt2.type === "GEOGCS") {
    geogcs = wkt2;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt2.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt2.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt2.datumCode.slice(0, 2) === "d_") {
      wkt2.datumCode = wkt2.datumCode.slice(2);
    }
    if (wkt2.datumCode === "new_zealand_geodetic_datum_1949" || wkt2.datumCode === "new_zealand_1949") {
      wkt2.datumCode = "nzgd49";
    }
    if (wkt2.datumCode === "wgs_1984" || wkt2.datumCode === "world_geodetic_system_1984") {
      if (wkt2.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt2.sphere = true;
      }
      wkt2.datumCode = "wgs84";
    }
    if (wkt2.datumCode.slice(-6) === "_ferro") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -6);
    }
    if (wkt2.datumCode.slice(-8) === "_jakarta") {
      wkt2.datumCode = wkt2.datumCode.slice(0, -8);
    }
    if (~wkt2.datumCode.indexOf("belge")) {
      wkt2.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt2.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt2.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt2.ellps = "intl";
      }
      wkt2.a = geogcs.DATUM.SPHEROID.a;
      wkt2.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt2.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt2.datumCode.indexOf("osgb_1936")) {
      wkt2.datumCode = "osgb36";
    }
    if (~wkt2.datumCode.indexOf("osni_1952")) {
      wkt2.datumCode = "osni52";
    }
    if (~wkt2.datumCode.indexOf("tm65") || ~wkt2.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt2.datumCode = "ire65";
    }
    if (wkt2.datumCode === "ch1903+") {
      wkt2.datumCode = "ch1903";
    }
    if (~wkt2.datumCode.indexOf("israel")) {
      wkt2.datumCode = "isr93";
    }
  }
  if (wkt2.b && !isFinite(wkt2.b)) {
    wkt2.b = wkt2.a;
  }
  function toMeter(input) {
    var ratio = wkt2.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt2, a);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  if (!wkt2.long0 && wkt2.longc && (wkt2.projName === "Albers_Conic_Equal_Area" || wkt2.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt2.long0 = wkt2.longc;
  }
  if (!wkt2.lat_ts && wkt2.lat1 && (wkt2.projName === "Stereographic_South_Pole" || wkt2.projName === "Polar Stereographic (variant B)")) {
    wkt2.lat0 = d2r(wkt2.lat1 > 0 ? 90 : -90);
    wkt2.lat_ts = wkt2.lat1;
  }
}
function wkt(wkt2) {
  var lisp = parseString(wkt2);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(["name", name]);
  lisp.unshift(["type", type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
}
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[name] = projStr(arguments[1]);
      } else {
        defs[name] = wkt(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        } else {
          defs(v);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
globals$1(defs);
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs;
}
var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function testWKT(code) {
  return codeWords.some(function(word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ["3857", "900913", "3785", "102113"];
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs[code];
    }
    if (testWKT(code)) {
      var out = wkt(code);
      if (checkMercator(out)) {
        return defs["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projStr(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projStr(code);
    }
  } else {
    return code;
  }
}
function extend$3(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
function msfnz(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
function sign(x) {
  return x < 0 ? -1 : 1;
}
function adjust_lon(x) {
  return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
}
function tsfnz(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
function phi2z(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
function init$v() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward$u(p) {
  var lon = p.x;
  var lat = p.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}
function inverse$u(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));
  p.x = lon;
  p.y = lat;
  return p;
}
var names$w = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const merc = {
  init: init$v,
  forward: forward$u,
  inverse: inverse$u,
  names: names$w
};
function init$u() {
}
function identity(pt) {
  return pt;
}
var names$v = ["longlat", "identity"];
const longlat = {
  init: init$u,
  forward: identity,
  inverse: identity,
  names: names$v
};
var projs = [merc, longlat];
var names$u = {};
var projStore = [];
function add$2(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names$u[n.toLowerCase()] = len;
  });
  return this;
}
function get$5(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names$u[n] !== "undefined" && projStore[names$u[n]]) {
    return projStore[names$u[n]];
  }
}
function start() {
  projs.forEach(add$2);
}
const projections = {
  start,
  add: add$2,
  get: get$5
};
var exports$1 = {};
exports$1.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports$1.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports$1.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports$1.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports$1.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
exports$1.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports$1.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports$1.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
exports$1.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports$1.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports$1.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports$1.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports$1.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports$1.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
exports$1.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports$1.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports$1.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports$1.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports$1.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports$1.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports$1.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports$1.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports$1.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports$1.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports$1.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports$1.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports$1.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports$1.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports$1.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
exports$1.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
exports$1.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports$1.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports$1.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
exports$1.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
exports$1.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
exports$1.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports$1.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
exports$1.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
exports$1.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports$1.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports$1.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = exports$1.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports$1.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function eccentricity(a, b, rf, R_A) {
  var a2 = a * a;
  var b2 = b * b;
  var es = (a2 - b2) / a2;
  var e = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es);
  }
  var ep2 = (a2 - b2) / b2;
  return {
    es,
    e,
    ep2
  };
}
function sphere(a, b, rf, ellps, sphere2) {
  if (!a) {
    var ellipse = match(exports$1, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b) {
    b = (1 - 1 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere2 = true;
    b = a;
  }
  return {
    a,
    b,
    rf,
    sphere: sphere2
  };
}
var exports = {};
exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
exports.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
exports.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a;
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var loadedNadgrids = {};
function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r) {
    return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
function Projection$3(srsCode, callback) {
  if (!(this instanceof Projection$3)) {
    return new Projection$3(srsCode);
  }
  callback = callback || function(error) {
    if (error) {
      throw error;
    }
  };
  var json = parse(srsCode);
  if (typeof json !== "object") {
    callback(srsCode);
    return;
  }
  var ourProj = Projection$3.projections.get(json.projName);
  if (!ourProj) {
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match(exports, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum(
    json.datumCode,
    json.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend$3(this, json);
  extend$3(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  this.init();
  callback(null, this);
}
Projection$3.projections = projections;
Projection$3.projections.start();
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p, es, a, b) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X = p.x;
  var Y = p.y;
  var Z2 = p.z ? p.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
  if (P / a < genau) {
    Longitude = 0;
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    Longitude = Math.atan2(Y, X);
  }
  CT = Z2 / RR;
  ST = P / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform(source, dest, point) {
  if (compareDatums(source, dest)) {
    return point;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }
  point = geodeticToGeocentric(point, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point;
}
function applyGridShift(source, inverse2, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point.x, y: point.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var attemptedGrids = [];
  for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    grid.mandatory;
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
      continue;
    }
    output = applySubgridShift(input, inverse2, subgrid);
    if (!isNaN(output.x)) {
      break;
    }
  }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse2, ct) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse2) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct) {
  var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
  var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
  var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx++;
  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx += ct.lim[0];
  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx--;
  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
function adjust_axis(crs, denorm, point) {
  var xin = point.x, yin = point.y, zin = point.z || 0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === void 0) {
      continue;
    }
    if (i === 0) {
      v = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = "x";
      } else {
        t = "y";
      }
    } else if (i === 1) {
      v = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = "y";
      } else {
        t = "x";
      }
    } else {
      v = zin;
      t = "z";
    }
    switch (crs.axis[i]) {
      case "e":
        out[t] = v;
        break;
      case "w":
        out[t] = -v;
        break;
      case "n":
        out[t] = v;
        break;
      case "s":
        out[t] = -v;
        break;
      case "u":
        if (point[t] !== void 0) {
          out.z = v;
        }
        break;
      case "d":
        if (point[t] !== void 0) {
          out.z = -v;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
function common$1(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
function checkSanity(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== "WGS84";
}
function transform$2(source, dest, point, enforceAxis) {
  var wgs842;
  if (Array.isArray(point)) {
    point = common$1(point);
  }
  checkSanity(point);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Projection$3("WGS84");
    point = transform$2(source, wgs842, point, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point = adjust_axis(source, false, point);
  }
  if (source.projName === "longlat") {
    point = {
      x: point.x * D2R$1,
      y: point.y * D2R$1,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point);
    if (!point) {
      return;
    }
  }
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis(dest, true, point);
  }
  return point;
}
var wgs84 = Projection$3("WGS84");
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform$2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform$2(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}
function checkProj(item) {
  if (item instanceof Projection$3) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Projection$3(item);
}
function proj4$1(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === "undefined") {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
var NUM_100K_SETS = 6;
var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
var A = 65;
var I = 73;
var O = 79;
var V = 86;
var Z = 90;
const mgrs = {
  forward: forward$t,
  inverse: inverse$t,
  toPoint
};
function forward$t(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse$t(mgrs2) {
  var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs2) {
  var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A2, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A2 + (1 - T + C) * A2 * A2 * A2 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T + 9 * C + 4 * C * C) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm2) {
  var UTMNorthing = utm2.northing;
  var UTMEasting = utm2.easting;
  var zoneLetter = utm2.zoneLetter;
  var zoneNumber = utm2.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C12, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;
  var x = UTMEasting - 5e5;
  var y = UTMNorthing;
  if (zoneLetter < "N") {
    y -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);
  var lon = (D - (1 + 2 * T1 + C12) * D * D * D / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;
  if (utm2.accuracy) {
    var topRight = UTMtoLL({
      northing: utm2.northing + utm2.accuracy,
      easting: utm2.easting + utm2.accuracy,
      zoneLetter: utm2.zoneLetter,
      zoneNumber: utm2.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat,
      lon
    };
  }
  return result;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode(utm2, accuracy) {
  var seasting = "00000" + utm2.easting, snorthing = "00000" + utm2.northing;
  return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }
  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }
  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;
    if (colInt === I) {
      colInt++;
    }
  }
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }
  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;
    if (rowInt === I) {
      rowInt++;
    }
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i === 0 || i + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i, i += 2);
  var set2 = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set2);
  var north100k = getNorthingFromChar(hunK.charAt(1), set2);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e, set2) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n, set2) {
  if (n > "V") {
    throw "MGRSPoint given invalid Northing " + n;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    if (curRow > V) {
      if (rewindMarker) {
        throw "Bad character: " + n;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0;
  } else if (typeof x === "object") {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0;
  } else if (typeof x === "string" && typeof y === "undefined") {
    var coords = x.split(",");
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Point.fromMGRS = function(mgrsStr) {
  return new Point(toPoint(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return forward$t([this.x, this.y], accuracy);
};
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.013020833333333334;
var C48 = 0.007120768229166667;
var C66 = 0.3645833333333333;
var C68 = 0.005696614583333333;
var C88 = 0.3076171875;
function pj_enfn(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}
function pj_mlfn(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}
var MAX_ITER$3 = 20;
function pj_inv_mlfn(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER$3; i; --i) {
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
function init$t() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward$s(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b) - 1) < EPSLN) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);
      if (b >= 1) {
        if (b - 1 > EPSLN) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }
      if (lat < 0) {
        y = -y;
      }
      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse$s(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);
    if (y < 0) {
      lat = -lat;
    }
    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  } else {
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = HALF_PI * sign(y);
      lon = 0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$t = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const tmerc = {
  init: init$t,
  forward: forward$s,
  inverse: inverse$s,
  names: names$t
};
function sinh(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
}
function hypot(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
}
function log1py(x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
}
function asinhy(x) {
  var y = Math.abs(x);
  y = log1py(y * (1 + y / (hypot(1, y) + 1)));
  return x < 0 ? -y : y;
}
function gatg(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;
  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }
  return B + h * Math.sin(2 * B);
}
function clens(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;
  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}
function cosh$1(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
}
function clens_cmplx(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh$1(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }
  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
}
function init$s() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens(this.gtu, 2 * Z2));
}
function forward$r(p) {
  var Ce = adjust_lon(p.x - this.long0);
  var Cn = p.y;
  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));
  var tmp2 = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp2[0];
  Ce = Ce + tmp2[1];
  var x;
  var y;
  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse$r(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp2 = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp2[0];
    Ce = Ce + tmp2[1];
    Ce = Math.atan(sinh(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$s = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const etmerc = {
  init: init$s,
  forward: forward$r,
  inverse: inverse$r,
  names: names$s
};
function adjust_zone(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var dependsOn = "etmerc";
function init$r() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R$1;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}
var names$r = ["Universal Transverse Mercator System", "utm"];
const utm = {
  init: init$r,
  names: names$r,
  dependsOn
};
function srat(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var MAX_ITER$2 = 20;
function init$q() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}
function forward$q(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}
function inverse$q(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER$2; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$q = ["gauss"];
const gauss = {
  init: init$q,
  forward: forward$q,
  inverse: inverse$q,
  names: names$q
};
function init$p() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward$p(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse$p(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
}
var names$p = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const sterea = {
  init: init$p,
  forward: forward$p,
  inverse: inverse$p,
  names: names$p
};
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init$o() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward$o(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A2, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A2 * sinX;
    } else {
      A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A2 * cosX * Math.sin(dlon) + this.x0;
  }
  return p;
}
function inverse$o(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    } else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
    } else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$o = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const stere = {
  init: init$o,
  forward: forward$o,
  inverse: inverse$o,
  names: names$o,
  ssfn_
};
function init$n() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function forward$n(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
  var I2 = this.alpha * (p.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function inverse$n(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I2 / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }
  p.x = lambda;
  p.y = phy;
  return p;
}
var names$n = ["somerc"];
const somerc = {
  init: init$n,
  forward: forward$n,
  inverse: inverse$n,
  names: names$n
};
var TOL = 1e-7;
function isTypeA(P) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
  return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1;
}
function init$m() {
  var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle * D2R$1;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D - 1;
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    this.E = F += D;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    if (con < -Math.pi) {
      lam2 -= TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  this.A * this.B;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}
function forward$m(p) {
  var coords = {};
  var S, T, U, V2, W, temp, u, v;
  p.x = p.x - this.lam0;
  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V2 = Math.sin(this.B * p.x);
    U = (S * this.singam - V2 * this.cosgam) / T;
    if (Math.abs(Math.abs(U) - 1) < EPSLN) {
      throw new Error();
    }
    v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
    temp = Math.cos(this.B * p.x);
    if (Math.abs(temp) < TOL) {
      u = this.A * p.x;
    } else {
      u = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp);
    }
  } else {
    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p.y;
  }
  if (this.no_rot) {
    coords.x = u;
    coords.y = v;
  } else {
    u -= this.u_0;
    coords.x = v * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse$m(p) {
  var u, v, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p.x = (p.x - this.x0) * (1 / this.a);
  p.y = (p.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v = p.y;
    u = p.x;
  } else {
    v = p.x * this.cosrot - p.y * this.sinrot;
    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
  }
  coords.x += this.lam0;
  return coords;
}
var names$m = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const omerc = {
  init: init$m,
  forward: forward$m,
  inverse: inverse$m,
  names: names$m
};
function init$l() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);
  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward$l(p) {
  var lon = p.x;
  var lat = p.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
}
function inverse$l(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
var names$l = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const lcc = {
  init: init$l,
  forward: forward$l,
  inverse: inverse$l,
  names: names$l
};
function init$k() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward$k(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return p;
}
function inverse$k(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;
  var tmp2 = p.x;
  p.x = p.y;
  p.y = tmp2;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p;
}
var names$k = ["Krovak", "krovak"];
const krovak = {
  init: init$k,
  forward: forward$k,
  inverse: inverse$k,
  names: names$k
};
function mlfn(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
function e0fn(x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
}
function e1fn(x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
}
function e2fn(x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
}
function e3fn(x) {
  return x * x * x * (35 / 3072);
}
function gN(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}
function adjust_lat(x) {
  return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
}
function imlfn(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$j() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward$j(p) {
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse$j(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;
}
var names$j = ["Cassini", "Cassini_Soldner", "cass"];
const cass = {
  init: init$j,
  forward: forward$j,
  inverse: inverse$j,
  names: names$j
};
function qsfnz(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
function init$i() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward$i(p) {
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }
        break;
    }
  }
  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}
function inverse$i(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = x * x + y * y;
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }
  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
}
var P00 = 0.3333333333333333;
var P01 = 0.17222222222222222;
var P02 = 0.10257936507936508;
var P10 = 0.06388888888888888;
var P11 = 0.0664021164021164;
var P20 = 0.016415012942191543;
function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}
function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}
var names$i = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const laea = {
  init: init$i,
  forward: forward$i,
  inverse: inverse$i,
  names: names$i,
  S_POLE,
  N_POLE,
  EQUIT,
  OBLIQ
};
function asinz(x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }
  return Math.asin(x);
}
function init$h() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward$h(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse$h(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names$h = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const aea = {
  init: init$h,
  forward: forward$h,
  inverse: inverse$h,
  names: names$h,
  phi1z
};
function init$g() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward$g(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse$g(p) {
  var rh;
  var sinc, cosc;
  var c;
  var lon, lat;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$g = ["gnom"];
const gnom = {
  init: init$g,
  forward: forward$g,
  inverse: inverse$g,
  names: names$g
};
function iqsfnz(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1e-6) {
    if (q < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
function init$f() {
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward$f(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse$f(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$f = ["cea"];
const cea = {
  init: init$f,
  forward: forward$f,
  inverse: inverse$f,
  names: names$f
};
function init$e() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward$e(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
}
function inverse$e(p) {
  var x = p.x;
  var y = p.y;
  p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
  p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var names$e = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const eqc = {
  init: init$e,
  forward: forward$e,
  inverse: inverse$e,
  names: names$e
};
var MAX_ITER$1 = 20;
function init$d() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward$d(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse$d(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER$1; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER$1; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$d = ["Polyconic", "poly"];
const poly = {
  init: init$d,
  forward: forward$d,
  inverse: inverse$d,
  names: names$d
};
function init$c() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward$c(p) {
  var n;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }
  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}
function inverse$c(p) {
  var n;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var names$c = ["New_Zealand_Map_Grid", "nzmg"];
const nzmg = {
  init: init$c,
  forward: forward$c,
  inverse: inverse$c,
  names: names$c
};
function init$b() {
}
function forward$b(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}
function inverse$b(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var names$b = ["Miller_Cylindrical", "mill"];
const mill = {
  init: init$b,
  forward: forward$b,
  inverse: inverse$b,
  names: names$b
};
var MAX_ITER = 20;
function init$a() {
  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward$a(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  lon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V2;
        if (Math.abs(V2) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse$a(p) {
  var lat, temp, lon, s;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  } else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    } else if (s - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$a = ["Sinusoidal", "sinu"];
const sinu = {
  init: init$a,
  forward: forward$a,
  inverse: inverse$a,
  names: names$a
};
function init$9() {
}
function forward$9(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse$9(p) {
  var theta;
  var arg;
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var names$9 = ["Mollweide", "moll"];
const moll = {
  init: init$9,
  forward: forward$9,
  inverse: inverse$9,
  names: names$9
};
function init$8() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward$8(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}
function inverse$8(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var names$8 = ["Equidistant_Conic", "eqdc"];
const eqdc = {
  init: init$8,
  forward: forward$8,
  inverse: inverse$8,
  names: names$8
};
function init$7() {
  this.R = this.a;
}
function forward$7(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var x, y;
  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    y = this.y0 + con;
  } else {
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse$7(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names$7 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const vandg = {
  init: init$7,
  forward: forward$7,
  inverse: inverse$7,
  names: names$7
};
function init$6() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function forward$6(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }
}
function inverse$6(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp2, A2, B, D, Ee, F, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
        } else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp2 = this.e * this.cos_p12 * cosAz;
      A2 = -tmp2 * tmp2 / (1 - this.es);
      B = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A2 * (1 + A2) * Math.pow(D, 3) / 6 - B * (1 + 3 * A2) * Math.pow(D, 4) / 24;
      F = 1 - A2 * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }
}
var names$6 = ["Azimuthal_Equidistant", "aeqd"];
const aeqd = {
  init: init$6,
  forward: forward$6,
  inverse: inverse$6,
  names: names$6
};
function init$5() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward$5(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse$5(p) {
  var rh;
  var z;
  var sinz, cosz;
  var con;
  var lon, lat;
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
    } else {
      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}
var names$5 = ["ortho"];
const ortho = {
  init: init$5,
  forward: forward$5,
  inverse: inverse$5,
  names: names$5
};
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function init$4() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward$4(p) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t, mu;
  var area2 = { value: 0 };
  p.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }
  lon = p.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area2.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area2.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area2.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area2.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area2.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area2.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area2.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area2.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area2);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area2);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area2);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area2);
    } else {
      phi = theta = 0;
      area2.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area2.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area2.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area2.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
}
function inverse$4(p) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area2 = { value: 0 };
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0 && p.x >= Math.abs(p.y)) {
    area2.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
    area2.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
    area2.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area2.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area2.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area2.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area2.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area2.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area2.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area2.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    if (area2.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area2.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area2.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}
function qsc_fwd_equat_face_theta(phi, y, x, area2) {
  var theta;
  if (phi < EPSLN) {
    area2.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= FORTPI) {
      area2.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area2.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area2.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area2.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var names$4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const qsc = {
  init: init$4,
  forward: forward$4,
  inverse: inverse$4,
  names: names$4
};
var COEFS_X = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
];
var COEFS_Y = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5;
var RC1 = 1 / C1;
var NODES = 18;
var poly3_val = function(coefs, x) {
  return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};
var poly3_der = function(coefs, x) {
  return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};
function newton_rapshon(f_df, start2, max_err, iters) {
  var x = start2;
  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x;
}
function init$3() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward$3(ll) {
  var lon = adjust_lon(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);
  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse$3(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i = Math.floor(ll.y * NODES);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
    t = newton_rapshon(function(x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * D2R$1;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon(ll.x + this.long0);
  return ll;
}
var names$3 = ["Robinson", "robin"];
const robin = {
  init: init$3,
  forward: forward$3,
  inverse: inverse$3,
  names: names$3
};
function init$2() {
  this.name = "geocent";
}
function forward$2(p) {
  var point = geodeticToGeocentric(p, this.es, this.a);
  return point;
}
function inverse$2(p) {
  var point = geocentricToGeodetic(p, this.es, this.a, this.b);
  return point;
}
var names$2 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const geocent = {
  init: init$2,
  forward: forward$2,
  inverse: inverse$2,
  names: names$2
};
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};
var params = {
  h: { def: 1e5, num: true },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: true, degrees: true },
  // default is North
  tilt: { def: 0, num: true, degrees: true },
  // default is Nadir
  long0: { def: 0, num: true },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: true }
  // default is Equator, conversion to rad is automatic
};
function init$1() {
  Object.keys(params).forEach(function(p) {
    if (typeof this[p] === "undefined") {
      this[p] = params[p].def;
    } else if (params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (params[p].degrees) {
      this[p] = this[p] * D2R$1;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward$1(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;
  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}
function inverse$1(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = { x: p.x, y: p.y };
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;
  var rh = hypot(p.x, p.y);
  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p.x, p.y);
  }
  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}
var names$1 = ["Tilted_Perspective", "tpers"];
const tpers = {
  init: init$1,
  forward: forward$1,
  inverse: inverse$1,
  names: names$1
};
function init() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var tmp2, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r * Math.cos(lon) * Math.cos(lat);
    v_y = r * Math.sin(lon) * Math.cos(lat);
    v_z = r * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    tmp2 = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp2));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp2);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp2);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp2));
    }
  } else if (this.shape === "sphere") {
    tmp2 = Math.cos(lat);
    v_x = Math.cos(lon) * tmp2;
    v_y = Math.sin(lon) * tmp2;
    v_z = Math.sin(lat);
    tmp2 = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp2));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp2);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp2);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp2));
    }
  }
  p.x = p.x * this.a;
  p.y = p.y * this.a;
  return p;
}
function inverse(p) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a, b, det, k;
  p.x = p.x / this.a;
  p.y = p.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * hypot(1, v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * hypot(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a = v_y * v_y + v_z * v_z + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
  }
  p.x = p.x + this.long0;
  return p;
}
var names = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const geos = {
  init,
  forward,
  inverse,
  names
};
function includedProjections(proj42) {
  proj42.Proj.projections.add(tmerc);
  proj42.Proj.projections.add(etmerc);
  proj42.Proj.projections.add(utm);
  proj42.Proj.projections.add(sterea);
  proj42.Proj.projections.add(stere);
  proj42.Proj.projections.add(somerc);
  proj42.Proj.projections.add(omerc);
  proj42.Proj.projections.add(lcc);
  proj42.Proj.projections.add(krovak);
  proj42.Proj.projections.add(cass);
  proj42.Proj.projections.add(laea);
  proj42.Proj.projections.add(aea);
  proj42.Proj.projections.add(gnom);
  proj42.Proj.projections.add(cea);
  proj42.Proj.projections.add(eqc);
  proj42.Proj.projections.add(poly);
  proj42.Proj.projections.add(nzmg);
  proj42.Proj.projections.add(mill);
  proj42.Proj.projections.add(sinu);
  proj42.Proj.projections.add(moll);
  proj42.Proj.projections.add(eqdc);
  proj42.Proj.projections.add(vandg);
  proj42.Proj.projections.add(aeqd);
  proj42.Proj.projections.add(ortho);
  proj42.Proj.projections.add(qsc);
  proj42.Proj.projections.add(robin);
  proj42.Proj.projections.add(geocent);
  proj42.Proj.projections.add(tpers);
  proj42.Proj.projections.add(geos);
}
proj4$1.defaultDatum = "WGS84";
proj4$1.Proj = Projection$3;
proj4$1.WGS84 = new proj4$1.Proj("WGS84");
proj4$1.Point = Point;
proj4$1.toPoint = common$1;
proj4$1.defs = defs;
proj4$1.nadgrid = nadgrid;
proj4$1.transform = transform$2;
proj4$1.mgrs = mgrs;
proj4$1.version = "__VERSION__";
includedProjections(proj4$1);
const lib$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: proj4$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$9$1 = /* @__PURE__ */ getAugmentedNamespace(lib$1);
var Units = {
  /**
   * Radians
   * @api
   */
  RADIANS: "radians",
  /**
   * Degrees
   * @api
   */
  DEGREES: "degrees",
  /**
   * Feet
   * @api
   */
  FEET: "ft",
  /**
   * Meters
   * @api
   */
  METERS: "m",
  /**
   * Pixels
   * @api
   */
  PIXELS: "pixels",
  /**
   * Tile Pixels
   * @api
   */
  TILE_PIXELS: "tile-pixels",
  /**
   * US Feet
   * @api
   */
  USFEET: "us-ft"
};
var METERS_PER_UNIT$1 = {};
METERS_PER_UNIT$1[Units.RADIANS] = 6370997 / (2 * Math.PI);
METERS_PER_UNIT$1[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT$1[Units.FEET] = 0.3048;
METERS_PER_UNIT$1[Units.METERS] = 1;
METERS_PER_UNIT$1[Units.USFEET] = 1200 / 3937;
const Units$1 = Units;
var Projection$1 = (
  /** @class */
  function() {
    function Projection2(options) {
      this.code_ = options.code;
      this.units_ = /** @type {import("./Units.js").default} */
      options.units;
      this.extent_ = options.extent !== void 0 ? options.extent : null;
      this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
      this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
      this.global_ = options.global !== void 0 ? options.global : false;
      this.canWrapX_ = !!(this.global_ && this.extent_);
      this.getPointResolutionFunc_ = options.getPointResolution;
      this.defaultTileGrid_ = null;
      this.metersPerUnit_ = options.metersPerUnit;
    }
    Projection2.prototype.canWrapX = function() {
      return this.canWrapX_;
    };
    Projection2.prototype.getCode = function() {
      return this.code_;
    };
    Projection2.prototype.getExtent = function() {
      return this.extent_;
    };
    Projection2.prototype.getUnits = function() {
      return this.units_;
    };
    Projection2.prototype.getMetersPerUnit = function() {
      return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
    };
    Projection2.prototype.getWorldExtent = function() {
      return this.worldExtent_;
    };
    Projection2.prototype.getAxisOrientation = function() {
      return this.axisOrientation_;
    };
    Projection2.prototype.isGlobal = function() {
      return this.global_;
    };
    Projection2.prototype.setGlobal = function(global2) {
      this.global_ = global2;
      this.canWrapX_ = !!(global2 && this.extent_);
    };
    Projection2.prototype.getDefaultTileGrid = function() {
      return this.defaultTileGrid_;
    };
    Projection2.prototype.setDefaultTileGrid = function(tileGrid) {
      this.defaultTileGrid_ = tileGrid;
    };
    Projection2.prototype.setExtent = function(extent2) {
      this.extent_ = extent2;
      this.canWrapX_ = !!(this.global_ && extent2);
    };
    Projection2.prototype.setWorldExtent = function(worldExtent) {
      this.worldExtent_ = worldExtent;
    };
    Projection2.prototype.setGetPointResolution = function(func) {
      this.getPointResolutionFunc_ = func;
    };
    Projection2.prototype.getPointResolutionFunc = function() {
      return this.getPointResolutionFunc_;
    };
    return Projection2;
  }()
);
const Projection$2 = Projection$1;
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
var cosh = function() {
  var cosh2;
  if ("cosh" in Math) {
    cosh2 = Math.cosh;
  } else {
    cosh2 = function(x) {
      var y = (
        /** @type {Math} */
        Math.exp(x)
      );
      return (y + 1 / y) / 2;
    };
  }
  return cosh2;
}();
var log2 = function() {
  var log22;
  if ("log2" in Math) {
    log22 = Math.log2;
  } else {
    log22 = function(x) {
      return Math.log(x) * Math.LOG2E;
    };
  }
  return log22;
}();
function solveLinearSystem(mat) {
  var n = mat.length;
  for (var i = 0; i < n; i++) {
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    var tmp2 = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp2;
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  var factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}
var __extends$x = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RADIUS$1 = 6378137;
var HALF_SIZE = Math.PI * RADIUS$1;
var EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
var WORLD_EXTENT = [-180, -85, 180, 85];
var MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
var EPSG3857Projection = (
  /** @class */
  function(_super) {
    __extends$x(EPSG3857Projection2, _super);
    function EPSG3857Projection2(code) {
      return _super.call(this, {
        code,
        units: Units$1.METERS,
        extent: EXTENT$1,
        global: true,
        worldExtent: WORLD_EXTENT,
        getPointResolution: function(resolution, point) {
          return resolution / cosh(point[1] / RADIUS$1);
        }
      }) || this;
    }
    return EPSG3857Projection2;
  }(Projection$2)
);
var PROJECTIONS$1 = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    var y = RADIUS$1 * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS$1)) / Math.PI - 90;
  }
  return output;
}
var __extends$w = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RADIUS = 6378137;
var EXTENT = [-180, -90, 180, 90];
var METERS_PER_UNIT = Math.PI * RADIUS / 180;
var EPSG4326Projection = (
  /** @class */
  function(_super) {
    __extends$w(EPSG4326Projection2, _super);
    function EPSG4326Projection2(code, opt_axisOrientation) {
      return _super.call(this, {
        code,
        units: Units$1.DEGREES,
        extent: EXTENT,
        axisOrientation: opt_axisOrientation,
        global: true,
        metersPerUnit: METERS_PER_UNIT,
        worldExtent: EXTENT
      }) || this;
    }
    return EPSG4326Projection2;
  }(Projection$2)
);
var PROJECTIONS = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
var cache = {};
function get$4(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add$1(code, projection) {
  cache[code] = projection;
}
var assign = typeof Object.assign === "function" ? Object.assign : function(target, var_sources) {
  if (target === void 0 || target === null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];
    if (source !== void 0 && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}
var getValues = typeof Object.values === "function" ? Object.values : function(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
};
function isEmpty$1(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
}
var transforms = {};
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get$3(sourceCode, destinationCode) {
  var transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}
const Relationship = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function abstract() {
  return (
    /** @type {?} */
    function() {
      throw new Error("Unimplemented abstract method.");
    }()
  );
}
var uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var VERSION$1 = "6.15.1";
var __extends$v = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AssertionError = (
  /** @class */
  function(_super) {
    __extends$v(AssertionError2, _super);
    function AssertionError2(code) {
      var _this = this;
      var path = "v" + VERSION$1.split("-")[0];
      var message = "Assertion failed. See https://openlayers.org/en/" + path + "/doc/errors/#" + code + " for details.";
      _this = _super.call(this, message) || this;
      _this.code = code;
      _this.name = "AssertionError";
      _this.message = message;
      return _this;
    }
    return AssertionError2;
  }(Error)
);
const AssertionError$1 = AssertionError;
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new AssertionError$1(errorCode);
  }
}
function boundingExtent(coordinates) {
  var extent2 = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent2, coordinates[i]);
  }
  return extent2;
}
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
}
function buffer$1(extent2, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent2[0] - value;
    opt_extent[1] = extent2[1] - value;
    opt_extent[2] = extent2[2] + value;
    opt_extent[3] = extent2[3] + value;
    return opt_extent;
  } else {
    return [
      extent2[0] - value,
      extent2[1] - value,
      extent2[2] + value,
      extent2[3] + value
    ];
  }
}
function clone(extent2, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent2[0];
    opt_extent[1] = extent2[1];
    opt_extent[2] = extent2[2];
    opt_extent[3] = extent2[3];
    return opt_extent;
  } else {
    return extent2.slice();
  }
}
function closestSquaredDistanceXY(extent2, x, y) {
  var dx, dy;
  if (x < extent2[0]) {
    dx = extent2[0] - x;
  } else if (extent2[2] < x) {
    dx = x - extent2[2];
  } else {
    dx = 0;
  }
  if (y < extent2[1]) {
    dy = extent2[1] - y;
  } else if (extent2[3] < y) {
    dy = y - extent2[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent2, coordinate) {
  return containsXY(extent2, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent2, x, y) {
  return extent2[0] <= x && x <= extent2[2] && extent2[1] <= y && y <= extent2[3];
}
function coordinateRelationship(extent2, coordinate) {
  var minX = extent2[0];
  var minY = extent2[1];
  var maxX = extent2[2];
  var maxY = extent2[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = Relationship.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship.ABOVE;
  }
  if (relationship === Relationship.UNKNOWN) {
    relationship = Relationship.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate$2(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate$2(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate$2(x, y, x, y, opt_extent);
}
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent2 = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent2, coordinates);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent2 = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent2, flatCoordinates, offset, end, stride);
}
function createOrUpdateFromRings(rings, opt_extent) {
  var extent2 = createOrUpdateEmpty(opt_extent);
  return extendRings(extent2, rings);
}
function equals$1(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend$2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent2, coordinate) {
  if (coordinate[0] < extent2[0]) {
    extent2[0] = coordinate[0];
  }
  if (coordinate[0] > extent2[2]) {
    extent2[2] = coordinate[0];
  }
  if (coordinate[1] < extent2[1]) {
    extent2[1] = coordinate[1];
  }
  if (coordinate[1] > extent2[3]) {
    extent2[3] = coordinate[1];
  }
}
function extendCoordinates(extent2, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent2, coordinates[i]);
  }
  return extent2;
}
function extendFlatCoordinates(extent2, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent2, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent2;
}
function extendRings(extent2, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent2, rings[i]);
  }
  return extent2;
}
function extendXY(extent2, x, y) {
  extent2[0] = Math.min(extent2[0], x);
  extent2[1] = Math.min(extent2[1], y);
  extent2[2] = Math.max(extent2[2], x);
  extent2[3] = Math.max(extent2[3], y);
}
function forEachCorner(extent2, callback) {
  var val;
  val = callback(getBottomLeft(extent2));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent2));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent2));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent2));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent2) {
  var area2 = 0;
  if (!isEmpty(extent2)) {
    area2 = getWidth(extent2) * getHeight(extent2);
  }
  return area2;
}
function getBottomLeft(extent2) {
  return [extent2[0], extent2[1]];
}
function getBottomRight(extent2) {
  return [extent2[2], extent2[1]];
}
function getCenter(extent2) {
  return [(extent2[0] + extent2[2]) / 2, (extent2[1] + extent2[3]) / 2];
}
function getCorner(extent2, corner) {
  var coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent2);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent2);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent2);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent2);
  } else {
    assert(false, 13);
  }
  return coordinate;
}
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var _a = getRotatedViewport(center, resolution, rotation, size), x0 = _a[0], y0 = _a[1], x1 = _a[2], y1 = _a[3], x2 = _a[4], y2 = _a[5], x3 = _a[6], y3 = _a[7];
  return createOrUpdate$2(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}
function getRotatedViewport(center, resolution, rotation, size) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent2) {
  return extent2[3] - extent2[1];
}
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects$1(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getMargin(extent2) {
  return getWidth(extent2) + getHeight(extent2);
}
function getSize(extent2) {
  return [extent2[2] - extent2[0], extent2[3] - extent2[1]];
}
function getTopLeft(extent2) {
  return [extent2[0], extent2[3]];
}
function getTopRight(extent2) {
  return [extent2[2], extent2[3]];
}
function getWidth(extent2) {
  return extent2[2] - extent2[0];
}
function intersects$1(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent2) {
  return extent2[2] < extent2[0] || extent2[3] < extent2[1];
}
function returnOrUpdate(extent2, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent2[0];
    opt_extent[1] = extent2[1];
    opt_extent[2] = extent2[2];
    opt_extent[3] = extent2[3];
    return opt_extent;
  } else {
    return extent2;
  }
}
function scaleFromCenter(extent2, value) {
  var deltaX = (extent2[2] - extent2[0]) / 2 * (value - 1);
  var deltaY = (extent2[3] - extent2[1]) / 2 * (value - 1);
  extent2[0] -= deltaX;
  extent2[2] += deltaX;
  extent2[1] -= deltaY;
  extent2[3] += deltaY;
}
function intersectsSegment(extent2, start2, end) {
  var intersects2 = false;
  var startRel = coordinateRelationship(extent2, start2);
  var endRel = coordinateRelationship(extent2, end);
  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
    intersects2 = true;
  } else {
    var minX = extent2[0];
    var minY = extent2[1];
    var maxX = extent2[2];
    var maxY = extent2[3];
    var startX = start2[0];
    var startY = start2[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x = void 0, y = void 0;
    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
  }
  return intersects2;
}
function applyTransform(extent2, transformFn, opt_extent, opt_stops) {
  var coordinates = [];
  if (opt_stops > 1) {
    var width = extent2[2] - extent2[0];
    var height = extent2[3] - extent2[1];
    for (var i = 0; i < opt_stops; ++i) {
      coordinates.push(extent2[0] + width * i / opt_stops, extent2[1], extent2[2], extent2[1] + height * i / opt_stops, extent2[2] - width * i / opt_stops, extent2[3], extent2[0], extent2[3] - height * i / opt_stops);
    }
  } else {
    coordinates = [
      extent2[0],
      extent2[1],
      extent2[2],
      extent2[1],
      extent2[2],
      extent2[3],
      extent2[0],
      extent2[3]
    ];
  }
  transformFn(coordinates, coordinates, 2);
  var xs = [];
  var ys = [];
  for (var i = 0, l = coordinates.length; i < l; i += 2) {
    xs.push(coordinates[i]);
    ys.push(coordinates[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, opt_extent);
}
function wrapX$1(extent2, projection) {
  var projectionExtent = projection.getExtent();
  var center = getCenter(extent2);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    var offset = worldsAway * worldWidth;
    extent2[0] -= offset;
    extent2[2] -= offset;
  }
  return extent2;
}
function wrapAndSliceX(extent2, projection) {
  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();
    if (!isFinite(extent2[0]) || !isFinite(extent2[2])) {
      return [[projectionExtent[0], extent2[1], projectionExtent[2], extent2[3]]];
    }
    wrapX$1(extent2, projection);
    var worldWidth = getWidth(projectionExtent);
    if (getWidth(extent2) > worldWidth) {
      return [[projectionExtent[0], extent2[1], projectionExtent[2], extent2[3]]];
    } else if (extent2[0] < projectionExtent[0]) {
      return [
        [extent2[0] + worldWidth, extent2[1], projectionExtent[2], extent2[3]],
        [projectionExtent[0], extent2[1], extent2[2], extent2[3]]
      ];
    } else if (extent2[2] > projectionExtent[2]) {
      return [
        [extent2[0], extent2[1], projectionExtent[2], extent2[3]],
        [projectionExtent[0], extent2[1], extent2[2] - worldWidth, extent2[3]]
      ];
    }
  }
  return [extent2];
}
const extent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyTransform,
  approximatelyEquals,
  boundingExtent,
  buffer: buffer$1,
  clone,
  closestSquaredDistanceXY,
  containsCoordinate,
  containsExtent,
  containsXY,
  coordinateRelationship,
  createEmpty,
  createOrUpdate: createOrUpdate$2,
  createOrUpdateEmpty,
  createOrUpdateFromCoordinate,
  createOrUpdateFromCoordinates,
  createOrUpdateFromFlatCoordinates,
  createOrUpdateFromRings,
  equals: equals$1,
  extend: extend$2,
  extendCoordinate,
  extendCoordinates,
  extendFlatCoordinates,
  extendRings,
  extendXY,
  forEachCorner,
  getArea,
  getBottomLeft,
  getBottomRight,
  getCenter,
  getCorner,
  getEnlargedArea,
  getForViewAndSize,
  getHeight,
  getIntersection,
  getIntersectionArea,
  getMargin,
  getRotatedViewport,
  getSize,
  getTopLeft,
  getTopRight,
  getWidth,
  intersects: intersects$1,
  intersectsSegment,
  isEmpty,
  returnOrUpdate,
  scaleFromCenter,
  wrapAndSliceX,
  wrapX: wrapX$1
}, Symbol.toStringTag, { value: "Module" }));
function compareVersions(v1, v2) {
  var s1 = ("" + v1).split(".");
  var s2 = ("" + v2).split(".");
  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || "0", 10);
    var n2 = parseInt(s2[i] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}
function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
  var projectionExtent = projection.getExtent();
  var worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
  }
  return worldsAway;
}
var DEFAULT_RADIUS = 63710088e-1;
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = toRadians(c1[1]);
  var lat2 = toRadians(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function cloneTransform(input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== void 0) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== void 0 && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
}
function addProjection(projection) {
  add$1(projection.getCode(), projection);
  add(projection, projection, cloneTransform);
}
function addProjections(projections2) {
  projections2.forEach(addProjection);
}
function get$2(projectionLike) {
  return typeof projectionLike === "string" ? get$4(
    /** @type {string} */
    projectionLike
  ) : (
    /** @type {Projection} */
    projectionLike || null
  );
}
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get$2(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (opt_units && opt_units !== projection.getUnits()) {
      var metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT$1[opt_units];
      }
    }
  } else {
    var units2 = projection.getUnits();
    if (units2 == Units$1.DEGREES && !opt_units || opt_units == Units$1.DEGREES) {
      pointResolution = resolution;
    } else {
      var toEPSG4326_1 = getTransformFromProjections(projection, get$2("EPSG:4326"));
      if (toEPSG4326_1 === identityTransform && units2 !== Units$1.DEGREES) {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        var vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG4326_1(vertices, vertices, 2);
        var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      var metersPerUnit = opt_units ? METERS_PER_UNIT$1[opt_units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections2) {
  addProjections(projections2);
  projections2.forEach(function(source) {
    projections2.forEach(function(destination) {
      if (source !== destination) {
        add(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add(projection1, projection2, forwardTransform);
      add(projection2, projection1, inverseTransform);
    });
  });
}
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [opt_output] Output.
     * @param {number} [opt_dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== void 0 ? opt_dimension : 2;
      var output = opt_output !== void 0 ? opt_output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform(input.slice(i, i + dimension));
        var pointLength = point.length;
        for (var j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}
function addCoordinateTransforms(source, destination, forward2, inverse2) {
  var sourceProj = get$2(source);
  var destProj = get$2(destination);
  add(sourceProj, destProj, createTransformFromCoordinateTransform(forward2));
  add(destProj, sourceProj, createTransformFromCoordinateTransform(inverse2));
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = get$3(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  var sourceProjection = get$2(source);
  var destinationProjection = get$2(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform$1(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent2, source, destination, opt_stops) {
  var transformFunc = getTransform(source, destination);
  return applyTransform(extent2, transformFunc, void 0, opt_stops);
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    var transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      var sourceExtent = sourceProj.getExtent();
      var sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform2(coord);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS$1);
  addEquivalentProjections(PROJECTIONS);
  addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);
}
addCommon();
function register(proj42) {
  var projCodes = Object.keys(proj42.defs);
  var len = projCodes.length;
  var i, j;
  for (i = 0; i < len; ++i) {
    var code = projCodes[i];
    if (!get$2(code)) {
      var def = proj42.defs(code);
      var units2 = def.units;
      if (!units2 && def.projName === "longlat") {
        units2 = Units$1.DEGREES;
      }
      addProjection(new Projection$2({
        code,
        axisOrientation: def.axis,
        metersPerUnit: def.to_meter,
        units: units2
      }));
    }
  }
  for (i = 0; i < len; ++i) {
    var code1 = projCodes[i];
    var proj1 = get$2(code1);
    for (j = 0; j < len; ++j) {
      var code2 = projCodes[j];
      var proj2 = get$2(code2);
      if (!get$3(code1, code2)) {
        if (proj42.defs[code1] === proj42.defs[code2]) {
          addEquivalentProjections([proj1, proj2]);
        } else {
          var transform2 = proj42(code1, code2);
          addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform2.forward), createSafeCoordinateTransform(proj2, proj1, transform2.inverse));
        }
      }
    }
  }
}
const proj4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  register
}, Symbol.toStringTag, { value: "Module" }));
const require$$10$1 = /* @__PURE__ */ getAugmentedNamespace(proj4);
var Camera2 = {};
var Coordinates = {};
var constructExports = {};
var construct = {
  get exports() {
    return constructExports;
  },
  set exports(v) {
    constructExports = v;
  }
};
var isNativeReflectConstructExports = {};
var isNativeReflectConstruct = {
  get exports() {
    return isNativeReflectConstructExports;
  },
  set exports(v) {
    isNativeReflectConstructExports = v;
  }
};
var hasRequiredIsNativeReflectConstruct;
function requireIsNativeReflectConstruct() {
  if (hasRequiredIsNativeReflectConstruct)
    return isNativeReflectConstructExports;
  hasRequiredIsNativeReflectConstruct = 1;
  (function(module) {
    function _isNativeReflectConstruct2() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    module.exports = _isNativeReflectConstruct2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(isNativeReflectConstruct);
  return isNativeReflectConstructExports;
}
var hasRequiredConstruct;
function requireConstruct() {
  if (hasRequiredConstruct)
    return constructExports;
  hasRequiredConstruct = 1;
  (function(module) {
    var setPrototypeOf2 = requireSetPrototypeOf();
    var isNativeReflectConstruct2 = requireIsNativeReflectConstruct();
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct2()) {
        module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            setPrototypeOf2(instance, Class2.prototype);
          return instance;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }
      return _construct.apply(null, arguments);
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(construct);
  return constructExports;
}
var toConsumableArrayExports = {};
var toConsumableArray = {
  get exports() {
    return toConsumableArrayExports;
  },
  set exports(v) {
    toConsumableArrayExports = v;
  }
};
var arrayWithoutHolesExports = {};
var arrayWithoutHoles = {
  get exports() {
    return arrayWithoutHolesExports;
  },
  set exports(v) {
    arrayWithoutHolesExports = v;
  }
};
var arrayLikeToArrayExports = {};
var arrayLikeToArray = {
  get exports() {
    return arrayLikeToArrayExports;
  },
  set exports(v) {
    arrayLikeToArrayExports = v;
  }
};
var hasRequiredArrayLikeToArray;
function requireArrayLikeToArray() {
  if (hasRequiredArrayLikeToArray)
    return arrayLikeToArrayExports;
  hasRequiredArrayLikeToArray = 1;
  (function(module) {
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    module.exports = _arrayLikeToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(arrayLikeToArray);
  return arrayLikeToArrayExports;
}
var hasRequiredArrayWithoutHoles;
function requireArrayWithoutHoles() {
  if (hasRequiredArrayWithoutHoles)
    return arrayWithoutHolesExports;
  hasRequiredArrayWithoutHoles = 1;
  (function(module) {
    var arrayLikeToArray2 = requireArrayLikeToArray();
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return arrayLikeToArray2(arr);
    }
    module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(arrayWithoutHoles);
  return arrayWithoutHolesExports;
}
var iterableToArrayExports = {};
var iterableToArray = {
  get exports() {
    return iterableToArrayExports;
  },
  set exports(v) {
    iterableToArrayExports = v;
  }
};
var hasRequiredIterableToArray;
function requireIterableToArray() {
  if (hasRequiredIterableToArray)
    return iterableToArrayExports;
  hasRequiredIterableToArray = 1;
  (function(module) {
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(iterableToArray);
  return iterableToArrayExports;
}
var unsupportedIterableToArrayExports = {};
var unsupportedIterableToArray = {
  get exports() {
    return unsupportedIterableToArrayExports;
  },
  set exports(v) {
    unsupportedIterableToArrayExports = v;
  }
};
var hasRequiredUnsupportedIterableToArray;
function requireUnsupportedIterableToArray() {
  if (hasRequiredUnsupportedIterableToArray)
    return unsupportedIterableToArrayExports;
  hasRequiredUnsupportedIterableToArray = 1;
  (function(module) {
    var arrayLikeToArray2 = requireArrayLikeToArray();
    function _unsupportedIterableToArray2(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return arrayLikeToArray2(o, minLen);
    }
    module.exports = _unsupportedIterableToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(unsupportedIterableToArray);
  return unsupportedIterableToArrayExports;
}
var nonIterableSpreadExports = {};
var nonIterableSpread = {
  get exports() {
    return nonIterableSpreadExports;
  },
  set exports(v) {
    nonIterableSpreadExports = v;
  }
};
var hasRequiredNonIterableSpread;
function requireNonIterableSpread() {
  if (hasRequiredNonIterableSpread)
    return nonIterableSpreadExports;
  hasRequiredNonIterableSpread = 1;
  (function(module) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(nonIterableSpread);
  return nonIterableSpreadExports;
}
var hasRequiredToConsumableArray;
function requireToConsumableArray() {
  if (hasRequiredToConsumableArray)
    return toConsumableArrayExports;
  hasRequiredToConsumableArray = 1;
  (function(module) {
    var arrayWithoutHoles2 = requireArrayWithoutHoles();
    var iterableToArray2 = requireIterableToArray();
    var unsupportedIterableToArray2 = requireUnsupportedIterableToArray();
    var nonIterableSpread2 = requireNonIterableSpread();
    function _toConsumableArray(arr) {
      return arrayWithoutHoles2(arr) || iterableToArray2(arr) || unsupportedIterableToArray2(arr) || nonIterableSpread2();
    }
    module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(toConsumableArray);
  return toConsumableArrayExports;
}
var hasRequiredCoordinates;
function requireCoordinates() {
  if (hasRequiredCoordinates)
    return Coordinates;
  hasRequiredCoordinates = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Coordinates, "__esModule", {
    value: true
  });
  Coordinates.UNIT = Coordinates.C = void 0;
  Coordinates.assertCrsIsValid = assertCrsIsValid;
  Coordinates.crsIsGeocentric = crsIsGeocentric;
  Coordinates.crsIsGeographic = crsIsGeographic;
  Coordinates.crsToUnit = crsToUnit;
  Coordinates.default = void 0;
  Coordinates.is4326 = is4326;
  Coordinates.reasonnableEpsilonForCRS = reasonnableEpsilonForCRS;
  var _construct2 = _interopRequireDefault2(requireConstruct());
  var _toConsumableArray22 = _interopRequireDefault2(requireToConsumableArray());
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _three2 = require$$8$1;
  var _proj3 = _interopRequireDefault2(require$$9$1);
  var projectionCache = {};
  var UNIT = {
    DEGREE: 1,
    METER: 2
  };
  Coordinates.UNIT = UNIT;
  function _unitFromProj4Unit(projunit) {
    if (projunit === "degrees") {
      return UNIT.DEGREE;
    }
    if (projunit === "m") {
      return UNIT.METER;
    }
    return void 0;
  }
  function crsToUnit(crs) {
    switch (crs) {
      case "EPSG:4326":
        return UNIT.DEGREE;
      case "EPSG:4978":
        return UNIT.METER;
      default: {
        var p = _proj3.default.defs(crs);
        if (!p) {
          return void 0;
        }
        return _unitFromProj4Unit(p.units);
      }
    }
  }
  function reasonnableEpsilonForCRS(crs, extent2) {
    if (is4326(crs)) {
      return 0.01;
    }
    var d = extent2.dimensions();
    return 0.01 * Math.min(d.x, d.y);
  }
  function _crsToUnitWithError(crs) {
    var u = crsToUnit(crs);
    if (crs === void 0 || u === void 0) {
      throw new Error("Invalid crs parameter value '".concat(crs, "'"));
    }
    return u;
  }
  function assertCrsIsValid(crs) {
    if (!_proj3.default.defs[crs]) {
      throw new Error("Invalid crs parameter value '".concat(crs, "'. Did you define it with proj4?"));
    }
  }
  function crsIsGeographic(crs) {
    return _crsToUnitWithError(crs) !== UNIT.METER;
  }
  function crsIsGeocentric(crs) {
    return _crsToUnitWithError(crs) === UNIT.METER;
  }
  function _assertIsGeographic(crs) {
    if (!crsIsGeographic(crs)) {
      throw new Error("Can't query crs ".concat(crs, " long/lat"));
    }
  }
  function _assertIsGeocentric(crs) {
    if (!crsIsGeocentric(crs)) {
      throw new Error("Can't query crs ".concat(crs, " x/y/z"));
    }
  }
  function instanceProj4(crsIn, crsOut) {
    if (projectionCache[crsIn]) {
      var _p = projectionCache[crsIn];
      if (_p[crsOut]) {
        return _p[crsOut];
      }
    } else {
      projectionCache[crsIn] = {};
    }
    var p = (0, _proj3.default)(crsIn, crsOut);
    projectionCache[crsIn][crsOut] = p;
    return p;
  }
  function is4326(crs) {
    return crs.indexOf("EPSG:4326") === 0;
  }
  var planarNormal = new _three2.Vector3(0, 0, 1);
  var Coordinates$1 = /* @__PURE__ */ function() {
    function Coordinates2(crs) {
      (0, _classCallCheck22.default)(this, Coordinates2);
      this._values = new Float64Array(3);
      for (var _len = arguments.length, coordinates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        coordinates[_key - 1] = arguments[_key];
      }
      this.set.apply(this, [crs].concat(coordinates));
      Object.defineProperty(this, "geodesicNormal", {
        configurable: true,
        get: function get2() {
          return planarNormal;
        }
      });
    }
    (0, _createClass22.default)(Coordinates2, [{
      key: "set",
      value: function set2(crs) {
        _crsToUnitWithError(crs);
        this.crs = crs;
        for (var _len2 = arguments.length, coordinates = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          coordinates[_key2 - 1] = arguments[_key2];
        }
        if (coordinates.length === 1 && coordinates[0] instanceof _three2.Vector3) {
          this._values[0] = coordinates[0].x;
          this._values[1] = coordinates[0].y;
          this._values[2] = coordinates[0].z;
        } else {
          for (var i = 0; i < coordinates.length && i < 3; i++) {
            this._values[i] = coordinates[i];
          }
          for (var _i = coordinates.length; _i < 3; _i++) {
            this._values[_i] = 0;
          }
        }
        this._normal = void 0;
        return this;
      }
    }, {
      key: "clone",
      value: function clone2(target) {
        var r;
        if (target) {
          Coordinates2.call.apply(Coordinates2, [target, this.crs].concat((0, _toConsumableArray22.default)(this._values)));
          r = target;
        } else {
          r = (0, _construct2.default)(Coordinates2, [this.crs].concat((0, _toConsumableArray22.default)(this._values)));
        }
        if (this._normal) {
          r._normal = this._normal.clone();
        }
        return r;
      }
    }, {
      key: "copy",
      value: function copy(src) {
        this.set.apply(this, [src.crs].concat((0, _toConsumableArray22.default)(src._values)));
        return this;
      }
      /**
       * Returns the longitude in geographic coordinates.
       * Coordinates must be in geographic system (can be
       * converted by using {@linkcode module:Core/Geographic/Coordinates~Coordinates#as as()} ).
       *
       * @example
       * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };
       * const coordinates = new Coordinates(
       *   'EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic
       * coordinates.longitude(); // Longitude in geographic system
       * // returns 2.33
       *
       * // or
       *
       * const position = { x: 20885167, y: 849862, z: 23385912 };
       * // Geocentric system
       * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);
       * const coordinates = coords.as('EPSG:4326');  // Geographic system
       * coordinates.longitude(); // Longitude in geographic system
       * // returns 2.330201911389028
       * @returns     {number} - The longitude of the position.
       * @api
       */
    }, {
      key: "longitude",
      value: function longitude() {
        _assertIsGeographic(this.crs);
        return this._values[0];
      }
      /**
       * Returns the latitude in geographic coordinates.
       * Coordinates must be in geographic system (can be
       * converted by using {@linkcode module:Core/Geographic/Coordinates~Coordinates#as as()} ).
       *
       * @example
       *
       * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };
       * const coordinates = new Coordinates(
       *     'EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic
       * coordinates.latitude(); // Latitude in geographic system
       * // returns : 48.24
       *
       * // or
       *
       * const position = { x: 20885167, y: 849862, z: 23385912 };
       * // Geocentric system
       * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);
       * const coordinates = coords.as('EPSG:4326');  // Geographic system
       * coordinates.latitude(); // Latitude in geographic system
       * // returns : 48.24830764643365
       * @returns     {number} - The latitude of the position.
       * @api
       */
    }, {
      key: "latitude",
      value: function latitude() {
        return this._values[1];
      }
      /**
       * Returns the altitude in geographic coordinates.
       * Coordinates must be in geographic system(can be converted by using
       * {@linkcode module:Core/Geographic/Coordinates~Coordinates#as as()} ).
       *
       * @example
       *
       * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };
       * // Geographic system
       * const coordinates =
       *      new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude);
       * coordinates.altitude(); // Altitude in geographic system
       * // returns : 24999549
       *
       * // or
       *
       * const position = { x: 20885167, y: 849862, z: 23385912 };
       * // Geocentric system
       * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);
       * const coordinates = coords.as('EPSG:4326');  // Geographic system
       * coordinates.altitude(); // Altitude in geographic system
       * // returns : 24999548.046711832
       * @returns     {number} - The altitude of the position.
       * @api
       */
    }, {
      key: "altitude",
      value: function altitude() {
        _assertIsGeographic(this.crs);
        return this._values[2];
      }
      /**
       * Set the altitude.
       *
       * @param      {number} altitude the new altitude.
       * @example coordinates.setAltitude(10000)
       * @api
       */
    }, {
      key: "setAltitude",
      value: function setAltitude(altitude) {
        _assertIsGeographic(this.crs);
        this._values[2] = altitude;
      }
      /**
       * Returns the <code>x</code> component of this coordinate in geocentric coordinates.
       * Coordinates must be in geocentric system (can be
       * converted by using {@linkcode module:Core/Geographic/Coordinates~Coordinates#as as()}).
       *
       * @example
       *
       * const position = { x: 20885167, y: 849862, z: 23385912 };
       * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);
       * coordinates.x();  // Geocentric system
       * // returns : 20885167
       *
       * // or
       *
       * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };
       * // Geographic system
       * const coords =
       *     new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude);
       * const coordinates = coords.as('EPSG:4978'); // Geocentric system
       * coordinates.x(); // Geocentric system
       * // returns : 20888561.0301258
       * @returns {number} The <code>x</code> component of the position.
       * @api
       */
    }, {
      key: "x",
      value: function x() {
        _assertIsGeocentric(this.crs);
        return this._values[0];
      }
      /**
       * Returns the <code>y</code> component of this coordinate in geocentric coordinates.
       * Coordinates must be in geocentric system (can be
       * converted by using {@linkcode module:Core/Geographic/Coordinates~Coordinates#as as()}).
       *
       * @example
       * const position = { x: 20885167, y: 849862, z: 23385912 };
       * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);
       * coordinates.y();  // Geocentric system
       * // returns :  849862
       * @returns {number} The <code>y</code> component of the position.
       * @api
       */
    }, {
      key: "y",
      value: function y() {
        _assertIsGeocentric(this.crs);
        return this._values[1];
      }
      /**
       * Returns the <code>z</code> component of this coordinate in geocentric coordinates.
       * Coordinates must be in geocentric system (can be
       * converted by using {@linkcode module:Core/Geographic/Coordinates~Coordinates#as as()}).
       *
       * @example
       * const position = { x: 20885167, y: 849862, z: 23385912 };
       * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);
       * coordinates.z();  // Geocentric system
       * // returns :  23385912
       * @returns {number} The <code>z</code> component of the position.
       * @api
       */
    }, {
      key: "z",
      value: function z() {
        _assertIsGeocentric(this.crs);
        return this._values[2];
      }
      /**
       * Returns a position in cartesian coordinates. Coordinates must be in geocentric system (can be
       * converted by using {@linkcode module:Core/Geographic/Coordinates~Coordinates#as as()}).
       *
       * @example
       *
       * const position = { x: 20885167, y: 849862, z: 23385912 };
       * // Geocentric system
       * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);
       * coordinates.xyz();  // Geocentric system
       * // returns : Vector3
       * // x: 20885167
       * // y: 849862
       * // z: 23385912
       *
       * // or
       *
       * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };
       * // Geographic system
       * const coords =
       *      new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude);
       * const coordinates = coords.as('EPSG:4978'); // Geocentric system
       * coordinates.xyz(); // Geocentric system
       * // returns : Vector3
       * // x: 20885167
       * // y: 849862
       * // z: 23385912
       * @param {Coordinates} target the geocentric coordinate
       * @returns     {Vector3 | Coordinates} target position
       * @api
       */
    }, {
      key: "xyz",
      value: function xyz(target) {
        _assertIsGeocentric(this.crs);
        var v = target || new _three2.Vector3();
        v.fromArray(this._values);
        return v;
      }
      /**
       * Converts coordinates in another [CRS](http://inspire.ec.europa.eu/theme/rs).
       *
       * If target is not specified, creates a new instance.
       * The original instance is never modified (except if you passed it as `target`).
       *
       * @example
       *
       * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };
       * // Geographic system
       * const coords =
       *     new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude);
       * const coordinates = coords.as('EPSG:4978'); // Geocentric system
       * @param   {string} crs the [CRS](http://inspire.ec.europa.eu/theme/rs) EPSG string
       * @param   {Coordinates|Vector3} target the object that is returned
       * @returns {Coordinates|Vector3} the converted coordinate
       * @api
       */
    }, {
      key: "as",
      value: function as(crs, target) {
        if (crs === void 0 || crsToUnit(crs) === void 0) {
          throw new Error("Invalid crs paramater value '".concat(crs, "'"));
        }
        return this._convert(crs, target);
      }
      // Only support explicit conversions
    }, {
      key: "_convert",
      value: function _convert(newCrs, target) {
        target = target || new Coordinates2(newCrs, 0, 0);
        if (newCrs === this.crs) {
          return target.copy(this);
        }
        if (this.crs in _proj3.default.defs && newCrs in _proj3.default.defs) {
          var val0 = this._values[0];
          var val1 = this._values[1];
          var crsIn = this.crs;
          if (is4326(crsIn) && newCrs === "EPSG:3857") {
            val1 = _three2.MathUtils.clamp(val1, -89.999999, 89.999999);
            var _p2 = instanceProj4(crsIn, newCrs).forward([val0, val1]);
            return target.set(newCrs, _p2[0], _p2[1], this._values[2]);
          }
          var p = instanceProj4(crsIn, newCrs).forward([val0, val1]);
          return target.set(newCrs, p[0], p[1], this._values[2]);
        }
        throw new Error("Cannot convert from crs ".concat(this.crs, " to ").concat(newCrs));
      }
      /**
       * Returns the normalized offset from top-left in extent of this Coordinates
       * e.g:
       * ```
       * extent.center().offsetInExtent(extent)
       * ```
       *  would return `(0.5, 0.5)`.
       *
       * @param {module:Core/Geographic/Extent~Extent} extent the extent to test
       * @param {Vector2} target optional Vector2 target.
       * If not present a new one will be created
       * @returns {Vector2} normalized offset in extent
       * @api
       */
    }, {
      key: "offsetInExtent",
      value: function offsetInExtent(extent2, target) {
        if (this.crs !== extent2.crs()) {
          throw new Error("unsupported mix");
        }
        var dimension = {
          x: Math.abs(extent2.east() - extent2.west()),
          y: Math.abs(extent2.north() - extent2.south())
        };
        var x = crsIsGeocentric(this.crs) ? this.x() : this.longitude();
        var y = crsIsGeocentric(this.crs) ? this.y() : this.latitude();
        var originX = (x - extent2.west()) / dimension.x;
        var originY = (extent2.north() - y) / dimension.y;
        target = target || new _three2.Vector2();
        target.set(originX, originY);
        return target;
      }
    }]);
    return Coordinates2;
  }();
  var C = {
    /**
     * Returns a Coordinates object from a position object in the EPSG:4326 CRS.
     * The object just* needs to have x, y, z properties.
     *
     * @param {object} args the position to transform
     * @param {number} args.x the x component of the position
     * @param {number} args.y the y component of the position
     * @param {number} args.z the z component of the position
     * @returns {Coordinates} the created coordinates
     */
    EPSG_4326: function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return (0, _construct2.default)(Coordinates$1, ["EPSG:4326"].concat(args));
    }
  };
  Coordinates.C = C;
  var _default2 = Coordinates$1;
  Coordinates.default = _default2;
  return Coordinates;
}
var hasRequiredCamera;
function requireCamera() {
  if (hasRequiredCamera)
    return Camera2;
  hasRequiredCamera = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Camera2, "__esModule", {
    value: true
  });
  Camera2.default = void 0;
  var _three2 = require$$8$1;
  var _Coordinates = _interopRequireDefault2(requireCoordinates());
  function Camera$12(crs, width, height) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    Object.defineProperty(this, "crs", {
      get: function get2() {
        return crs;
      }
    });
    this.camera3D = options.camera ? options.camera : new _three2.PerspectiveCamera(30, width / height);
    this.camera3D.near = 0.1;
    this.camera3D.far = 2e9;
    this.camera3D.updateProjectionMatrix();
    this.camera2D = new _three2.OrthographicCamera(0, 1, 0, 1, 0, 10);
    this._viewMatrix = new _three2.Matrix4();
    this.width = width;
    this.height = height;
    this._preSSE = Infinity;
  }
  function resize(camera, width, height) {
    if (width && height) {
      camera.width = width;
      camera.height = height;
      var ratio = width / height;
      if (camera.camera3D.aspect !== ratio) {
        camera.camera3D.aspect = ratio;
        if (camera.camera3D.isOrthographicCamera) {
          var halfH = (camera.camera3D.right - camera.camera3D.left) * 0.5 / ratio;
          var y = (camera.camera3D.top + camera.camera3D.bottom) * 0.5;
          camera.camera3D.top = y + halfH;
          camera.camera3D.bottom = y - halfH;
        }
      }
    }
    if (camera.camera3D.updateProjectionMatrix) {
      camera.camera3D.updateProjectionMatrix();
    }
    camera.camera2D.right = width;
    camera.camera2D.top = height;
    camera.camera2D.bottom = 0;
    camera.camera2D.updateProjectionMatrix();
  }
  Camera$12.prototype.update = function(width, height) {
    resize(this, width, height);
    this.camera3D.updateMatrixWorld();
    this._viewMatrix.multiplyMatrices(this.camera3D.projectionMatrix, this.camera3D.matrixWorldInverse);
  };
  Camera$12.prototype.position = function(crs) {
    return new _Coordinates.default(this.crs, this.camera3D.position).as(crs || this.crs);
  };
  var tmp2 = {
    frustum: new _three2.Frustum(),
    matrix: new _three2.Matrix4(),
    box3: new _three2.Box3()
  };
  var points = [new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3()];
  function projectBox3PointsInCameraSpace(camera, box3, matrixWorld) {
    var m = camera.camera3D.matrixWorldInverse;
    if (matrixWorld) {
      m = tmp2.matrix.multiplyMatrices(camera.camera3D.matrixWorldInverse, matrixWorld);
    }
    points[0].set(box3.min.x, box3.min.y, box3.min.z).applyMatrix4(m);
    points[1].set(box3.min.x, box3.min.y, box3.max.z).applyMatrix4(m);
    points[2].set(box3.min.x, box3.max.y, box3.min.z).applyMatrix4(m);
    points[3].set(box3.min.x, box3.max.y, box3.max.z).applyMatrix4(m);
    points[4].set(box3.max.x, box3.min.y, box3.min.z).applyMatrix4(m);
    points[5].set(box3.max.x, box3.min.y, box3.max.z).applyMatrix4(m);
    points[6].set(box3.max.x, box3.max.y, box3.min.z).applyMatrix4(m);
    points[7].set(box3.max.x, box3.max.y, box3.max.z).applyMatrix4(m);
    var atLeastOneInFrontOfNearPlane = false;
    for (var i = 0; i < 8; i++) {
      if (points[i].z <= -camera.camera3D.near) {
        atLeastOneInFrontOfNearPlane = true;
      } else {
        points[i].z = -camera.camera3D.near;
      }
    }
    return atLeastOneInFrontOfNearPlane ? points : void 0;
  }
  var ndcBox3 = new _three2.Box3(new _three2.Vector3(-1, -1, -1), new _three2.Vector3(1, 1, 1));
  Camera$12.prototype.isBox3Visible = function(box3, matrixWorld) {
    return this.box3SizeOnScreen(box3, matrixWorld).intersectsBox(ndcBox3);
  };
  Camera$12.prototype.isSphereVisible = function(sphere2, matrixWorld) {
    if (matrixWorld) {
      tmp2.matrix.multiplyMatrices(this._viewMatrix, matrixWorld);
      tmp2.frustum.setFromProjectionMatrix(tmp2.matrix);
    } else {
      tmp2.frustum.setFromProjectionMatrix(this._viewMatrix);
    }
    return tmp2.frustum.intersectsSphere(sphere2);
  };
  Camera$12.prototype.box3SizeOnScreen = function(box3, matrixWorld) {
    var pts = projectBox3PointsInCameraSpace(this, box3, matrixWorld);
    if (!pts) {
      return tmp2.box3.makeEmpty();
    }
    for (var i = 0; i < 8; i++) {
      pts[i].applyMatrix4(this.camera3D.projectionMatrix);
    }
    return tmp2.box3.setFromPoints(pts);
  };
  var _default2 = Camera$12;
  Camera2.default = _default2;
  return Camera2;
}
var MainLoop = {};
var Layer = {};
const EventType = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
var Disposable = (
  /** @class */
  function() {
    function Disposable2() {
      this.disposed = false;
    }
    Disposable2.prototype.dispose = function() {
      if (!this.disposed) {
        this.disposed = true;
        this.disposeInternal();
      }
    };
    Disposable2.prototype.disposeInternal = function() {
    };
    return Disposable2;
  }()
);
const Disposable$1 = Disposable;
var BaseEvent = (
  /** @class */
  function() {
    function BaseEvent2(type) {
      this.propagationStopped;
      this.defaultPrevented;
      this.type = type;
      this.target = null;
    }
    BaseEvent2.prototype.preventDefault = function() {
      this.defaultPrevented = true;
    };
    BaseEvent2.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    return BaseEvent2;
  }()
);
const Event$1 = BaseEvent;
function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i = void 0;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (typeof direction === "function") {
            if (direction(target, arr[i - 1], arr[i]) > 0) {
              return i - 1;
            } else {
              return i;
            }
          } else if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp2 = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp2;
    ++begin;
    --end;
  }
}
function extend$1(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}
function TRUE() {
  return true;
}
function VOID() {
}
var __extends$u = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Target = (
  /** @class */
  function(_super) {
    __extends$u(Target2, _super);
    function Target2(opt_target) {
      var _this = _super.call(this) || this;
      _this.eventTarget_ = opt_target;
      _this.pendingRemovals_ = null;
      _this.dispatching_ = null;
      _this.listeners_ = null;
      return _this;
    }
    Target2.prototype.addEventListener = function(type, listener) {
      if (!type || !listener) {
        return;
      }
      var listeners = this.listeners_ || (this.listeners_ = {});
      var listenersForType = listeners[type] || (listeners[type] = []);
      if (listenersForType.indexOf(listener) === -1) {
        listenersForType.push(listener);
      }
    };
    Target2.prototype.dispatchEvent = function(event) {
      var isString = typeof event === "string";
      var type = isString ? event : event.type;
      var listeners = this.listeners_ && this.listeners_[type];
      if (!listeners) {
        return;
      }
      var evt = isString ? new Event$1(event) : (
        /** @type {Event} */
        event
      );
      if (!evt.target) {
        evt.target = this.eventTarget_ || this;
      }
      var dispatching = this.dispatching_ || (this.dispatching_ = {});
      var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
      if (!(type in dispatching)) {
        dispatching[type] = 0;
        pendingRemovals[type] = 0;
      }
      ++dispatching[type];
      var propagate;
      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if ("handleEvent" in listeners[i]) {
          propagate = /** @type {import("../events.js").ListenerObject} */
          listeners[i].handleEvent(evt);
        } else {
          propagate = /** @type {import("../events.js").ListenerFunction} */
          listeners[i].call(this, evt);
        }
        if (propagate === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }
      if (--dispatching[type] === 0) {
        var pr = pendingRemovals[type];
        delete pendingRemovals[type];
        while (pr--) {
          this.removeEventListener(type, VOID);
        }
        delete dispatching[type];
      }
      return propagate;
    };
    Target2.prototype.disposeInternal = function() {
      this.listeners_ && clear(this.listeners_);
    };
    Target2.prototype.getListeners = function(type) {
      return this.listeners_ && this.listeners_[type] || void 0;
    };
    Target2.prototype.hasListener = function(opt_type) {
      if (!this.listeners_) {
        return false;
      }
      return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    };
    Target2.prototype.removeEventListener = function(type, listener) {
      var listeners = this.listeners_ && this.listeners_[type];
      if (listeners) {
        var index = listeners.indexOf(listener);
        if (index !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    return Target2;
  }(Disposable$1)
);
const EventTarget = Target;
const TileState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
const TileState$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: TileState
}, Symbol.toStringTag, { value: "Module" }));
function easeIn(t) {
  return Math.pow(t, 3);
}
var __extends$t = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Tile$1 = (
  /** @class */
  function(_super) {
    __extends$t(Tile2, _super);
    function Tile2(tileCoord, state, opt_options) {
      var _this = _super.call(this) || this;
      var options = opt_options ? opt_options : {};
      _this.tileCoord = tileCoord;
      _this.state = state;
      _this.interimTile = null;
      _this.key = "";
      _this.transition_ = options.transition === void 0 ? 250 : options.transition;
      _this.transitionStarts_ = {};
      _this.interpolate = !!options.interpolate;
      return _this;
    }
    Tile2.prototype.changed = function() {
      this.dispatchEvent(EventType.CHANGE);
    };
    Tile2.prototype.release = function() {
    };
    Tile2.prototype.getKey = function() {
      return this.key + "/" + this.tileCoord;
    };
    Tile2.prototype.getInterimTile = function() {
      if (!this.interimTile) {
        return this;
      }
      var tile = this.interimTile;
      do {
        if (tile.getState() == TileState.LOADED) {
          this.transition_ = 0;
          return tile;
        }
        tile = tile.interimTile;
      } while (tile);
      return this;
    };
    Tile2.prototype.refreshInterimChain = function() {
      if (!this.interimTile) {
        return;
      }
      var tile = this.interimTile;
      var prev = this;
      do {
        if (tile.getState() == TileState.LOADED) {
          tile.interimTile = null;
          break;
        } else if (tile.getState() == TileState.LOADING) {
          prev = tile;
        } else if (tile.getState() == TileState.IDLE) {
          prev.interimTile = tile.interimTile;
        } else {
          prev = tile;
        }
        tile = prev.interimTile;
      } while (tile);
    };
    Tile2.prototype.getTileCoord = function() {
      return this.tileCoord;
    };
    Tile2.prototype.getState = function() {
      return this.state;
    };
    Tile2.prototype.setState = function(state) {
      if (this.state !== TileState.ERROR && this.state > state) {
        throw new Error("Tile load sequence violation");
      }
      this.state = state;
      this.changed();
    };
    Tile2.prototype.load = function() {
      abstract();
    };
    Tile2.prototype.getAlpha = function(id, time) {
      if (!this.transition_) {
        return 1;
      }
      var start2 = this.transitionStarts_[id];
      if (!start2) {
        start2 = time;
        this.transitionStarts_[id] = start2;
      } else if (start2 === -1) {
        return 1;
      }
      var delta = time - start2 + 1e3 / 60;
      if (delta >= this.transition_) {
        return 1;
      }
      return easeIn(delta / this.transition_);
    };
    Tile2.prototype.inTransition = function(id) {
      if (!this.transition_) {
        return false;
      }
      return this.transitionStarts_[id] !== -1;
    };
    Tile2.prototype.endTransition = function(id) {
      if (this.transition_) {
        this.transitionStarts_[id] = -1;
      }
    };
    return Tile2;
  }(EventTarget)
);
const Tile$2 = Tile$1;
var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
ua.indexOf("firefox") !== -1;
var SAFARI = ua.indexOf("safari") !== -1 && ua.indexOf("chrom") == -1;
SAFARI && !!(ua.indexOf("version/15.4") >= 0 || ua.match(/cpu (os|iphone os) 15_4 like mac os x/));
ua.indexOf("webkit") !== -1 && ua.indexOf("edge") == -1;
ua.indexOf("macintosh") !== -1;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
(function() {
  var passive = false;
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch (error) {
  }
  return passive;
})();
function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
  var canvas;
  if (opt_canvasPool && opt_canvasPool.length) {
    canvas = opt_canvasPool.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", opt_Context2DSettings)
  );
}
function releaseCanvas(context) {
  var canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
var __extends$s = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ImageBase = (
  /** @class */
  function(_super) {
    __extends$s(ImageBase2, _super);
    function ImageBase2(extent2, resolution, pixelRatio, state) {
      var _this = _super.call(this) || this;
      _this.extent = extent2;
      _this.pixelRatio_ = pixelRatio;
      _this.resolution = resolution;
      _this.state = state;
      return _this;
    }
    ImageBase2.prototype.changed = function() {
      this.dispatchEvent(EventType.CHANGE);
    };
    ImageBase2.prototype.getExtent = function() {
      return this.extent;
    };
    ImageBase2.prototype.getImage = function() {
      return abstract();
    };
    ImageBase2.prototype.getPixelRatio = function() {
      return this.pixelRatio_;
    };
    ImageBase2.prototype.getResolution = function() {
      return (
        /** @type {number} */
        this.resolution
      );
    };
    ImageBase2.prototype.getState = function() {
      return this.state;
    };
    ImageBase2.prototype.load = function() {
      abstract();
    };
    return ImageBase2;
  }(EventTarget)
);
const ImageBase$1 = ImageBase;
const ImageState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
function listen(target, type, listener, opt_this, opt_once) {
  if (opt_this && opt_this !== target) {
    listener = listener.bind(opt_this);
  }
  if (opt_once) {
    var originalListener_1 = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener_1.apply(this, arguments);
    };
  }
  var eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
const events = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  listen,
  listenOnce,
  unlistenByKey
}, Symbol.toStringTag, { value: "Module" }));
var __extends$r = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$r(ImageWrapper, _super);
  function ImageWrapper(extent2, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
    var _this = _super.call(this, extent2, resolution, pixelRatio, ImageState.IDLE) || this;
    _this.src_ = src;
    _this.image_ = new Image();
    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    _this.unlisten_ = null;
    _this.state = ImageState.IDLE;
    _this.imageLoadFunction_ = imageLoadFunction;
    return _this;
  }
  ImageWrapper.prototype.getImage = function() {
    return this.image_;
  };
  ImageWrapper.prototype.handleImageError_ = function() {
    this.state = ImageState.ERROR;
    this.unlistenImage_();
    this.changed();
  };
  ImageWrapper.prototype.handleImageLoad_ = function() {
    if (this.resolution === void 0) {
      this.resolution = getHeight(this.extent) / this.image_.height;
    }
    this.state = ImageState.LOADED;
    this.unlistenImage_();
    this.changed();
  };
  ImageWrapper.prototype.load = function() {
    if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
      this.state = ImageState.LOADING;
      this.changed();
      this.imageLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  ImageWrapper.prototype.setImage = function(image) {
    this.image_ = image;
    this.resolution = getHeight(this.extent) / this.image_.height;
  };
  ImageWrapper.prototype.unlistenImage_ = function() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };
  return ImageWrapper;
})(ImageBase$1);
function listenImage(image, loadHandler, errorHandler) {
  var img = (
    /** @type {HTMLImageElement} */
    image
  );
  var listening = true;
  var decoding = false;
  var loaded = false;
  var listenerKeys = [
    listenOnce(img, EventType.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
var __extends$q = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ImageTile = (
  /** @class */
  function(_super) {
    __extends$q(ImageTile2, _super);
    function ImageTile2(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
      var _this = _super.call(this, tileCoord, state, opt_options) || this;
      _this.crossOrigin_ = crossOrigin;
      _this.src_ = src;
      _this.key = src;
      _this.image_ = new Image();
      if (crossOrigin !== null) {
        _this.image_.crossOrigin = crossOrigin;
      }
      _this.unlisten_ = null;
      _this.tileLoadFunction_ = tileLoadFunction;
      return _this;
    }
    ImageTile2.prototype.getImage = function() {
      return this.image_;
    };
    ImageTile2.prototype.setImage = function(element) {
      this.image_ = element;
      this.state = TileState.LOADED;
      this.unlistenImage_();
      this.changed();
    };
    ImageTile2.prototype.handleImageError_ = function() {
      this.state = TileState.ERROR;
      this.unlistenImage_();
      this.image_ = getBlankImage();
      this.changed();
    };
    ImageTile2.prototype.handleImageLoad_ = function() {
      var image = (
        /** @type {HTMLImageElement} */
        this.image_
      );
      if (image.naturalWidth && image.naturalHeight) {
        this.state = TileState.LOADED;
      } else {
        this.state = TileState.EMPTY;
      }
      this.unlistenImage_();
      this.changed();
    };
    ImageTile2.prototype.load = function() {
      if (this.state == TileState.ERROR) {
        this.state = TileState.IDLE;
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      if (this.state == TileState.IDLE) {
        this.state = TileState.LOADING;
        this.changed();
        this.tileLoadFunction_(this, this.src_);
        this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
      }
    };
    ImageTile2.prototype.unlistenImage_ = function() {
      if (this.unlisten_) {
        this.unlisten_();
        this.unlisten_ = null;
      }
    };
    return ImageTile2;
  }(Tile$2)
);
function getBlankImage() {
  var ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
const ImageTile$1 = ImageTile;
var ERROR_THRESHOLD = 0.5;
var ENABLE_RASTER_REPROJECTION = true;
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = (
  /** @class */
  function() {
    function Triangulation2(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
      this.sourceProj_ = sourceProj;
      this.targetProj_ = targetProj;
      var transformInvCache = {};
      var transformInv = getTransform(this.targetProj_, this.sourceProj_);
      this.transformInv_ = function(c) {
        var key = c[0] + "/" + c[1];
        if (!transformInvCache[key]) {
          transformInvCache[key] = transformInv(c);
        }
        return transformInvCache[key];
      };
      this.maxSourceExtent_ = maxSourceExtent;
      this.errorThresholdSquared_ = errorThreshold * errorThreshold;
      this.triangles_ = [];
      this.wrapsXInSource_ = false;
      this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
      this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
      this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
      var destinationTopLeft = getTopLeft(targetExtent);
      var destinationTopRight = getTopRight(targetExtent);
      var destinationBottomRight = getBottomRight(targetExtent);
      var destinationBottomLeft = getBottomLeft(targetExtent);
      var sourceTopLeft = this.transformInv_(destinationTopLeft);
      var sourceTopRight = this.transformInv_(destinationTopRight);
      var sourceBottomRight = this.transformInv_(destinationBottomRight);
      var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
      var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);
      this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
      if (this.wrapsXInSource_) {
        var leftBound_1 = Infinity;
        this.triangles_.forEach(function(triangle, i, arr) {
          leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
        });
        this.triangles_.forEach(function(triangle) {
          if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {
            var newTriangle = [
              [triangle.source[0][0], triangle.source[0][1]],
              [triangle.source[1][0], triangle.source[1][1]],
              [triangle.source[2][0], triangle.source[2][1]]
            ];
            if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
              newTriangle[0][0] -= this.sourceWorldWidth_;
            }
            if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
              newTriangle[1][0] -= this.sourceWorldWidth_;
            }
            if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
              newTriangle[2][0] -= this.sourceWorldWidth_;
            }
            var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
            var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
            if (maxX - minX < this.sourceWorldWidth_ / 2) {
              triangle.source = newTriangle;
            }
          }
        }.bind(this));
      }
      transformInvCache = {};
    }
    Triangulation2.prototype.addTriangle_ = function(a, b, c, aSrc, bSrc, cSrc) {
      this.triangles_.push({
        source: [aSrc, bSrc, cSrc],
        target: [a, b, c]
      });
    };
    Triangulation2.prototype.addQuad_ = function(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
      var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
      var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
      var sourceWorldWidth = (
        /** @type {number} */
        this.sourceWorldWidth_
      );
      var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
      var needsSubdivision = false;
      if (maxSubdivision > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          var targetQuadExtent = boundingExtent([a, b, c, d]);
          var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
          needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }
        if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
          needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }
      }
      if (!needsSubdivision && this.maxSourceExtent_) {
        if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
          if (!intersects$1(sourceQuadExtent, this.maxSourceExtent_)) {
            return;
          }
        }
      }
      var isNotFinite = 0;
      if (!needsSubdivision) {
        if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
          if (maxSubdivision > 0) {
            needsSubdivision = true;
          } else {
            isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
            if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
              return;
            }
          }
        }
      }
      if (maxSubdivision > 0) {
        if (!needsSubdivision) {
          var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
          var centerSrc = this.transformInv_(center);
          var dx = void 0;
          if (wrapsX) {
            var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
            dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
          } else {
            dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
          }
          var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
          var centerSrcErrorSquared = dx * dx + dy * dy;
          needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
        }
        if (needsSubdivision) {
          if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
            var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
            var bcSrc = this.transformInv_(bc);
            var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
            var daSrc = this.transformInv_(da);
            this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
            this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
          } else {
            var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
            var abSrc = this.transformInv_(ab);
            var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
            var cdSrc = this.transformInv_(cd);
            this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
            this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
          }
          return;
        }
      }
      if (wrapsX) {
        if (!this.canWrapXInSource_) {
          return;
        }
        this.wrapsXInSource_ = true;
      }
      if ((isNotFinite & 11) == 0) {
        this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
      }
      if ((isNotFinite & 14) == 0) {
        this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
      }
      if (isNotFinite) {
        if ((isNotFinite & 13) == 0) {
          this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
        }
        if ((isNotFinite & 7) == 0) {
          this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
        }
      }
    };
    Triangulation2.prototype.calculateSourceExtent = function() {
      var extent2 = createEmpty();
      this.triangles_.forEach(function(triangle, i, arr) {
        var src = triangle.source;
        extendCoordinate(extent2, src[0]);
        extendCoordinate(extent2, src[1]);
        extendCoordinate(extent2, src[2]);
      });
      return extent2;
    };
    Triangulation2.prototype.getTriangles = function() {
      return this.triangles_;
    };
    return Triangulation2;
  }()
);
const Triangulation$1 = Triangulation;
var IMAGE_SMOOTHING_DISABLED = {
  imageSmoothingEnabled: false,
  msImageSmoothingEnabled: false
};
var brokenDiagonalRendering_;
var canvasPool$1 = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    var ctx = document.createElement("canvas").getContext("2d");
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    var data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = transform$1(targetCenter, targetProj, sourceProj);
  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  var targetCenter = getCenter(targetExtent);
  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_interpolate) {
  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool$1);
  if (!opt_interpolate) {
    assign(context, IMAGE_SMOOTHING_DISABLED);
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  var sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend$2(sourceDataExtent, src.extent);
  });
  var canvasWidthInUnits = getWidth(sourceDataExtent);
  var canvasHeightInUnits = getHeight(sourceDataExtent);
  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
  if (!opt_interpolate) {
    assign(stitchContext, IMAGE_SMOOTHING_DISABLED);
  }
  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function(src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = getWidth(src.extent);
    var srcHeight = getHeight(src.extent);
    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    }
  });
  var targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0], y0 = source[0][1];
    var x1 = source[1][0], y1 = source[1][1];
    var x2 = source[2][0], y2 = source[2][1];
    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    var affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !opt_interpolate) {
      context.moveTo(u1, v1);
      var steps = 4;
      var ud = u0 - u1;
      var vd = v0 - v1;
      for (var step = 0; step < steps; step++) {
        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
        if (step != steps - 1) {
          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });
  if (opt_renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}
var __extends$p = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ReprojTile = (
  /** @class */
  function(_super) {
    __extends$p(ReprojTile2, _super);
    function ReprojTile2(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {
      var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;
      _this.renderEdges_ = opt_renderEdges !== void 0 ? opt_renderEdges : false;
      _this.pixelRatio_ = pixelRatio;
      _this.gutter_ = gutter;
      _this.canvas_ = null;
      _this.sourceTileGrid_ = sourceTileGrid;
      _this.targetTileGrid_ = targetTileGrid;
      _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
      _this.sourceTiles_ = [];
      _this.sourcesListenerKeys_ = null;
      _this.sourceZ_ = 0;
      var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
      var maxTargetExtent = _this.targetTileGrid_.getExtent();
      var maxSourceExtent = _this.sourceTileGrid_.getExtent();
      var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
      if (getArea(limitedTargetExtent) === 0) {
        _this.state = TileState.EMPTY;
        return _this;
      }
      var sourceProjExtent = sourceProj.getExtent();
      if (sourceProjExtent) {
        if (!maxSourceExtent) {
          maxSourceExtent = sourceProjExtent;
        } else {
          maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
        }
      }
      var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
      var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
      if (!isFinite(sourceResolution) || sourceResolution <= 0) {
        _this.state = TileState.EMPTY;
        return _this;
      }
      var errorThresholdInPixels = opt_errorThreshold !== void 0 ? opt_errorThreshold : ERROR_THRESHOLD;
      _this.triangulation_ = new Triangulation$1(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
      if (_this.triangulation_.getTriangles().length === 0) {
        _this.state = TileState.EMPTY;
        return _this;
      }
      _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
      var sourceExtent = _this.triangulation_.calculateSourceExtent();
      if (maxSourceExtent) {
        if (sourceProj.canWrapX()) {
          sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
          sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
        } else {
          sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
        }
      }
      if (!getArea(sourceExtent)) {
        _this.state = TileState.EMPTY;
      } else {
        var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
        for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
            if (tile) {
              _this.sourceTiles_.push(tile);
            }
          }
        }
        if (_this.sourceTiles_.length === 0) {
          _this.state = TileState.EMPTY;
        }
      }
      return _this;
    }
    ReprojTile2.prototype.getImage = function() {
      return this.canvas_;
    };
    ReprojTile2.prototype.reproject_ = function() {
      var sources = [];
      this.sourceTiles_.forEach(function(tile, i, arr) {
        if (tile && tile.getState() == TileState.LOADED) {
          sources.push({
            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
            image: tile.getImage()
          });
        }
      }.bind(this));
      this.sourceTiles_.length = 0;
      if (sources.length === 0) {
        this.state = TileState.ERROR;
      } else {
        var z = this.wrappedTileCoord_[0];
        var size = this.targetTileGrid_.getTileSize(z);
        var width = typeof size === "number" ? size : size[0];
        var height = typeof size === "number" ? size : size[1];
        var targetResolution = this.targetTileGrid_.getResolution(z);
        var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
        var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
        this.state = TileState.LOADED;
      }
      this.changed();
    };
    ReprojTile2.prototype.load = function() {
      if (this.state == TileState.IDLE) {
        this.state = TileState.LOADING;
        this.changed();
        var leftToLoad_1 = 0;
        this.sourcesListenerKeys_ = [];
        this.sourceTiles_.forEach(function(tile, i, arr) {
          var state = tile.getState();
          if (state == TileState.IDLE || state == TileState.LOADING) {
            leftToLoad_1++;
            var sourceListenKey_1 = listen(tile, EventType.CHANGE, function(e) {
              var state2 = tile.getState();
              if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
                unlistenByKey(sourceListenKey_1);
                leftToLoad_1--;
                if (leftToLoad_1 === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            }, this);
            this.sourcesListenerKeys_.push(sourceListenKey_1);
          }
        }.bind(this));
        if (leftToLoad_1 === 0) {
          setTimeout(this.reproject_.bind(this), 0);
        } else {
          this.sourceTiles_.forEach(function(tile, i, arr) {
            var state = tile.getState();
            if (state == TileState.IDLE) {
              tile.load();
            }
          });
        }
      }
    };
    ReprojTile2.prototype.unlistenSources_ = function() {
      this.sourcesListenerKeys_.forEach(unlistenByKey);
      this.sourcesListenerKeys_ = null;
    };
    ReprojTile2.prototype.release = function() {
      if (this.canvas_) {
        releaseCanvas(this.canvas_.getContext("2d"));
        canvasPool$1.push(this.canvas_);
        this.canvas_ = null;
      }
      _super.prototype.release.call(this);
    };
    return ReprojTile2;
  }(Tile$2)
);
const ReprojTile$1 = ReprojTile;
var LRUCache = (
  /** @class */
  function() {
    function LRUCache2(opt_highWaterMark) {
      this.highWaterMark = opt_highWaterMark !== void 0 ? opt_highWaterMark : 2048;
      this.count_ = 0;
      this.entries_ = {};
      this.oldest_ = null;
      this.newest_ = null;
    }
    LRUCache2.prototype.canExpireCache = function() {
      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    };
    LRUCache2.prototype.expireCache = function(keep) {
      while (this.canExpireCache()) {
        this.pop();
      }
    };
    LRUCache2.prototype.clear = function() {
      this.count_ = 0;
      this.entries_ = {};
      this.oldest_ = null;
      this.newest_ = null;
    };
    LRUCache2.prototype.containsKey = function(key) {
      return this.entries_.hasOwnProperty(key);
    };
    LRUCache2.prototype.forEach = function(f) {
      var entry = this.oldest_;
      while (entry) {
        f(entry.value_, entry.key_, this);
        entry = entry.newer;
      }
    };
    LRUCache2.prototype.get = function(key, opt_options) {
      var entry = this.entries_[key];
      assert(entry !== void 0, 15);
      if (entry === this.newest_) {
        return entry.value_;
      } else if (entry === this.oldest_) {
        this.oldest_ = /** @type {Entry} */
        this.oldest_.newer;
        this.oldest_.older = null;
      } else {
        entry.newer.older = entry.older;
        entry.older.newer = entry.newer;
      }
      entry.newer = null;
      entry.older = this.newest_;
      this.newest_.newer = entry;
      this.newest_ = entry;
      return entry.value_;
    };
    LRUCache2.prototype.remove = function(key) {
      var entry = this.entries_[key];
      assert(entry !== void 0, 15);
      if (entry === this.newest_) {
        this.newest_ = /** @type {Entry} */
        entry.older;
        if (this.newest_) {
          this.newest_.newer = null;
        }
      } else if (entry === this.oldest_) {
        this.oldest_ = /** @type {Entry} */
        entry.newer;
        if (this.oldest_) {
          this.oldest_.older = null;
        }
      } else {
        entry.newer.older = entry.older;
        entry.older.newer = entry.newer;
      }
      delete this.entries_[key];
      --this.count_;
      return entry.value_;
    };
    LRUCache2.prototype.getCount = function() {
      return this.count_;
    };
    LRUCache2.prototype.getKeys = function() {
      var keys = new Array(this.count_);
      var i = 0;
      var entry;
      for (entry = this.newest_; entry; entry = entry.older) {
        keys[i++] = entry.key_;
      }
      return keys;
    };
    LRUCache2.prototype.getValues = function() {
      var values = new Array(this.count_);
      var i = 0;
      var entry;
      for (entry = this.newest_; entry; entry = entry.older) {
        values[i++] = entry.value_;
      }
      return values;
    };
    LRUCache2.prototype.peekLast = function() {
      return this.oldest_.value_;
    };
    LRUCache2.prototype.peekLastKey = function() {
      return this.oldest_.key_;
    };
    LRUCache2.prototype.peekFirstKey = function() {
      return this.newest_.key_;
    };
    LRUCache2.prototype.peek = function(key) {
      if (!this.containsKey(key)) {
        return void 0;
      }
      return this.entries_[key].value_;
    };
    LRUCache2.prototype.pop = function() {
      var entry = this.oldest_;
      delete this.entries_[entry.key_];
      if (entry.newer) {
        entry.newer.older = null;
      }
      this.oldest_ = /** @type {Entry} */
      entry.newer;
      if (!this.oldest_) {
        this.newest_ = null;
      }
      --this.count_;
      return entry.value_;
    };
    LRUCache2.prototype.replace = function(key, value) {
      this.get(key);
      this.entries_[key].value_ = value;
    };
    LRUCache2.prototype.set = function(key, value) {
      assert(!(key in this.entries_), 16);
      var entry = {
        key_: key,
        newer: null,
        older: this.newest_,
        value_: value
      };
      if (!this.newest_) {
        this.oldest_ = entry;
      } else {
        this.newest_.newer = entry;
      }
      this.newest_ = entry;
      this.entries_[key] = entry;
      ++this.count_;
    };
    LRUCache2.prototype.setSize = function(size) {
      this.highWaterMark = size;
    };
    return LRUCache2;
  }()
);
const LRUCache$1 = LRUCache;
function createOrUpdate$1(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== void 0) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function getKey$1(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function getCacheKeyForTileKey(tileKey) {
  var _a = tileKey.substring(tileKey.lastIndexOf("/") + 1, tileKey.length).split(",").map(Number), z = _a[0], x = _a[1], y = _a[2];
  return getKeyZXY(z, x, y);
}
function fromKey(key) {
  return key.split("/").map(Number);
}
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}
var __extends$o = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileCache = (
  /** @class */
  function(_super) {
    __extends$o(TileCache2, _super);
    function TileCache2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TileCache2.prototype.expireCache = function(usedTiles) {
      while (this.canExpireCache()) {
        var tile = this.peekLast();
        if (tile.getKey() in usedTiles) {
          break;
        } else {
          this.pop().release();
        }
      }
    };
    TileCache2.prototype.pruneExceptNewestZ = function() {
      if (this.getCount() === 0) {
        return;
      }
      var key = this.peekFirstKey();
      var tileCoord = fromKey(key);
      var z = tileCoord[0];
      this.forEach(function(tile) {
        if (tile.tileCoord[0] !== z) {
          this.remove(getKey$1(tile.tileCoord));
          tile.release();
        }
      }.bind(this));
    };
    return TileCache2;
  }(LRUCache$1)
);
const TileCache$1 = TileCache;
const TileEventType = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
const ObjectEventType = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
var __extends$n = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Observable = (
  /** @class */
  function(_super) {
    __extends$n(Observable2, _super);
    function Observable2() {
      var _this = _super.call(this) || this;
      _this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      _this.onInternal;
      _this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      _this.onceInternal;
      _this.un = /** @type {ObservableOnSignature<void>} */
      _this.unInternal;
      _this.revision_ = 0;
      return _this;
    }
    Observable2.prototype.changed = function() {
      ++this.revision_;
      this.dispatchEvent(EventType.CHANGE);
    };
    Observable2.prototype.getRevision = function() {
      return this.revision_;
    };
    Observable2.prototype.onInternal = function(type, listener) {
      if (Array.isArray(type)) {
        var len = type.length;
        var keys = new Array(len);
        for (var i = 0; i < len; ++i) {
          keys[i] = listen(this, type[i], listener);
        }
        return keys;
      } else {
        return listen(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
    };
    Observable2.prototype.onceInternal = function(type, listener) {
      var key;
      if (Array.isArray(type)) {
        var len = type.length;
        key = new Array(len);
        for (var i = 0; i < len; ++i) {
          key[i] = listenOnce(this, type[i], listener);
        }
      } else {
        key = listenOnce(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      listener.ol_key = key;
      return key;
    };
    Observable2.prototype.unInternal = function(type, listener) {
      var key = (
        /** @type {Object} */
        listener.ol_key
      );
      if (key) {
        unByKey(key);
      } else if (Array.isArray(type)) {
        for (var i = 0, ii = type.length; i < ii; ++i) {
          this.removeEventListener(type[i], listener);
        }
      } else {
        this.removeEventListener(type, listener);
      }
    };
    return Observable2;
  }(EventTarget)
);
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
const Observable$1 = Observable;
var __extends$m = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ObjectEvent = (
  /** @class */
  function(_super) {
    __extends$m(ObjectEvent2, _super);
    function ObjectEvent2(type, key, oldValue) {
      var _this = _super.call(this, type) || this;
      _this.key = key;
      _this.oldValue = oldValue;
      return _this;
    }
    return ObjectEvent2;
  }(Event$1)
);
var BaseObject = (
  /** @class */
  function(_super) {
    __extends$m(BaseObject2, _super);
    function BaseObject2(opt_values) {
      var _this = _super.call(this) || this;
      _this.on;
      _this.once;
      _this.un;
      getUid(_this);
      _this.values_ = null;
      if (opt_values !== void 0) {
        _this.setProperties(opt_values);
      }
      return _this;
    }
    BaseObject2.prototype.get = function(key) {
      var value;
      if (this.values_ && this.values_.hasOwnProperty(key)) {
        value = this.values_[key];
      }
      return value;
    };
    BaseObject2.prototype.getKeys = function() {
      return this.values_ && Object.keys(this.values_) || [];
    };
    BaseObject2.prototype.getProperties = function() {
      return this.values_ && assign({}, this.values_) || {};
    };
    BaseObject2.prototype.hasProperties = function() {
      return !!this.values_;
    };
    BaseObject2.prototype.notify = function(key, oldValue) {
      var eventType;
      eventType = "change:".concat(key);
      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }
      eventType = ObjectEventType.PROPERTYCHANGE;
      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }
    };
    BaseObject2.prototype.addChangeListener = function(key, listener) {
      this.addEventListener("change:".concat(key), listener);
    };
    BaseObject2.prototype.removeChangeListener = function(key, listener) {
      this.removeEventListener("change:".concat(key), listener);
    };
    BaseObject2.prototype.set = function(key, value, opt_silent) {
      var values = this.values_ || (this.values_ = {});
      if (opt_silent) {
        values[key] = value;
      } else {
        var oldValue = values[key];
        values[key] = value;
        if (oldValue !== value) {
          this.notify(key, oldValue);
        }
      }
    };
    BaseObject2.prototype.setProperties = function(values, opt_silent) {
      for (var key in values) {
        this.set(key, values[key], opt_silent);
      }
    };
    BaseObject2.prototype.applyProperties = function(source) {
      if (!source.values_) {
        return;
      }
      assign(this.values_ || (this.values_ = {}), source.values_);
    };
    BaseObject2.prototype.unset = function(key, opt_silent) {
      if (this.values_ && key in this.values_) {
        var oldValue = this.values_[key];
        delete this.values_[key];
        if (isEmpty$1(this.values_)) {
          this.values_ = null;
        }
        if (!opt_silent) {
          this.notify(key, oldValue);
        }
      }
    };
    return BaseObject2;
  }(Observable$1)
);
const BaseObject$1 = BaseObject;
var __extends$l = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Source = (
  /** @class */
  function(_super) {
    __extends$l(Source2, _super);
    function Source2(options) {
      var _this = _super.call(this) || this;
      _this.projection = get$2(options.projection);
      _this.attributions_ = adaptAttributions(options.attributions);
      _this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
      _this.loading = false;
      _this.state_ = options.state !== void 0 ? options.state : "ready";
      _this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
      _this.interpolate_ = !!options.interpolate;
      _this.viewResolver = null;
      _this.viewRejector = null;
      var self2 = _this;
      _this.viewPromise_ = new Promise(function(resolve, reject) {
        self2.viewResolver = resolve;
        self2.viewRejector = reject;
      });
      return _this;
    }
    Source2.prototype.getAttributions = function() {
      return this.attributions_;
    };
    Source2.prototype.getAttributionsCollapsible = function() {
      return this.attributionsCollapsible_;
    };
    Source2.prototype.getProjection = function() {
      return this.projection;
    };
    Source2.prototype.getResolutions = function() {
      return abstract();
    };
    Source2.prototype.getView = function() {
      return this.viewPromise_;
    };
    Source2.prototype.getState = function() {
      return this.state_;
    };
    Source2.prototype.getWrapX = function() {
      return this.wrapX_;
    };
    Source2.prototype.getInterpolate = function() {
      return this.interpolate_;
    };
    Source2.prototype.refresh = function() {
      this.changed();
    };
    Source2.prototype.setAttributions = function(attributions) {
      this.attributions_ = adaptAttributions(attributions);
      this.changed();
    };
    Source2.prototype.setState = function(state) {
      this.state_ = state;
      this.changed();
    };
    return Source2;
  }(BaseObject$1)
);
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  return function(frameState) {
    return [attributionLike];
  };
}
const Source$1 = Source;
var TileRange = (
  /** @class */
  function() {
    function TileRange2(minX, maxX, minY, maxY) {
      this.minX = minX;
      this.maxX = maxX;
      this.minY = minY;
      this.maxY = maxY;
    }
    TileRange2.prototype.contains = function(tileCoord) {
      return this.containsXY(tileCoord[1], tileCoord[2]);
    };
    TileRange2.prototype.containsTileRange = function(tileRange) {
      return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    };
    TileRange2.prototype.containsXY = function(x, y) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    };
    TileRange2.prototype.equals = function(tileRange) {
      return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    };
    TileRange2.prototype.extend = function(tileRange) {
      if (tileRange.minX < this.minX) {
        this.minX = tileRange.minX;
      }
      if (tileRange.maxX > this.maxX) {
        this.maxX = tileRange.maxX;
      }
      if (tileRange.minY < this.minY) {
        this.minY = tileRange.minY;
      }
      if (tileRange.maxY > this.maxY) {
        this.maxY = tileRange.maxY;
      }
    };
    TileRange2.prototype.getHeight = function() {
      return this.maxY - this.minY + 1;
    };
    TileRange2.prototype.getSize = function() {
      return [this.getWidth(), this.getHeight()];
    };
    TileRange2.prototype.getWidth = function() {
      return this.maxX - this.minX + 1;
    };
    TileRange2.prototype.intersects = function(tileRange) {
      return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
    };
    return TileRange2;
  }()
);
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}
const TileRange$1 = TileRange;
var DEFAULT_MAX_ZOOM = 42;
var DEFAULT_TILE_SIZE = 256;
function forEach(flatCoordinates, offset, end, stride, callback) {
  var ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
    if (ret) {
      return ret;
    }
  }
  return false;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function intersectsLineString(flatCoordinates, offset, end, stride, extent2) {
  var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
  if (!intersects$1(extent2, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent2, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent2[0] && coordinatesExtent[2] <= extent2[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent2[1] && coordinatesExtent[3] <= extent2[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent2, point1, point2);
    }
  );
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent2) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent2)) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent2[0], extent2[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent2[0], extent2[3])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent2[2], extent2[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent2[2], extent2[3])) {
    return true;
  }
  return false;
}
function buffer(size, num, opt_size) {
  if (opt_size === void 0) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}
function scale$1(size, ratio, opt_size) {
  if (opt_size === void 0) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
}
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === void 0) {
      opt_size = [size, size];
    } else {
      opt_size[0] = size;
      opt_size[1] = size;
    }
    return opt_size;
  }
}
var tmpTileCoord = [0, 0, 0];
var DECIMALS = 5;
var TileGrid = (
  /** @class */
  function() {
    function TileGrid2(options) {
      this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
      this.resolutions_ = options.resolutions;
      assert(isSorted(this.resolutions_, function(a, b) {
        return b - a;
      }, true), 17);
      var zoomFactor;
      if (!options.origins) {
        for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
          if (!zoomFactor) {
            zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
          } else {
            if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
              zoomFactor = void 0;
              break;
            }
          }
        }
      }
      this.zoomFactor_ = zoomFactor;
      this.maxZoom = this.resolutions_.length - 1;
      this.origin_ = options.origin !== void 0 ? options.origin : null;
      this.origins_ = null;
      if (options.origins !== void 0) {
        this.origins_ = options.origins;
        assert(this.origins_.length == this.resolutions_.length, 20);
      }
      var extent2 = options.extent;
      if (extent2 !== void 0 && !this.origin_ && !this.origins_) {
        this.origin_ = getTopLeft(extent2);
      }
      assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);
      this.tileSizes_ = null;
      if (options.tileSizes !== void 0) {
        this.tileSizes_ = options.tileSizes;
        assert(this.tileSizes_.length == this.resolutions_.length, 19);
      }
      this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
      assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);
      this.extent_ = extent2 !== void 0 ? extent2 : null;
      this.fullTileRanges_ = null;
      this.tmpSize_ = [0, 0];
      this.tmpExtent_ = [0, 0, 0, 0];
      if (options.sizes !== void 0) {
        this.fullTileRanges_ = options.sizes.map(function(size, z) {
          var tileRange = new TileRange$1(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
          if (extent2) {
            var restrictedTileRange = this.getTileRangeForExtentAndZ(extent2, z);
            tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
            tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
            tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
            tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
          }
          return tileRange;
        }, this);
      } else if (extent2) {
        this.calculateTileRanges_(extent2);
      }
    }
    TileGrid2.prototype.forEachTileCoord = function(extent2, zoom, callback) {
      var tileRange = this.getTileRangeForExtentAndZ(extent2, zoom);
      for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
        for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
          callback([zoom, i, j]);
        }
      }
    };
    TileGrid2.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_tileRange, opt_extent) {
      var tileRange, x, y;
      var tileCoordExtent = null;
      var z = tileCoord[0] - 1;
      if (this.zoomFactor_ === 2) {
        x = tileCoord[1];
        y = tileCoord[2];
      } else {
        tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
      }
      while (z >= this.minZoom) {
        if (this.zoomFactor_ === 2) {
          x = Math.floor(x / 2);
          y = Math.floor(y / 2);
          tileRange = createOrUpdate(x, x, y, y, opt_tileRange);
        } else {
          tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
        }
        if (callback(z, tileRange)) {
          return true;
        }
        --z;
      }
      return false;
    };
    TileGrid2.prototype.getExtent = function() {
      return this.extent_;
    };
    TileGrid2.prototype.getMaxZoom = function() {
      return this.maxZoom;
    };
    TileGrid2.prototype.getMinZoom = function() {
      return this.minZoom;
    };
    TileGrid2.prototype.getOrigin = function(z) {
      if (this.origin_) {
        return this.origin_;
      } else {
        return this.origins_[z];
      }
    };
    TileGrid2.prototype.getResolution = function(z) {
      return this.resolutions_[z];
    };
    TileGrid2.prototype.getResolutions = function() {
      return this.resolutions_;
    };
    TileGrid2.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {
      if (tileCoord[0] < this.maxZoom) {
        if (this.zoomFactor_ === 2) {
          var minX = tileCoord[1] * 2;
          var minY = tileCoord[2] * 2;
          return createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
        }
        var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
      }
      return null;
    };
    TileGrid2.prototype.getTileRangeForTileCoordAndZ = function(tileCoord, z, opt_tileRange) {
      if (z > this.maxZoom || z < this.minZoom) {
        return null;
      }
      var tileCoordZ = tileCoord[0];
      var tileCoordX = tileCoord[1];
      var tileCoordY = tileCoord[2];
      if (z === tileCoordZ) {
        return createOrUpdate(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);
      }
      if (this.zoomFactor_) {
        var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
        var minX = Math.floor(tileCoordX * factor);
        var minY = Math.floor(tileCoordY * factor);
        if (z < tileCoordZ) {
          return createOrUpdate(minX, minX, minY, minY, opt_tileRange);
        }
        var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
        var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
        return createOrUpdate(minX, maxX, minY, maxY, opt_tileRange);
      }
      var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    };
    TileGrid2.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {
      var origin = this.getOrigin(z);
      var resolution = this.getResolution(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
      var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
      var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
      var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
      var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
      return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
    };
    TileGrid2.prototype.getTileRangeForExtentAndZ = function(extent2, z, opt_tileRange) {
      var tileCoord = tmpTileCoord;
      this.getTileCoordForXYAndZ_(extent2[0], extent2[3], z, false, tileCoord);
      var minX = tileCoord[1];
      var minY = tileCoord[2];
      this.getTileCoordForXYAndZ_(extent2[2], extent2[1], z, true, tileCoord);
      return createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
    };
    TileGrid2.prototype.getTileCoordCenter = function(tileCoord) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
      return [
        origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
        origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
      ];
    };
    TileGrid2.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
      var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
      var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
      var maxX = minX + tileSize[0] * resolution;
      var maxY = minY + tileSize[1] * resolution;
      return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);
    };
    TileGrid2.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {
      return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    };
    TileGrid2.prototype.getTileCoordForXYAndResolution_ = function(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
      var z = this.getZForResolution(resolution);
      var scale2 = resolution / this.getResolution(z);
      var origin = this.getOrigin(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
      var tileCoordX = scale2 * (x - origin[0]) / resolution / tileSize[0];
      var tileCoordY = scale2 * (origin[1] - y) / resolution / tileSize[1];
      if (reverseIntersectionPolicy) {
        tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
        tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
      } else {
        tileCoordX = floor(tileCoordX, DECIMALS);
        tileCoordY = floor(tileCoordY, DECIMALS);
      }
      return createOrUpdate$1(z, tileCoordX, tileCoordY, opt_tileCoord);
    };
    TileGrid2.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
      var origin = this.getOrigin(z);
      var resolution = this.getResolution(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
      var tileCoordX = (x - origin[0]) / resolution / tileSize[0];
      var tileCoordY = (origin[1] - y) / resolution / tileSize[1];
      if (reverseIntersectionPolicy) {
        tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
        tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
      } else {
        tileCoordX = floor(tileCoordX, DECIMALS);
        tileCoordY = floor(tileCoordY, DECIMALS);
      }
      return createOrUpdate$1(z, tileCoordX, tileCoordY, opt_tileCoord);
    };
    TileGrid2.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {
      return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
    };
    TileGrid2.prototype.getTileCoordResolution = function(tileCoord) {
      return this.resolutions_[tileCoord[0]];
    };
    TileGrid2.prototype.getTileSize = function(z) {
      if (this.tileSize_) {
        return this.tileSize_;
      } else {
        return this.tileSizes_[z];
      }
    };
    TileGrid2.prototype.getFullTileRange = function(z) {
      if (!this.fullTileRanges_) {
        return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
      } else {
        return this.fullTileRanges_[z];
      }
    };
    TileGrid2.prototype.getZForResolution = function(resolution, opt_direction) {
      var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
      return clamp(z, this.minZoom, this.maxZoom);
    };
    TileGrid2.prototype.tileCoordIntersectsViewport = function(tileCoord, viewport) {
      return intersectsLinearRing(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
    };
    TileGrid2.prototype.calculateTileRanges_ = function(extent2) {
      var length = this.resolutions_.length;
      var fullTileRanges = new Array(length);
      for (var z = this.minZoom; z < length; ++z) {
        fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent2, z);
      }
      this.fullTileRanges_ = fullTileRanges;
    };
    return TileGrid2;
  }()
);
const TileGrid$1 = TileGrid;
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}
function createForExtent(extent2, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== void 0 ? opt_corner : "top-left";
  var resolutions = resolutionsFromExtent(extent2, opt_maxZoom, opt_tileSize);
  return new TileGrid$1({
    extent: extent2,
    origin: getCorner(extent2, corner),
    resolutions,
    tileSize: opt_tileSize
  });
}
function createXYZ(opt_options) {
  var xyzOptions = opt_options || {};
  var extent2 = xyzOptions.extent || get$2("EPSG:3857").getExtent();
  var gridOptions = {
    extent: extent2,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent2, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new TileGrid$1(gridOptions);
}
function resolutionsFromExtent(extent2, opt_maxZoom, opt_tileSize, opt_maxResolution) {
  var maxZoom = opt_maxZoom !== void 0 ? opt_maxZoom : DEFAULT_MAX_ZOOM;
  var height = getHeight(extent2);
  var width = getWidth(extent2);
  var tileSize = toSize(opt_tileSize !== void 0 ? opt_tileSize : DEFAULT_TILE_SIZE);
  var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent2 = extentFromProjection(projection);
  return createForExtent(extent2, opt_maxZoom, opt_tileSize, opt_corner);
}
function extentFromProjection(projection) {
  projection = get$2(projection);
  var extent2 = projection.getExtent();
  if (!extent2) {
    var half = 180 * METERS_PER_UNIT$1[Units$1.DEGREES] / projection.getMetersPerUnit();
    extent2 = createOrUpdate$2(-half, -half, half, half);
  }
  return extent2;
}
var __extends$k = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileSource = (
  /** @class */
  function(_super) {
    __extends$k(TileSource2, _super);
    function TileSource2(options) {
      var _this = _super.call(this, {
        attributions: options.attributions,
        attributionsCollapsible: options.attributionsCollapsible,
        projection: options.projection,
        state: options.state,
        wrapX: options.wrapX,
        interpolate: options.interpolate
      }) || this;
      _this.on;
      _this.once;
      _this.un;
      _this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
      _this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
      _this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
      var tileSize = [256, 256];
      if (_this.tileGrid) {
        toSize(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);
      }
      _this.tileCache = new TileCache$1(options.cacheSize || 0);
      _this.tmpSize = [0, 0];
      _this.key_ = options.key || "";
      _this.tileOptions = {
        transition: options.transition,
        interpolate: options.interpolate
      };
      _this.zDirection = options.zDirection ? options.zDirection : 0;
      return _this;
    }
    TileSource2.prototype.canExpireCache = function() {
      return this.tileCache.canExpireCache();
    };
    TileSource2.prototype.expireCache = function(projection, usedTiles) {
      var tileCache = this.getTileCacheForProjection(projection);
      if (tileCache) {
        tileCache.expireCache(usedTiles);
      }
    };
    TileSource2.prototype.forEachLoadedTile = function(projection, z, tileRange, callback) {
      var tileCache = this.getTileCacheForProjection(projection);
      if (!tileCache) {
        return false;
      }
      var covered = true;
      var tile, tileCoordKey, loaded;
      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          tileCoordKey = getKeyZXY(z, x, y);
          loaded = false;
          if (tileCache.containsKey(tileCoordKey)) {
            tile = /** @type {!import("../Tile.js").default} */
            tileCache.get(tileCoordKey);
            loaded = tile.getState() === TileState.LOADED;
            if (loaded) {
              loaded = callback(tile) !== false;
            }
          }
          if (!loaded) {
            covered = false;
          }
        }
      }
      return covered;
    };
    TileSource2.prototype.getGutterForProjection = function(projection) {
      return 0;
    };
    TileSource2.prototype.getKey = function() {
      return this.key_;
    };
    TileSource2.prototype.setKey = function(key) {
      if (this.key_ !== key) {
        this.key_ = key;
        this.changed();
      }
    };
    TileSource2.prototype.getOpaque = function(projection) {
      return this.opaque_;
    };
    TileSource2.prototype.getResolutions = function() {
      if (!this.tileGrid) {
        return null;
      }
      return this.tileGrid.getResolutions();
    };
    TileSource2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
      return abstract();
    };
    TileSource2.prototype.getTileGrid = function() {
      return this.tileGrid;
    };
    TileSource2.prototype.getTileGridForProjection = function(projection) {
      if (!this.tileGrid) {
        return getForProjection(projection);
      } else {
        return this.tileGrid;
      }
    };
    TileSource2.prototype.getTileCacheForProjection = function(projection) {
      var sourceProjection = this.getProjection();
      assert(
        sourceProjection === null || equivalent(sourceProjection, projection),
        68
        // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
      );
      return this.tileCache;
    };
    TileSource2.prototype.getTilePixelRatio = function(pixelRatio) {
      return this.tilePixelRatio_;
    };
    TileSource2.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
      var tileGrid = this.getTileGridForProjection(projection);
      var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
      var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
      if (tilePixelRatio == 1) {
        return tileSize;
      } else {
        return scale$1(tileSize, tilePixelRatio, this.tmpSize);
      }
    };
    TileSource2.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {
      var projection = opt_projection !== void 0 ? opt_projection : this.getProjection();
      var tileGrid = this.getTileGridForProjection(projection);
      if (this.getWrapX() && projection.isGlobal()) {
        tileCoord = wrapX(tileGrid, tileCoord, projection);
      }
      return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
    };
    TileSource2.prototype.clear = function() {
      this.tileCache.clear();
    };
    TileSource2.prototype.refresh = function() {
      this.clear();
      _super.prototype.refresh.call(this);
    };
    TileSource2.prototype.updateCacheSize = function(tileCount, projection) {
      var tileCache = this.getTileCacheForProjection(projection);
      if (tileCount > tileCache.highWaterMark) {
        tileCache.highWaterMark = tileCount;
      }
    };
    TileSource2.prototype.useTile = function(z, x, y, projection) {
    };
    return TileSource2;
  }(Source$1)
);
var TileSourceEvent = (
  /** @class */
  function(_super) {
    __extends$k(TileSourceEvent2, _super);
    function TileSourceEvent2(type, tile) {
      var _this = _super.call(this, type) || this;
      _this.tile = tile;
      return _this;
    }
    return TileSourceEvent2;
  }(Event$1)
);
const TileSource$1 = TileSource;
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          assert(range, 55);
          var y = range.getHeight() - tileCoord[2] - 1;
          return y.toString();
        });
      }
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      } else {
        var h = hash(tileCoord);
        var index = modulo(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}
function expandUrl(url) {
  var urls = [];
  var match2 = /\{([a-z])-([a-z])\}/.exec(url);
  if (match2) {
    var startCharCode = match2[1].charCodeAt(0);
    var stopCharCode = match2[2].charCodeAt(0);
    var charCode = void 0;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match2[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match2 = /\{(\d+)-(\d+)\}/.exec(url);
  if (match2) {
    var stop_1 = parseInt(match2[2], 10);
    for (var i = parseInt(match2[1], 10); i <= stop_1; i++) {
      urls.push(url.replace(match2[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
var __extends$j = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var UrlTile = (
  /** @class */
  function(_super) {
    __extends$j(UrlTile2, _super);
    function UrlTile2(options) {
      var _this = _super.call(this, {
        attributions: options.attributions,
        cacheSize: options.cacheSize,
        opaque: options.opaque,
        projection: options.projection,
        state: options.state,
        tileGrid: options.tileGrid,
        tilePixelRatio: options.tilePixelRatio,
        wrapX: options.wrapX,
        transition: options.transition,
        interpolate: options.interpolate,
        key: options.key,
        attributionsCollapsible: options.attributionsCollapsible,
        zDirection: options.zDirection
      }) || this;
      _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile2.prototype.tileUrlFunction;
      _this.tileLoadFunction = options.tileLoadFunction;
      if (options.tileUrlFunction) {
        _this.tileUrlFunction = options.tileUrlFunction;
      }
      _this.urls = null;
      if (options.urls) {
        _this.setUrls(options.urls);
      } else if (options.url) {
        _this.setUrl(options.url);
      }
      _this.tileLoadingKeys_ = {};
      return _this;
    }
    UrlTile2.prototype.getTileLoadFunction = function() {
      return this.tileLoadFunction;
    };
    UrlTile2.prototype.getTileUrlFunction = function() {
      return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    };
    UrlTile2.prototype.getUrls = function() {
      return this.urls;
    };
    UrlTile2.prototype.handleTileChange = function(event) {
      var tile = (
        /** @type {import("../Tile.js").default} */
        event.target
      );
      var uid = getUid(tile);
      var tileState = tile.getState();
      var type;
      if (tileState == TileState.LOADING) {
        this.tileLoadingKeys_[uid] = true;
        type = TileEventType.TILELOADSTART;
      } else if (uid in this.tileLoadingKeys_) {
        delete this.tileLoadingKeys_[uid];
        type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;
      }
      if (type != void 0) {
        this.dispatchEvent(new TileSourceEvent(type, tile));
      }
    };
    UrlTile2.prototype.setTileLoadFunction = function(tileLoadFunction) {
      this.tileCache.clear();
      this.tileLoadFunction = tileLoadFunction;
      this.changed();
    };
    UrlTile2.prototype.setTileUrlFunction = function(tileUrlFunction, key) {
      this.tileUrlFunction = tileUrlFunction;
      this.tileCache.pruneExceptNewestZ();
      if (typeof key !== "undefined") {
        this.setKey(key);
      } else {
        this.changed();
      }
    };
    UrlTile2.prototype.setUrl = function(url) {
      var urls = expandUrl(url);
      this.urls = urls;
      this.setUrls(urls);
    };
    UrlTile2.prototype.setUrls = function(urls) {
      this.urls = urls;
      var key = urls.join("\n");
      if (this.generateTileUrlFunction_) {
        this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
      } else {
        this.setKey(key);
      }
    };
    UrlTile2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
      return void 0;
    };
    UrlTile2.prototype.useTile = function(z, x, y) {
      var tileCoordKey = getKeyZXY(z, x, y);
      if (this.tileCache.containsKey(tileCoordKey)) {
        this.tileCache.get(tileCoordKey);
      }
    };
    return UrlTile2;
  }(TileSource$1)
);
const UrlTile$1 = UrlTile;
var __extends$i = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileImage = (
  /** @class */
  function(_super) {
    __extends$i(TileImage2, _super);
    function TileImage2(options) {
      var _this = this;
      var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
      if (options.interpolate !== void 0) {
        interpolate = options.interpolate;
      }
      _this = _super.call(this, {
        attributions: options.attributions,
        cacheSize: options.cacheSize,
        opaque: options.opaque,
        projection: options.projection,
        state: options.state,
        tileGrid: options.tileGrid,
        tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
        tilePixelRatio: options.tilePixelRatio,
        tileUrlFunction: options.tileUrlFunction,
        url: options.url,
        urls: options.urls,
        wrapX: options.wrapX,
        transition: options.transition,
        interpolate,
        key: options.key,
        attributionsCollapsible: options.attributionsCollapsible,
        zDirection: options.zDirection
      }) || this;
      _this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
      _this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile$1;
      _this.tileCacheForProjection = {};
      _this.tileGridForProjection = {};
      _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
      _this.renderReprojectionEdges_ = false;
      return _this;
    }
    TileImage2.prototype.canExpireCache = function() {
      if (!ENABLE_RASTER_REPROJECTION) {
        return _super.prototype.canExpireCache.call(this);
      }
      if (this.tileCache.canExpireCache()) {
        return true;
      } else {
        for (var key in this.tileCacheForProjection) {
          if (this.tileCacheForProjection[key].canExpireCache()) {
            return true;
          }
        }
      }
      return false;
    };
    TileImage2.prototype.expireCache = function(projection, usedTiles) {
      if (!ENABLE_RASTER_REPROJECTION) {
        _super.prototype.expireCache.call(this, projection, usedTiles);
        return;
      }
      var usedTileCache = this.getTileCacheForProjection(projection);
      this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
      for (var id in this.tileCacheForProjection) {
        var tileCache = this.tileCacheForProjection[id];
        tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
      }
    };
    TileImage2.prototype.getGutterForProjection = function(projection) {
      if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
        return 0;
      } else {
        return this.getGutter();
      }
    };
    TileImage2.prototype.getGutter = function() {
      return 0;
    };
    TileImage2.prototype.getKey = function() {
      var key = _super.prototype.getKey.call(this);
      if (!this.getInterpolate()) {
        key += ":disable-interpolation";
      }
      return key;
    };
    TileImage2.prototype.getOpaque = function(projection) {
      if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
        return false;
      } else {
        return _super.prototype.getOpaque.call(this, projection);
      }
    };
    TileImage2.prototype.getTileGridForProjection = function(projection) {
      if (!ENABLE_RASTER_REPROJECTION) {
        return _super.prototype.getTileGridForProjection.call(this, projection);
      }
      var thisProj = this.getProjection();
      if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
        return this.tileGrid;
      } else {
        var projKey = getUid(projection);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = getForProjection(projection);
        }
        return this.tileGridForProjection[projKey];
      }
    };
    TileImage2.prototype.getTileCacheForProjection = function(projection) {
      if (!ENABLE_RASTER_REPROJECTION) {
        return _super.prototype.getTileCacheForProjection.call(this, projection);
      }
      var thisProj = this.getProjection();
      if (!thisProj || equivalent(thisProj, projection)) {
        return this.tileCache;
      } else {
        var projKey = getUid(projection);
        if (!(projKey in this.tileCacheForProjection)) {
          this.tileCacheForProjection[projKey] = new TileCache$1(this.tileCache.highWaterMark);
        }
        return this.tileCacheForProjection[projKey];
      }
    };
    TileImage2.prototype.createTile_ = function(z, x, y, pixelRatio, projection, key) {
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
      var tile = new this.tileClass(tileCoord, tileUrl !== void 0 ? TileState.IDLE : TileState.EMPTY, tileUrl !== void 0 ? tileUrl : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
      tile.key = key;
      tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
      return tile;
    };
    TileImage2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
      var sourceProjection = this.getProjection();
      if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
      } else {
        var cache2 = this.getTileCacheForProjection(projection);
        var tileCoord = [z, x, y];
        var tile = void 0;
        var tileCoordKey = getKey$1(tileCoord);
        if (cache2.containsKey(tileCoordKey)) {
          tile = cache2.get(tileCoordKey);
        }
        var key = this.getKey();
        if (tile && tile.key == key) {
          return tile;
        } else {
          var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
          var targetTileGrid = this.getTileGridForProjection(projection);
          var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
          var newTile = new ReprojTile$1(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function(z2, x2, y2, pixelRatio2) {
            return this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection);
          }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
          newTile.key = key;
          if (tile) {
            newTile.interimTile = tile;
            newTile.refreshInterimChain();
            cache2.replace(tileCoordKey, newTile);
          } else {
            cache2.set(tileCoordKey, newTile);
          }
          return newTile;
        }
      }
    };
    TileImage2.prototype.getTileInternal = function(z, x, y, pixelRatio, projection) {
      var tile = null;
      var tileCoordKey = getKeyZXY(z, x, y);
      var key = this.getKey();
      if (!this.tileCache.containsKey(tileCoordKey)) {
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);
        this.tileCache.set(tileCoordKey, tile);
      } else {
        tile = this.tileCache.get(tileCoordKey);
        if (tile.key != key) {
          var interimTile = tile;
          tile = this.createTile_(z, x, y, pixelRatio, projection, key);
          if (interimTile.getState() == TileState.IDLE) {
            tile.interimTile = interimTile.interimTile;
          } else {
            tile.interimTile = interimTile;
          }
          tile.refreshInterimChain();
          this.tileCache.replace(tileCoordKey, tile);
        }
      }
      return tile;
    };
    TileImage2.prototype.setRenderReprojectionEdges = function(render2) {
      if (!ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render2) {
        return;
      }
      this.renderReprojectionEdges_ = render2;
      for (var id in this.tileCacheForProjection) {
        this.tileCacheForProjection[id].clear();
      }
      this.changed();
    };
    TileImage2.prototype.setTileGridForProjection = function(projection, tilegrid) {
      if (ENABLE_RASTER_REPROJECTION) {
        var proj = get$2(projection);
        if (proj) {
          var projKey = getUid(proj);
          if (!(projKey in this.tileGridForProjection)) {
            this.tileGridForProjection[projKey] = tilegrid;
          }
        }
      }
    };
    return TileImage2;
  }(UrlTile$1)
);
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
const TileImage$1 = TileImage;
var DEFAULT_VERSION = "1.3.0";
function appendParams(uri, params2) {
  var keyParams = [];
  Object.keys(params2).forEach(function(k) {
    if (params2[k] !== null && params2[k] !== void 0) {
      keyParams.push(k + "=" + encodeURIComponent(params2[k]));
    }
  });
  var qs = keyParams.join("&");
  uri = uri.replace(/[?&]$/, "");
  uri = uri.indexOf("?") === -1 ? uri + "?" : uri + "&";
  return uri + qs;
}
var __extends$h = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileWMS = (
  /** @class */
  function(_super) {
    __extends$h(TileWMS2, _super);
    function TileWMS2(opt_options) {
      var _this = this;
      var options = opt_options ? opt_options : (
        /** @type {Options} */
        {}
      );
      var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
      if (options.interpolate !== void 0) {
        interpolate = options.interpolate;
      }
      var params2 = options.params || {};
      var transparent = "TRANSPARENT" in params2 ? params2["TRANSPARENT"] : true;
      _this = _super.call(this, {
        attributions: options.attributions,
        attributionsCollapsible: options.attributionsCollapsible,
        cacheSize: options.cacheSize,
        crossOrigin: options.crossOrigin,
        interpolate,
        opaque: !transparent,
        projection: options.projection,
        reprojectionErrorThreshold: options.reprojectionErrorThreshold,
        tileClass: options.tileClass,
        tileGrid: options.tileGrid,
        tileLoadFunction: options.tileLoadFunction,
        url: options.url,
        urls: options.urls,
        wrapX: options.wrapX !== void 0 ? options.wrapX : true,
        transition: options.transition,
        zDirection: options.zDirection
      }) || this;
      _this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
      _this.params_ = params2;
      _this.v13_ = true;
      _this.serverType_ = options.serverType;
      _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
      _this.tmpExtent_ = createEmpty();
      _this.updateV13_();
      _this.setKey(_this.getKeyForParams_());
      return _this;
    }
    TileWMS2.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params2) {
      var projectionObj = get$2(projection);
      var sourceProjectionObj = this.getProjection();
      var tileGrid = this.getTileGrid();
      if (!tileGrid) {
        tileGrid = this.getTileGridForProjection(projectionObj);
      }
      var z = tileGrid.getZForResolution(resolution, this.zDirection);
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      if (tileGrid.getResolutions().length <= tileCoord[0]) {
        return void 0;
      }
      var tileResolution = tileGrid.getResolution(tileCoord[0]);
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
      var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
      var gutter = this.gutter_;
      if (gutter !== 0) {
        tileSize = buffer(tileSize, gutter, this.tmpSize);
        tileExtent = buffer$1(tileExtent, tileResolution * gutter, tileExtent);
      }
      if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
        tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
        tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);
        coordinate = transform$1(coordinate, projectionObj, sourceProjectionObj);
      }
      var baseParams = {
        "SERVICE": "WMS",
        "VERSION": DEFAULT_VERSION,
        "REQUEST": "GetFeatureInfo",
        "FORMAT": "image/png",
        "TRANSPARENT": true,
        "QUERY_LAYERS": this.params_["LAYERS"]
      };
      assign(baseParams, this.params_, params2);
      var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
      var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
      baseParams[this.v13_ ? "I" : "X"] = x;
      baseParams[this.v13_ ? "J" : "Y"] = y;
      return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
    };
    TileWMS2.prototype.getLegendUrl = function(resolution, params2) {
      if (this.urls[0] === void 0) {
        return void 0;
      }
      var baseParams = {
        "SERVICE": "WMS",
        "VERSION": DEFAULT_VERSION,
        "REQUEST": "GetLegendGraphic",
        "FORMAT": "image/png"
      };
      if (params2 === void 0 || params2["LAYER"] === void 0) {
        var layers = this.params_.LAYERS;
        var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
        if (!isSingleLayer) {
          return void 0;
        }
        baseParams["LAYER"] = layers;
      }
      if (resolution !== void 0) {
        var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
        var pixelSize = 28e-5;
        baseParams["SCALE"] = resolution * mpu / pixelSize;
      }
      assign(baseParams, params2);
      return appendParams(
        /** @type {string} */
        this.urls[0],
        baseParams
      );
    };
    TileWMS2.prototype.getGutter = function() {
      return this.gutter_;
    };
    TileWMS2.prototype.getParams = function() {
      return this.params_;
    };
    TileWMS2.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params2) {
      var urls = this.urls;
      if (!urls) {
        return void 0;
      }
      params2["WIDTH"] = tileSize[0];
      params2["HEIGHT"] = tileSize[1];
      params2[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
      if (!("STYLES" in this.params_)) {
        params2["STYLES"] = "";
      }
      if (pixelRatio != 1) {
        switch (this.serverType_) {
          case "geoserver":
            var dpi = 90 * pixelRatio + 0.5 | 0;
            if ("FORMAT_OPTIONS" in params2) {
              params2["FORMAT_OPTIONS"] += ";dpi:" + dpi;
            } else {
              params2["FORMAT_OPTIONS"] = "dpi:" + dpi;
            }
            break;
          case "mapserver":
            params2["MAP_RESOLUTION"] = 90 * pixelRatio;
            break;
          case "carmentaserver":
          case "qgis":
            params2["DPI"] = 90 * pixelRatio;
            break;
          default:
            assert(false, 52);
            break;
        }
      }
      var axisOrientation = projection.getAxisOrientation();
      var bbox = tileExtent;
      if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
        var tmp2 = void 0;
        tmp2 = tileExtent[0];
        bbox[0] = tileExtent[1];
        bbox[1] = tmp2;
        tmp2 = tileExtent[2];
        bbox[2] = tileExtent[3];
        bbox[3] = tmp2;
      }
      params2["BBOX"] = bbox.join(",");
      var url;
      if (urls.length == 1) {
        url = urls[0];
      } else {
        var index = modulo(hash(tileCoord), urls.length);
        url = urls[index];
      }
      return appendParams(url, params2);
    };
    TileWMS2.prototype.getTilePixelRatio = function(pixelRatio) {
      return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;
    };
    TileWMS2.prototype.getKeyForParams_ = function() {
      var i = 0;
      var res = [];
      for (var key in this.params_) {
        res[i++] = key + "-" + this.params_[key];
      }
      return res.join("/");
    };
    TileWMS2.prototype.updateParams = function(params2) {
      assign(this.params_, params2);
      this.updateV13_();
      this.setKey(this.getKeyForParams_());
    };
    TileWMS2.prototype.updateV13_ = function() {
      var version = this.params_["VERSION"] || DEFAULT_VERSION;
      this.v13_ = compareVersions(version, "1.3") >= 0;
    };
    TileWMS2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
      var tileGrid = this.getTileGrid();
      if (!tileGrid) {
        tileGrid = this.getTileGridForProjection(projection);
      }
      if (tileGrid.getResolutions().length <= tileCoord[0]) {
        return void 0;
      }
      if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
        pixelRatio = 1;
      }
      var tileResolution = tileGrid.getResolution(tileCoord[0]);
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
      var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
      var gutter = this.gutter_;
      if (gutter !== 0) {
        tileSize = buffer(tileSize, gutter, this.tmpSize);
        tileExtent = buffer$1(tileExtent, tileResolution * gutter, tileExtent);
      }
      if (pixelRatio != 1) {
        tileSize = scale$1(tileSize, pixelRatio, this.tmpSize);
      }
      var baseParams = {
        "SERVICE": "WMS",
        "VERSION": DEFAULT_VERSION,
        "REQUEST": "GetMap",
        "FORMAT": "image/png",
        "TRANSPARENT": true
      };
      assign(baseParams, this.params_);
      return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
    };
    return TileWMS2;
  }(TileImage$1)
);
const TileWMS$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: TileWMS
}, Symbol.toStringTag, { value: "Module" }));
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(TileWMS$1);
const CollectionEventType = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
};
var __extends$g = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Property = {
  LENGTH: "length"
};
var CollectionEvent = (
  /** @class */
  function(_super) {
    __extends$g(CollectionEvent2, _super);
    function CollectionEvent2(type, opt_element, opt_index) {
      var _this = _super.call(this, type) || this;
      _this.element = opt_element;
      _this.index = opt_index;
      return _this;
    }
    return CollectionEvent2;
  }(Event$1)
);
var Collection = (
  /** @class */
  function(_super) {
    __extends$g(Collection2, _super);
    function Collection2(opt_array, opt_options) {
      var _this = _super.call(this) || this;
      _this.on;
      _this.once;
      _this.un;
      var options = opt_options || {};
      _this.unique_ = !!options.unique;
      _this.array_ = opt_array ? opt_array : [];
      if (_this.unique_) {
        for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
          _this.assertUnique_(_this.array_[i], i);
        }
      }
      _this.updateLength_();
      return _this;
    }
    Collection2.prototype.clear = function() {
      while (this.getLength() > 0) {
        this.pop();
      }
    };
    Collection2.prototype.extend = function(arr) {
      for (var i = 0, ii = arr.length; i < ii; ++i) {
        this.push(arr[i]);
      }
      return this;
    };
    Collection2.prototype.forEach = function(f) {
      var array = this.array_;
      for (var i = 0, ii = array.length; i < ii; ++i) {
        f(array[i], i, array);
      }
    };
    Collection2.prototype.getArray = function() {
      return this.array_;
    };
    Collection2.prototype.item = function(index) {
      return this.array_[index];
    };
    Collection2.prototype.getLength = function() {
      return this.get(Property.LENGTH);
    };
    Collection2.prototype.insertAt = function(index, elem) {
      if (this.unique_) {
        this.assertUnique_(elem);
      }
      this.array_.splice(index, 0, elem);
      this.updateLength_();
      this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
    };
    Collection2.prototype.pop = function() {
      return this.removeAt(this.getLength() - 1);
    };
    Collection2.prototype.push = function(elem) {
      if (this.unique_) {
        this.assertUnique_(elem);
      }
      var n = this.getLength();
      this.insertAt(n, elem);
      return this.getLength();
    };
    Collection2.prototype.remove = function(elem) {
      var arr = this.array_;
      for (var i = 0, ii = arr.length; i < ii; ++i) {
        if (arr[i] === elem) {
          return this.removeAt(i);
        }
      }
      return void 0;
    };
    Collection2.prototype.removeAt = function(index) {
      var prev = this.array_[index];
      this.array_.splice(index, 1);
      this.updateLength_();
      this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
      return prev;
    };
    Collection2.prototype.setAt = function(index, elem) {
      var n = this.getLength();
      if (index < n) {
        if (this.unique_) {
          this.assertUnique_(elem, index);
        }
        var prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
        this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
      } else {
        for (var j = n; j < index; ++j) {
          this.insertAt(j, void 0);
        }
        this.insertAt(index, elem);
      }
    };
    Collection2.prototype.updateLength_ = function() {
      this.set(Property.LENGTH, this.array_.length);
    };
    Collection2.prototype.assertUnique_ = function(elem, opt_except) {
      for (var i = 0, ii = this.array_.length; i < ii; ++i) {
        if (this.array_[i] === elem && i !== opt_except) {
          throw new AssertionError$1(58);
        }
      }
    };
    return Collection2;
  }(BaseObject$1)
);
const Collection$1 = Collection;
function quickselect(arr, k, left, right, compare) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap$1(arr, left, k);
    if (compare(arr[right], t) > 0)
      swap$1(arr, left, right);
    while (i < j) {
      swap$1(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0)
        i++;
      while (compare(arr[j], t) > 0)
        j--;
    }
    if (compare(arr[left], t) === 0)
      swap$1(arr, left, j);
    else {
      j++;
      swap$1(arr, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swap$1(arr, i, j) {
  var tmp2 = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp2;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
let RBush$2 = class RBush {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox, node))
      return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf)
            result.push(child);
          else if (contains(bbox, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects(bbox, node))
      return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length))
      return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item)
      return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else
        node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf)
        result.push(...node.children);
      else
        nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level)
        break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area2 = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area2;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area2 < minArea ? area2 : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area2 < minArea) {
            minArea = area2;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area2 = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area2 < minArea ? area2 : minArea;
      } else if (overlap === minOverlap) {
        if (area2 < minArea) {
          minArea = area2;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin)
      node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level) {
    for (let i = level; i >= 0; i--) {
      extend(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else
          this.clear();
      } else
        calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i]))
      return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n)
      continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
var RBush2 = (
  /** @class */
  function() {
    function RBush3(opt_maxEntries) {
      this.rbush_ = new RBush$2(opt_maxEntries);
      this.items_ = {};
    }
    RBush3.prototype.insert = function(extent2, value) {
      var item = {
        minX: extent2[0],
        minY: extent2[1],
        maxX: extent2[2],
        maxY: extent2[3],
        value
      };
      this.rbush_.insert(item);
      this.items_[getUid(value)] = item;
    };
    RBush3.prototype.load = function(extents, values) {
      var items = new Array(values.length);
      for (var i = 0, l = values.length; i < l; i++) {
        var extent2 = extents[i];
        var value = values[i];
        var item = {
          minX: extent2[0],
          minY: extent2[1],
          maxX: extent2[2],
          maxY: extent2[3],
          value
        };
        items[i] = item;
        this.items_[getUid(value)] = item;
      }
      this.rbush_.load(items);
    };
    RBush3.prototype.remove = function(value) {
      var uid = getUid(value);
      var item = this.items_[uid];
      delete this.items_[uid];
      return this.rbush_.remove(item) !== null;
    };
    RBush3.prototype.update = function(extent2, value) {
      var item = this.items_[getUid(value)];
      var bbox = [item.minX, item.minY, item.maxX, item.maxY];
      if (!equals$1(bbox, extent2)) {
        this.remove(value);
        this.insert(extent2, value);
      }
    };
    RBush3.prototype.getAll = function() {
      var items = this.rbush_.all();
      return items.map(function(item) {
        return item.value;
      });
    };
    RBush3.prototype.getInExtent = function(extent2) {
      var bbox = {
        minX: extent2[0],
        minY: extent2[1],
        maxX: extent2[2],
        maxY: extent2[3]
      };
      var items = this.rbush_.search(bbox);
      return items.map(function(item) {
        return item.value;
      });
    };
    RBush3.prototype.forEach = function(callback) {
      return this.forEach_(this.getAll(), callback);
    };
    RBush3.prototype.forEachInExtent = function(extent2, callback) {
      return this.forEach_(this.getInExtent(extent2), callback);
    };
    RBush3.prototype.forEach_ = function(values, callback) {
      var result;
      for (var i = 0, l = values.length; i < l; i++) {
        result = callback(values[i]);
        if (result) {
          return result;
        }
      }
      return result;
    };
    RBush3.prototype.isEmpty = function() {
      return isEmpty$1(this.items_);
    };
    RBush3.prototype.clear = function() {
      this.rbush_.clear();
      this.items_ = {};
    };
    RBush3.prototype.getExtent = function(opt_extent) {
      var data = this.rbush_.toJSON();
      return createOrUpdate$2(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
    };
    RBush3.prototype.concat = function(rbush) {
      this.rbush_.load(rbush.rbush_.all());
      for (var i in rbush.items_) {
        this.items_[i] = rbush.items_[i];
      }
    };
    return RBush3;
  }()
);
const RBush$1 = RBush2;
const VectorEventType = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function all(extent2, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
var withCredentials = false;
function loadFeaturesXhr(url, format, extent2, resolution, projection, success, failure) {
  var xhr2 = new XMLHttpRequest();
  xhr2.open("GET", typeof url === "function" ? url(extent2, resolution, projection) : url, true);
  if (format.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      var type = format.getType();
      var source = void 0;
      if (type == "json" || type == "text") {
        source = xhr2.responseText;
      } else if (type == "xml") {
        source = xhr2.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(xhr2.responseText, "application/xml");
        }
      } else if (type == "arraybuffer") {
        source = /** @type {ArrayBuffer} */
        xhr2.response;
      }
      if (source) {
        success(
          /** @type {Array<import("./Feature.js").default>} */
          format.readFeatures(source, {
            extent: extent2,
            featureProjection: projection
          }),
          format.readProjection(source)
        );
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr$1(url, format) {
  return function(extent2, resolution, projection, success, failure) {
    var source = (
      /** @type {import("./source/Vector").default} */
      this
    );
    loadFeaturesXhr(
      url,
      format,
      extent2,
      resolution,
      projection,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(features, dataProjection) {
        source.addFeatures(features);
        if (success !== void 0) {
          success(features);
        }
      },
      /* FIXME handle error */
      failure ? failure : VOID
    );
  };
}
var __extends$f = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorSourceEvent = (
  /** @class */
  function(_super) {
    __extends$f(VectorSourceEvent2, _super);
    function VectorSourceEvent2(type, opt_feature, opt_features) {
      var _this = _super.call(this, type) || this;
      _this.feature = opt_feature;
      _this.features = opt_features;
      return _this;
    }
    return VectorSourceEvent2;
  }(Event$1)
);
var VectorSource = (
  /** @class */
  function(_super) {
    __extends$f(VectorSource2, _super);
    function VectorSource2(opt_options) {
      var _this = this;
      var options = opt_options || {};
      _this = _super.call(this, {
        attributions: options.attributions,
        interpolate: true,
        projection: void 0,
        state: "ready",
        wrapX: options.wrapX !== void 0 ? options.wrapX : true
      }) || this;
      _this.on;
      _this.once;
      _this.un;
      _this.loader_ = VOID;
      _this.format_ = options.format;
      _this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
      _this.url_ = options.url;
      if (options.loader !== void 0) {
        _this.loader_ = options.loader;
      } else if (_this.url_ !== void 0) {
        assert(_this.format_, 7);
        _this.loader_ = xhr$1(
          _this.url_,
          /** @type {import("../format/Feature.js").default} */
          _this.format_
        );
      }
      _this.strategy_ = options.strategy !== void 0 ? options.strategy : all;
      var useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
      _this.featuresRtree_ = useSpatialIndex ? new RBush$1() : null;
      _this.loadedExtentsRtree_ = new RBush$1();
      _this.loadingExtentsCount_ = 0;
      _this.nullGeometryFeatures_ = {};
      _this.idIndex_ = {};
      _this.uidIndex_ = {};
      _this.featureChangeKeys_ = {};
      _this.featuresCollection_ = null;
      var collection, features;
      if (Array.isArray(options.features)) {
        features = /** @type {Array<import("../Feature.js").default<Geometry>>} */
        options.features;
      } else if (options.features) {
        collection = /** @type {Collection<import("../Feature.js").default<Geometry>>} */
        options.features;
        features = collection.getArray();
      }
      if (!useSpatialIndex && collection === void 0) {
        collection = new Collection$1(features);
      }
      if (features !== void 0) {
        _this.addFeaturesInternal(features);
      }
      if (collection !== void 0) {
        _this.bindFeaturesCollection_(collection);
      }
      return _this;
    }
    VectorSource2.prototype.addFeature = function(feature) {
      this.addFeatureInternal(feature);
      this.changed();
    };
    VectorSource2.prototype.addFeatureInternal = function(feature) {
      var featureKey = getUid(feature);
      if (!this.addToIndex_(featureKey, feature)) {
        if (this.featuresCollection_) {
          this.featuresCollection_.remove(feature);
        }
        return;
      }
      this.setupChangeEvents_(featureKey, feature);
      var geometry = feature.getGeometry();
      if (geometry) {
        var extent2 = geometry.getExtent();
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent2, feature);
        }
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
      this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
    };
    VectorSource2.prototype.setupChangeEvents_ = function(featureKey, feature) {
      this.featureChangeKeys_[featureKey] = [
        listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),
        listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)
      ];
    };
    VectorSource2.prototype.addToIndex_ = function(featureKey, feature) {
      var valid = true;
      var id = feature.getId();
      if (id !== void 0) {
        if (!(id.toString() in this.idIndex_)) {
          this.idIndex_[id.toString()] = feature;
        } else {
          valid = false;
        }
      }
      if (valid) {
        assert(!(featureKey in this.uidIndex_), 30);
        this.uidIndex_[featureKey] = feature;
      }
      return valid;
    };
    VectorSource2.prototype.addFeatures = function(features) {
      this.addFeaturesInternal(features);
      this.changed();
    };
    VectorSource2.prototype.addFeaturesInternal = function(features) {
      var extents = [];
      var newFeatures = [];
      var geometryFeatures = [];
      for (var i = 0, length_1 = features.length; i < length_1; i++) {
        var feature = features[i];
        var featureKey = getUid(feature);
        if (this.addToIndex_(featureKey, feature)) {
          newFeatures.push(feature);
        }
      }
      for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
        var feature = newFeatures[i];
        var featureKey = getUid(feature);
        this.setupChangeEvents_(featureKey, feature);
        var geometry = feature.getGeometry();
        if (geometry) {
          var extent2 = geometry.getExtent();
          extents.push(extent2);
          geometryFeatures.push(feature);
        } else {
          this.nullGeometryFeatures_[featureKey] = feature;
        }
      }
      if (this.featuresRtree_) {
        this.featuresRtree_.load(extents, geometryFeatures);
      }
      if (this.hasListener(VectorEventType.ADDFEATURE)) {
        for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));
        }
      }
    };
    VectorSource2.prototype.bindFeaturesCollection_ = function(collection) {
      var modifyingCollection = false;
      this.addEventListener(
        VectorEventType.ADDFEATURE,
        /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            collection.push(evt.feature);
            modifyingCollection = false;
          }
        }
      );
      this.addEventListener(
        VectorEventType.REMOVEFEATURE,
        /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            collection.remove(evt.feature);
            modifyingCollection = false;
          }
        }
      );
      collection.addEventListener(
        CollectionEventType.ADD,
        /**
         * @param {import("../Collection.js").CollectionEvent} evt The collection event
         */
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            this.addFeature(
              /** @type {import("../Feature.js").default<Geometry>} */
              evt.element
            );
            modifyingCollection = false;
          }
        }.bind(this)
      );
      collection.addEventListener(
        CollectionEventType.REMOVE,
        /**
         * @param {import("../Collection.js").CollectionEvent} evt The collection event
         */
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            this.removeFeature(
              /** @type {import("../Feature.js").default<Geometry>} */
              evt.element
            );
            modifyingCollection = false;
          }
        }.bind(this)
      );
      this.featuresCollection_ = collection;
    };
    VectorSource2.prototype.clear = function(opt_fast) {
      if (opt_fast) {
        for (var featureId in this.featureChangeKeys_) {
          var keys = this.featureChangeKeys_[featureId];
          keys.forEach(unlistenByKey);
        }
        if (!this.featuresCollection_) {
          this.featureChangeKeys_ = {};
          this.idIndex_ = {};
          this.uidIndex_ = {};
        }
      } else {
        if (this.featuresRtree_) {
          var removeAndIgnoreReturn = function(feature) {
            this.removeFeatureInternal(feature);
          }.bind(this);
          this.featuresRtree_.forEach(removeAndIgnoreReturn);
          for (var id in this.nullGeometryFeatures_) {
            this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
          }
        }
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.clear();
      }
      if (this.featuresRtree_) {
        this.featuresRtree_.clear();
      }
      this.nullGeometryFeatures_ = {};
      var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
      this.dispatchEvent(clearEvent);
      this.changed();
    };
    VectorSource2.prototype.forEachFeature = function(callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEach(callback);
      } else if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    };
    VectorSource2.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
      var extent2 = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
      return this.forEachFeatureInExtent(extent2, function(feature) {
        var geometry = feature.getGeometry();
        if (geometry.intersectsCoordinate(coordinate)) {
          return callback(feature);
        } else {
          return void 0;
        }
      });
    };
    VectorSource2.prototype.forEachFeatureInExtent = function(extent2, callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEachInExtent(extent2, callback);
      } else if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    };
    VectorSource2.prototype.forEachFeatureIntersectingExtent = function(extent2, callback) {
      return this.forEachFeatureInExtent(
        extent2,
        /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         */
        function(feature) {
          var geometry = feature.getGeometry();
          if (geometry.intersectsExtent(extent2)) {
            var result = callback(feature);
            if (result) {
              return result;
            }
          }
        }
      );
    };
    VectorSource2.prototype.getFeaturesCollection = function() {
      return this.featuresCollection_;
    };
    VectorSource2.prototype.getFeatures = function() {
      var features;
      if (this.featuresCollection_) {
        features = this.featuresCollection_.getArray().slice(0);
      } else if (this.featuresRtree_) {
        features = this.featuresRtree_.getAll();
        if (!isEmpty$1(this.nullGeometryFeatures_)) {
          extend$1(features, getValues(this.nullGeometryFeatures_));
        }
      }
      return (
        /** @type {Array<import("../Feature.js").default<Geometry>>} */
        features
      );
    };
    VectorSource2.prototype.getFeaturesAtCoordinate = function(coordinate) {
      var features = [];
      this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
        features.push(feature);
      });
      return features;
    };
    VectorSource2.prototype.getFeaturesInExtent = function(extent2, opt_projection) {
      var _this = this;
      if (this.featuresRtree_) {
        var multiWorld = opt_projection && opt_projection.canWrapX() && this.getWrapX();
        if (!multiWorld) {
          return this.featuresRtree_.getInExtent(extent2);
        }
        var extents = wrapAndSliceX(extent2, opt_projection);
        return [].concat.apply([], extents.map(function(anExtent) {
          return _this.featuresRtree_.getInExtent(anExtent);
        }));
      } else if (this.featuresCollection_) {
        return this.featuresCollection_.getArray().slice(0);
      } else {
        return [];
      }
    };
    VectorSource2.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
      var x = coordinate[0];
      var y = coordinate[1];
      var closestFeature = null;
      var closestPoint = [NaN, NaN];
      var minSquaredDistance = Infinity;
      var extent2 = [-Infinity, -Infinity, Infinity, Infinity];
      var filter = opt_filter ? opt_filter : TRUE;
      this.featuresRtree_.forEachInExtent(
        extent2,
        /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         */
        function(feature) {
          if (filter(feature)) {
            var geometry = feature.getGeometry();
            var previousMinSquaredDistance = minSquaredDistance;
            minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
            if (minSquaredDistance < previousMinSquaredDistance) {
              closestFeature = feature;
              var minDistance = Math.sqrt(minSquaredDistance);
              extent2[0] = x - minDistance;
              extent2[1] = y - minDistance;
              extent2[2] = x + minDistance;
              extent2[3] = y + minDistance;
            }
          }
        }
      );
      return closestFeature;
    };
    VectorSource2.prototype.getExtent = function(opt_extent) {
      return this.featuresRtree_.getExtent(opt_extent);
    };
    VectorSource2.prototype.getFeatureById = function(id) {
      var feature = this.idIndex_[id.toString()];
      return feature !== void 0 ? feature : null;
    };
    VectorSource2.prototype.getFeatureByUid = function(uid) {
      var feature = this.uidIndex_[uid];
      return feature !== void 0 ? feature : null;
    };
    VectorSource2.prototype.getFormat = function() {
      return this.format_;
    };
    VectorSource2.prototype.getOverlaps = function() {
      return this.overlaps_;
    };
    VectorSource2.prototype.getUrl = function() {
      return this.url_;
    };
    VectorSource2.prototype.handleFeatureChange_ = function(event) {
      var feature = (
        /** @type {import("../Feature.js").default<Geometry>} */
        event.target
      );
      var featureKey = getUid(feature);
      var geometry = feature.getGeometry();
      if (!geometry) {
        if (!(featureKey in this.nullGeometryFeatures_)) {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
          this.nullGeometryFeatures_[featureKey] = feature;
        }
      } else {
        var extent2 = geometry.getExtent();
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent2, feature);
          }
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.update(extent2, feature);
          }
        }
      }
      var id = feature.getId();
      if (id !== void 0) {
        var sid = id.toString();
        if (this.idIndex_[sid] !== feature) {
          this.removeFromIdIndex_(feature);
          this.idIndex_[sid] = feature;
        }
      } else {
        this.removeFromIdIndex_(feature);
        this.uidIndex_[featureKey] = feature;
      }
      this.changed();
      this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
    };
    VectorSource2.prototype.hasFeature = function(feature) {
      var id = feature.getId();
      if (id !== void 0) {
        return id in this.idIndex_;
      } else {
        return getUid(feature) in this.uidIndex_;
      }
    };
    VectorSource2.prototype.isEmpty = function() {
      if (this.featuresRtree_) {
        return this.featuresRtree_.isEmpty() && isEmpty$1(this.nullGeometryFeatures_);
      }
      if (this.featuresCollection_) {
        return this.featuresCollection_.getLength() === 0;
      }
      return true;
    };
    VectorSource2.prototype.loadFeatures = function(extent2, resolution, projection) {
      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var extentsToLoad = this.strategy_(extent2, resolution, projection);
      var _loop_1 = function(i2, ii2) {
        var extentToLoad = extentsToLoad[i2];
        var alreadyLoaded = loadedExtentsRtree.forEachInExtent(
          extentToLoad,
          /**
           * @param {{extent: import("../extent.js").Extent}} object Object.
           * @return {boolean} Contains.
           */
          function(object) {
            return containsExtent(object.extent, extentToLoad);
          }
        );
        if (!alreadyLoaded) {
          ++this_1.loadingExtentsCount_;
          this_1.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));
          this_1.loader_.call(this_1, extentToLoad, resolution, projection, function(features) {
            --this.loadingExtentsCount_;
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, void 0, features));
          }.bind(this_1), function() {
            --this.loadingExtentsCount_;
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
          }.bind(this_1));
          loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
        }
      };
      var this_1 = this;
      for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
        _loop_1(i);
      }
      this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    };
    VectorSource2.prototype.refresh = function() {
      this.clear(true);
      this.loadedExtentsRtree_.clear();
      _super.prototype.refresh.call(this);
    };
    VectorSource2.prototype.removeLoadedExtent = function(extent2) {
      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var obj;
      loadedExtentsRtree.forEachInExtent(extent2, function(object) {
        if (equals$1(object.extent, extent2)) {
          obj = object;
          return true;
        }
      });
      if (obj) {
        loadedExtentsRtree.remove(obj);
      }
    };
    VectorSource2.prototype.removeFeature = function(feature) {
      if (!feature) {
        return;
      }
      var featureKey = getUid(feature);
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
      }
      var result = this.removeFeatureInternal(feature);
      if (result) {
        this.changed();
      }
    };
    VectorSource2.prototype.removeFeatureInternal = function(feature) {
      var featureKey = getUid(feature);
      var featureChangeKeys = this.featureChangeKeys_[featureKey];
      if (!featureChangeKeys) {
        return;
      }
      featureChangeKeys.forEach(unlistenByKey);
      delete this.featureChangeKeys_[featureKey];
      var id = feature.getId();
      if (id !== void 0) {
        delete this.idIndex_[id.toString()];
      }
      delete this.uidIndex_[featureKey];
      this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
      return feature;
    };
    VectorSource2.prototype.removeFromIdIndex_ = function(feature) {
      var removed = false;
      for (var id in this.idIndex_) {
        if (this.idIndex_[id] === feature) {
          delete this.idIndex_[id];
          removed = true;
          break;
        }
      }
      return removed;
    };
    VectorSource2.prototype.setLoader = function(loader) {
      this.loader_ = loader;
    };
    VectorSource2.prototype.setUrl = function(url) {
      assert(this.format_, 7);
      this.url_ = url;
      this.setLoader(xhr$1(url, this.format_));
    };
    return VectorSource2;
  }(Source$1)
);
const Vector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VectorSourceEvent,
  default: VectorSource
}, Symbol.toStringTag, { value: "Module" }));
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(Vector);
var __extends$e = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorTile$2 = (
  /** @class */
  function(_super) {
    __extends$e(VectorTile2, _super);
    function VectorTile2(tileCoord, state, src, format, tileLoadFunction, opt_options) {
      var _this = _super.call(this, tileCoord, state, opt_options) || this;
      _this.extent = null;
      _this.format_ = format;
      _this.features_ = null;
      _this.loader_;
      _this.projection = null;
      _this.resolution;
      _this.tileLoadFunction_ = tileLoadFunction;
      _this.url_ = src;
      _this.key = src;
      return _this;
    }
    VectorTile2.prototype.getFormat = function() {
      return this.format_;
    };
    VectorTile2.prototype.getFeatures = function() {
      return this.features_;
    };
    VectorTile2.prototype.load = function() {
      if (this.state == TileState.IDLE) {
        this.setState(TileState.LOADING);
        this.tileLoadFunction_(this, this.url_);
        if (this.loader_) {
          this.loader_(this.extent, this.resolution, this.projection);
        }
      }
    };
    VectorTile2.prototype.onLoad = function(features, dataProjection) {
      this.setFeatures(features);
    };
    VectorTile2.prototype.onError = function() {
      this.setState(TileState.ERROR);
    };
    VectorTile2.prototype.setFeatures = function(features) {
      this.features_ = features;
      this.setState(TileState.LOADED);
    };
    VectorTile2.prototype.setLoader = function(loader) {
      this.loader_ = loader;
    };
    return VectorTile2;
  }(Tile$2)
);
const Tile = VectorTile$2;
var __extends$d = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var canvasPool = [];
var VectorRenderTile = (
  /** @class */
  function(_super) {
    __extends$d(VectorRenderTile2, _super);
    function VectorRenderTile2(tileCoord, state, urlTileCoord, getSourceTiles) {
      var _this = _super.call(this, tileCoord, state, { transition: 0 }) || this;
      _this.context_ = {};
      _this.executorGroups = {};
      _this.declutterExecutorGroups = {};
      _this.loadingSourceTiles = 0;
      _this.hitDetectionImageData = {};
      _this.replayState_ = {};
      _this.sourceTiles = [];
      _this.errorTileKeys = {};
      _this.wantedResolution;
      _this.getSourceTiles = getSourceTiles.bind(void 0, _this);
      _this.wrappedTileCoord = urlTileCoord;
      return _this;
    }
    VectorRenderTile2.prototype.getContext = function(layer) {
      var key = getUid(layer);
      if (!(key in this.context_)) {
        this.context_[key] = createCanvasContext2D(1, 1, canvasPool);
      }
      return this.context_[key];
    };
    VectorRenderTile2.prototype.hasContext = function(layer) {
      return getUid(layer) in this.context_;
    };
    VectorRenderTile2.prototype.getImage = function(layer) {
      return this.hasContext(layer) ? this.getContext(layer).canvas : null;
    };
    VectorRenderTile2.prototype.getReplayState = function(layer) {
      var key = getUid(layer);
      if (!(key in this.replayState_)) {
        this.replayState_[key] = {
          dirty: false,
          renderedRenderOrder: null,
          renderedResolution: NaN,
          renderedRevision: -1,
          renderedTileResolution: NaN,
          renderedTileRevision: -1,
          renderedTileZ: -1
        };
      }
      return this.replayState_[key];
    };
    VectorRenderTile2.prototype.load = function() {
      this.getSourceTiles();
    };
    VectorRenderTile2.prototype.release = function() {
      for (var key in this.context_) {
        var context = this.context_[key];
        releaseCanvas(context);
        canvasPool.push(context.canvas);
        delete this.context_[key];
      }
      _super.prototype.release.call(this);
    };
    return VectorRenderTile2;
  }(Tile$2)
);
const VectorRenderTile$1 = VectorRenderTile;
var __extends$c = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorTile = (
  /** @class */
  function(_super) {
    __extends$c(VectorTile2, _super);
    function VectorTile2(options) {
      var _this = this;
      var projection = options.projection || "EPSG:3857";
      var extent2 = options.extent || extentFromProjection(projection);
      var tileGrid = options.tileGrid || createXYZ({
        extent: extent2,
        maxResolution: options.maxResolution,
        maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 22,
        minZoom: options.minZoom,
        tileSize: options.tileSize || 512
      });
      _this = _super.call(this, {
        attributions: options.attributions,
        attributionsCollapsible: options.attributionsCollapsible,
        cacheSize: options.cacheSize,
        interpolate: true,
        opaque: false,
        projection,
        state: options.state,
        tileGrid,
        tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,
        tileUrlFunction: options.tileUrlFunction,
        url: options.url,
        urls: options.urls,
        wrapX: options.wrapX === void 0 ? true : options.wrapX,
        transition: options.transition,
        zDirection: options.zDirection === void 0 ? 1 : options.zDirection
      }) || this;
      _this.format_ = options.format ? options.format : null;
      _this.sourceTileCache = new TileCache$1(_this.tileCache.highWaterMark);
      _this.overlaps_ = options.overlaps == void 0 ? true : options.overlaps;
      _this.tileClass = options.tileClass ? options.tileClass : Tile;
      _this.tileGrids_ = {};
      return _this;
    }
    VectorTile2.prototype.getFeaturesInExtent = function(extent2) {
      var features = [];
      var tileCache = this.tileCache;
      if (tileCache.getCount() === 0) {
        return features;
      }
      var z = fromKey(tileCache.peekFirstKey())[0];
      var tileGrid = this.tileGrid;
      tileCache.forEach(function(tile) {
        if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {
          return;
        }
        var sourceTiles = tile.getSourceTiles();
        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
          var sourceTile = sourceTiles[i];
          var tileCoord = sourceTile.tileCoord;
          if (intersects$1(extent2, tileGrid.getTileCoordExtent(tileCoord))) {
            var tileFeatures = sourceTile.getFeatures();
            if (tileFeatures) {
              for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {
                var candidate = tileFeatures[j];
                var geometry = candidate.getGeometry();
                if (intersects$1(extent2, geometry.getExtent())) {
                  features.push(candidate);
                }
              }
            }
          }
        }
      });
      return features;
    };
    VectorTile2.prototype.getOverlaps = function() {
      return this.overlaps_;
    };
    VectorTile2.prototype.clear = function() {
      this.tileCache.clear();
      this.sourceTileCache.clear();
    };
    VectorTile2.prototype.expireCache = function(projection, usedTiles) {
      var tileCache = this.getTileCacheForProjection(projection);
      var usedSourceTiles = Object.keys(usedTiles).reduce(function(acc, key) {
        var cacheKey = getCacheKeyForTileKey(key);
        var tile = tileCache.peek(cacheKey);
        if (tile) {
          var sourceTiles = tile.sourceTiles;
          for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
            acc[sourceTiles[i].getKey()] = true;
          }
        }
        return acc;
      }, {});
      _super.prototype.expireCache.call(this, projection, usedTiles);
      this.sourceTileCache.expireCache(usedSourceTiles);
    };
    VectorTile2.prototype.getSourceTiles = function(pixelRatio, projection, tile) {
      var _this = this;
      if (tile.getState() === TileState.IDLE) {
        tile.setState(TileState.LOADING);
        var urlTileCoord = tile.wrappedTileCoord;
        var tileGrid = this.getTileGridForProjection(projection);
        var extent2 = tileGrid.getTileCoordExtent(urlTileCoord);
        var z = urlTileCoord[0];
        var resolution = tileGrid.getResolution(z);
        buffer$1(extent2, -resolution, extent2);
        var sourceTileGrid_1 = this.tileGrid;
        var sourceExtent = sourceTileGrid_1.getExtent();
        if (sourceExtent) {
          getIntersection(extent2, sourceExtent, extent2);
        }
        var sourceZ = sourceTileGrid_1.getZForResolution(resolution, this.zDirection);
        sourceTileGrid_1.forEachTileCoord(extent2, sourceZ, function(sourceTileCoord) {
          var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
          var sourceTile = _this.sourceTileCache.containsKey(tileUrl) ? _this.sourceTileCache.get(tileUrl) : new _this.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);
          tile.sourceTiles.push(sourceTile);
          var sourceTileState = sourceTile.getState();
          if (sourceTileState < TileState.LOADED) {
            var listenChange_1 = function(event) {
              _this.handleTileChange(event);
              var state = sourceTile.getState();
              if (state === TileState.LOADED || state === TileState.ERROR) {
                var sourceTileKey = sourceTile.getKey();
                if (sourceTileKey in tile.errorTileKeys) {
                  if (sourceTile.getState() === TileState.LOADED) {
                    delete tile.errorTileKeys[sourceTileKey];
                  }
                } else {
                  tile.loadingSourceTiles--;
                }
                if (state === TileState.ERROR) {
                  tile.errorTileKeys[sourceTileKey] = true;
                } else {
                  sourceTile.removeEventListener(EventType.CHANGE, listenChange_1);
                }
                if (tile.loadingSourceTiles === 0) {
                  tile.setState(isEmpty$1(tile.errorTileKeys) ? TileState.LOADED : TileState.ERROR);
                }
              }
            };
            sourceTile.addEventListener(EventType.CHANGE, listenChange_1);
            tile.loadingSourceTiles++;
          }
          if (sourceTileState === TileState.IDLE) {
            sourceTile.extent = sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);
            sourceTile.projection = projection;
            sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);
            _this.sourceTileCache.set(tileUrl, sourceTile);
            sourceTile.load();
          }
        });
        if (!tile.loadingSourceTiles) {
          tile.setState(tile.sourceTiles.some(function(sourceTile) {
            return sourceTile.getState() === TileState.ERROR;
          }) ? TileState.ERROR : TileState.LOADED);
        }
      }
      return tile.sourceTiles;
    };
    VectorTile2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
      var coordKey = getKeyZXY(z, x, y);
      var key = this.getKey();
      var tile;
      if (this.tileCache.containsKey(coordKey)) {
        tile = this.tileCache.get(coordKey);
        if (tile.key === key) {
          return tile;
        }
      }
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var sourceExtent = this.getTileGrid().getExtent();
      var tileGrid = this.getTileGridForProjection(projection);
      if (urlTileCoord && sourceExtent) {
        var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);
        buffer$1(tileExtent, -tileGrid.getResolution(z), tileExtent);
        if (!intersects$1(sourceExtent, tileExtent)) {
          urlTileCoord = null;
        }
      }
      var empty = true;
      if (urlTileCoord !== null) {
        var sourceTileGrid = this.tileGrid;
        var resolution = tileGrid.getResolution(z);
        var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);
        var extent2 = tileGrid.getTileCoordExtent(urlTileCoord);
        buffer$1(extent2, -resolution, extent2);
        sourceTileGrid.forEachTileCoord(extent2, sourceZ, function(sourceTileCoord) {
          empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
        }.bind(this));
      }
      var newTile = new VectorRenderTile$1(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));
      newTile.key = key;
      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        this.tileCache.replace(coordKey, newTile);
      } else {
        this.tileCache.set(coordKey, newTile);
      }
      return newTile;
    };
    VectorTile2.prototype.getTileGridForProjection = function(projection) {
      var code = projection.getCode();
      var tileGrid = this.tileGrids_[code];
      if (!tileGrid) {
        var sourceTileGrid_2 = this.tileGrid;
        var resolutions = sourceTileGrid_2.getResolutions().slice();
        var origins = resolutions.map(function(resolution, z2) {
          return sourceTileGrid_2.getOrigin(z2);
        });
        var tileSizes = resolutions.map(function(resolution, z2) {
          return sourceTileGrid_2.getTileSize(z2);
        });
        var length_1 = DEFAULT_MAX_ZOOM + 1;
        for (var z = resolutions.length; z < length_1; ++z) {
          resolutions.push(resolutions[z - 1] / 2);
          origins.push(origins[z - 1]);
          tileSizes.push(tileSizes[z - 1]);
        }
        tileGrid = new TileGrid$1({
          extent: sourceTileGrid_2.getExtent(),
          origins,
          resolutions,
          tileSizes
        });
        this.tileGrids_[code] = tileGrid;
      }
      return tileGrid;
    };
    VectorTile2.prototype.getTilePixelRatio = function(pixelRatio) {
      return pixelRatio;
    };
    VectorTile2.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
      var tileGrid = this.getTileGridForProjection(projection);
      var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
      return [
        Math.round(tileSize[0] * pixelRatio),
        Math.round(tileSize[1] * pixelRatio)
      ];
    };
    VectorTile2.prototype.updateCacheSize = function(tileCount, projection) {
      _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);
      this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;
    };
    return VectorTile2;
  }(UrlTile$1)
);
function defaultLoadFunction(tile, url) {
  tile.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(extent2, resolution, projection) {
      loadFeaturesXhr(url, tile.getFormat(), extent2, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));
    }
  );
}
const VectorTile$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: VectorTile,
  defaultLoadFunction
}, Symbol.toStringTag, { value: "Module" }));
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(VectorTile$1);
var __extends$b = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var XYZ = (
  /** @class */
  function(_super) {
    __extends$b(XYZ2, _super);
    function XYZ2(opt_options) {
      var _this = this;
      var options = opt_options || {};
      var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
      if (options.interpolate !== void 0) {
        interpolate = options.interpolate;
      }
      var projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
      var tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
        extent: extentFromProjection(projection),
        maxResolution: options.maxResolution,
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });
      _this = _super.call(this, {
        attributions: options.attributions,
        cacheSize: options.cacheSize,
        crossOrigin: options.crossOrigin,
        interpolate,
        opaque: options.opaque,
        projection,
        reprojectionErrorThreshold: options.reprojectionErrorThreshold,
        tileGrid,
        tileLoadFunction: options.tileLoadFunction,
        tilePixelRatio: options.tilePixelRatio,
        tileUrlFunction: options.tileUrlFunction,
        url: options.url,
        urls: options.urls,
        wrapX: options.wrapX !== void 0 ? options.wrapX : true,
        transition: options.transition,
        attributionsCollapsible: options.attributionsCollapsible,
        zDirection: options.zDirection
      }) || this;
      _this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
      return _this;
    }
    XYZ2.prototype.getGutter = function() {
      return this.gutter_;
    };
    return XYZ2;
  }(TileImage$1)
);
const XYZ$1 = XYZ;
var __extends$a = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
(function(_super) {
  __extends$a(OSM, _super);
  function OSM(opt_options) {
    var options = opt_options || {};
    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
    if (options.interpolate !== void 0) {
      interpolate = options.interpolate;
    }
    var attributions;
    if (options.attributions !== void 0) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    var url = options.url !== void 0 ? options.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png";
    return _super.call(this, {
      attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin,
      interpolate,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
      opaque: options.opaque !== void 0 ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    }) || this;
  }
  return OSM;
})(XYZ$1);
var __extends$9 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ATTRIBUTIONS = [
  'Map tiles by <a href="https://stamen.com/" target="_blank">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC BY 3.0</a>.',
  ATTRIBUTION
];
var LayerConfig = {
  "terrain": {
    extension: "jpg",
    opaque: true
  },
  "terrain-background": {
    extension: "jpg",
    opaque: true
  },
  "terrain-labels": {
    extension: "png",
    opaque: false
  },
  "terrain-lines": {
    extension: "png",
    opaque: false
  },
  "toner-background": {
    extension: "png",
    opaque: true
  },
  "toner": {
    extension: "png",
    opaque: true
  },
  "toner-hybrid": {
    extension: "png",
    opaque: false
  },
  "toner-labels": {
    extension: "png",
    opaque: false
  },
  "toner-lines": {
    extension: "png",
    opaque: false
  },
  "toner-lite": {
    extension: "png",
    opaque: true
  },
  "watercolor": {
    extension: "jpg",
    opaque: true
  }
};
var ProviderConfig = {
  "terrain": {
    minZoom: 0,
    maxZoom: 18
  },
  "toner": {
    minZoom: 0,
    maxZoom: 20
  },
  "watercolor": {
    minZoom: 0,
    maxZoom: 18
  }
};
var Stamen = (
  /** @class */
  function(_super) {
    __extends$9(Stamen2, _super);
    function Stamen2(options) {
      var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
      if (options.interpolate !== void 0) {
        interpolate = options.interpolate;
      }
      var i = options.layer.indexOf("-");
      var provider = i == -1 ? options.layer : options.layer.slice(0, i);
      var providerConfig = ProviderConfig[provider];
      var layerConfig = LayerConfig[options.layer];
      var url = options.url !== void 0 ? options.url : "https://stamen-tiles-{a-d}.a.ssl.fastly.net/" + options.layer + "/{z}/{x}/{y}." + layerConfig.extension;
      return _super.call(this, {
        attributions: ATTRIBUTIONS,
        cacheSize: options.cacheSize,
        crossOrigin: "anonymous",
        interpolate,
        maxZoom: options.maxZoom != void 0 ? options.maxZoom : providerConfig.maxZoom,
        minZoom: options.minZoom != void 0 ? options.minZoom : providerConfig.minZoom,
        opaque: layerConfig.opaque,
        reprojectionErrorThreshold: options.reprojectionErrorThreshold,
        tileLoadFunction: options.tileLoadFunction,
        transition: options.transition,
        url,
        wrapX: options.wrapX,
        zDirection: options.zDirection
      }) || this;
    }
    return Stamen2;
  }(XYZ$1)
);
const Stamen$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Stamen
}, Symbol.toStringTag, { value: "Module" }));
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(Stamen$1);
var LayerUpdateStrategy = {};
var hasRequiredLayerUpdateStrategy;
function requireLayerUpdateStrategy() {
  if (hasRequiredLayerUpdateStrategy)
    return LayerUpdateStrategy;
  hasRequiredLayerUpdateStrategy = 1;
  Object.defineProperty(LayerUpdateStrategy, "__esModule", {
    value: true
  });
  LayerUpdateStrategy.STRATEGY_PROGRESSIVE = LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC = LayerUpdateStrategy.STRATEGY_GROUP = LayerUpdateStrategy.STRATEGY_DICHOTOMY = void 0;
  var STRATEGY_MIN_NETWORK_TRAFFIC = 0;
  LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC = STRATEGY_MIN_NETWORK_TRAFFIC;
  var STRATEGY_GROUP = 1;
  LayerUpdateStrategy.STRATEGY_GROUP = STRATEGY_GROUP;
  var STRATEGY_PROGRESSIVE = 2;
  LayerUpdateStrategy.STRATEGY_PROGRESSIVE = STRATEGY_PROGRESSIVE;
  var STRATEGY_DICHOTOMY = 3;
  LayerUpdateStrategy.STRATEGY_DICHOTOMY = STRATEGY_DICHOTOMY;
  return LayerUpdateStrategy;
}
var CogSource = {};
var hasRequiredCogSource;
function requireCogSource() {
  if (hasRequiredCogSource)
    return CogSource;
  hasRequiredCogSource = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(CogSource, "__esModule", {
    value: true
  });
  CogSource.default = void 0;
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var CogSource$1 = /* @__PURE__ */ (0, _createClass22.default)(
    /**
     * Creates a COG source.
     *
     * @param {object} [options={}] options
     * @param {string} options.url the url of the cog image
     */
    function CogSource2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, _classCallCheck22.default)(this, CogSource2);
      this.url = options.url;
    }
  );
  var _default2 = CogSource$1;
  CogSource.default = _default2;
  return CogSource;
}
var CustomTiledImageSource = {};
var Fetcher = {};
var hasRequiredFetcher;
function requireFetcher() {
  if (hasRequiredFetcher)
    return Fetcher;
  hasRequiredFetcher = 1;
  Object.defineProperty(Fetcher, "__esModule", {
    value: true
  });
  Fetcher.default = void 0;
  var _three2 = require$$8$1;
  var textureLoader = new _three2.TextureLoader();
  function checkResponse(response) {
    if (!response.ok) {
      var error = new Error("Error loading ".concat(response.url, ": status ").concat(response.status));
      error.response = response;
      throw error;
    }
  }
  var _default2 = {
    /**
     * Wrapper over `fetch` to get some text
     *
     * @api
     * @param {string} url the URL to fetch
     * @param {object} options fetch options (passed directly to fetch)
     * @returns {Promise} the promise containing the text
     */
    text: function text(url) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return fetch(url, options).then(function(response) {
        checkResponse(response);
        return response.text();
      });
    },
    /**
     * Wrapper over `fetch` to get some JSON
     *
     * @api
     * @param {string} url the URL to fetch
     * @param {object} options fetch options (passed directly to fetch)
     * @returns {Promise} the promise containing the JSON
     */
    json: function json(url) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return fetch(url, options).then(function(response) {
        checkResponse(response);
        return response.json();
      });
    },
    /**
     * Wrapper over `fetch` to get some XML.
     *
     * @api
     * @param {string} url the URL to fetch
     * @param {object} options fetch options (passed directly to fetch)
     * @returns {Promise} the promise containing the XML
     */
    xml: function xml(url) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return fetch(url, options).then(function(response) {
        checkResponse(response);
        return response.text();
      }).then(function(text) {
        return new window.DOMParser().parseFromString(text, "text/xml");
      });
    },
    /**
     * Wrapper around TextureLoader.
     *
     * @api
     * @param {string} url the URL to fetch
     * @param {object} options options to pass to TextureLoader. Note that
     * THREE.js docs mention withCredentials, but it is not actually used in TextureLoader.js.
     * @param {string} options.crossOrigin passed directly to html elements supporting it
     * @returns {Promise} the promiose containing the texture.
     */
    texture: function texture(url) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var res;
      var rej;
      textureLoader.crossOrigin = options.crossOrigin;
      var promise = new Promise(function(resolve, reject) {
        res = resolve;
        rej = reject;
      });
      textureLoader.load(url, res, function() {
      }, rej);
      return promise;
    },
    /**
     * Wrapper over `fetch` to get some `ArrayBuffer`
     *
     * @param {string} url the URL to fetch
     * @param {object} options fetch options (passed directly to fetch)
     * @returns {Promise} the promise containing the ArrayBuffer
     */
    arrayBuffer: function arrayBuffer(url) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return fetch(url, options).then(function(response) {
        checkResponse(response);
        return response.arrayBuffer();
      });
    }
  };
  Fetcher.default = _default2;
  return Fetcher;
}
var hasRequiredCustomTiledImageSource;
function requireCustomTiledImageSource() {
  if (hasRequiredCustomTiledImageSource)
    return CustomTiledImageSource;
  hasRequiredCustomTiledImageSource = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(CustomTiledImageSource, "__esModule", {
    value: true
  });
  CustomTiledImageSource.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _Fetcher = _interopRequireDefault2(requireFetcher());
  var CustomTiledImageSource$1 = /* @__PURE__ */ function() {
    function CustomTiledImageSource2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, _classCallCheck22.default)(this, CustomTiledImageSource2);
      this.url = new URL(options.url, window.location);
      this.networkOptions = options.networkOptions;
    }
    (0, _createClass22.default)(CustomTiledImageSource2, [{
      key: "buildUrl",
      value: function buildUrl(image) {
        return this.url.href.substr(0, this.url.href.lastIndexOf("/") + 1) + image;
      }
    }, {
      key: "fetchMetadata",
      value: function fetchMetadata() {
        return _Fetcher.default.json(this.url.href, this.networkOptions);
      }
    }]);
    return CustomTiledImageSource2;
  }();
  var _default2 = CustomTiledImageSource$1;
  CustomTiledImageSource.default = _default2;
  return CustomTiledImageSource;
}
var hasRequiredLayer;
function requireLayer() {
  if (hasRequiredLayer)
    return Layer;
  hasRequiredLayer = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Layer, "__esModule", {
    value: true
  });
  Layer.defineLayerProperty = Layer.default = Layer.MAX_RETRY = Layer.ImageryLayers = void 0;
  Layer.nodeCommandQueuePriorityFunction = nodeCommandQueuePriorityFunction;
  Layer.refinementCommandCancellationFn = refinementCommandCancellationFn;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _assertThisInitialized22 = _interopRequireDefault2(requireAssertThisInitialized());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  var _TileWMS = _interopRequireDefault2(require$$8);
  var _Vector = _interopRequireDefault2(require$$9);
  var _VectorTile = _interopRequireDefault2(require$$10);
  var _Stamen = _interopRequireDefault2(require$$11);
  var _LayerUpdateStrategy2 = requireLayerUpdateStrategy();
  var _CogSource = _interopRequireDefault2(requireCogSource());
  var _CustomTiledImageSource = _interopRequireDefault2(requireCustomTiledImageSource());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var defineLayerProperty = function(layer, propertyName, defaultValue, onChange) {
    var existing = Object.getOwnPropertyDescriptor(layer, propertyName);
    if (!existing || !existing.set) {
      var property = layer[propertyName] === void 0 ? defaultValue : layer[propertyName];
      Object.defineProperty(layer, propertyName, {
        get: function get2() {
          return property;
        },
        set: function set2(newValue) {
          if (property !== newValue) {
            var event = {
              type: "".concat(propertyName, "-property-changed"),
              previous: {},
              new: {}
            };
            event.previous[propertyName] = property;
            event.new[propertyName] = newValue;
            property = newValue;
            if (onChange) {
              onChange(layer, propertyName);
            }
            layer.dispatchEvent(event);
          }
        }
      });
    }
  };
  Layer.defineLayerProperty = defineLayerProperty;
  function nodeCommandQueuePriorityFunction(node) {
    var dim = node.extent.dimensions();
    return dim.x * dim.y;
  }
  function refinementCommandCancellationFn(cmd) {
    if (!cmd.requester.parent || !cmd.requester.material) {
      return true;
    }
    if (cmd.force) {
      return false;
    }
    return !cmd.requester.material.visible;
  }
  var MAX_RETRY = 4;
  Layer.MAX_RETRY = MAX_RETRY;
  var Layer$1 = /* @__PURE__ */ function(_EventDispatcher) {
    (0, _inherits22.default)(Layer2, _EventDispatcher);
    var _super = _createSuper2(Layer2);
    function Layer2(id, options) {
      var _this;
      (0, _classCallCheck22.default)(this, Layer2);
      _this = _super.call(this);
      Object.defineProperty((0, _assertThisInitialized22.default)(_this), "id", {
        value: id,
        writable: false
      });
      _this.standalone = options.standalone ? options.standalone : false;
      if (!_this.standalone) {
        _this.source = options.source;
        switch (_this.source.constructor) {
          case _TileWMS.default:
          case _Stamen.default:
            _this.protocol = "oltile";
            break;
          case _Vector.default:
            _this.protocol = "olvector";
            break;
          case _VectorTile.default:
            _this.protocol = "olvectortile";
            break;
          case _CogSource.default:
            _this.protocol = "cog";
            break;
          case _CustomTiledImageSource.default:
            _this.protocol = "customtiledimage";
            break;
          default:
            throw Error("Unsupported OpenLayers source");
        }
      }
      _this.extent = options.extent;
      if (options.updateStrategy) {
        _this.updateStrategy = options.updateStrategy;
      } else {
        _this.updateStrategy = {
          type: _LayerUpdateStrategy2.STRATEGY_MIN_NETWORK_TRAFFIC
        };
      }
      _this.projection = options.projection;
      _this.backgroundColor = options.backgroundColor;
      return _this;
    }
    (0, _createClass22.default)(Layer2, [{
      key: "_preprocessLayer",
      value: function _preprocessLayer(map, instance) {
        var _this2 = this;
        if (this.standalone) {
          this.whenReady = Promise.resolve().then(function() {
            _this2.ready = true;
            return _this2;
          });
          return this;
        }
        this.provider = instance.mainLoop.scheduler.getProtocolProvider(this.protocol);
        if (this.provider) {
          if (this.provider.tileInsideLimit) {
            this.tileInsideLimit = this.provider.tileInsideLimit.bind(this.provider);
          }
          if (this.provider.getPossibleTextureImprovements) {
            this.getPossibleTextureImprovements = this.provider.getPossibleTextureImprovements.bind(this.provider);
          }
          if (this.provider.tileTextureCount) {
            this.tileTextureCount = this.provider.tileTextureCount.bind(this.provider);
          }
        }
        if (!this.whenReady) {
          var providerPreprocessing = Promise.resolve();
          if (this.provider && this.provider.preprocessDataLayer) {
            providerPreprocessing = this.provider.preprocessDataLayer(this);
            if (!(providerPreprocessing && providerPreprocessing.then)) {
              providerPreprocessing = Promise.resolve();
            }
          }
          this.whenReady = providerPreprocessing.then(function() {
            _this2.ready = true;
            return _this2;
          });
        }
        return this;
      }
      /**
       * Performs the update of the layer. This method must be overwritten
       * for the layer to be displayed and updated.
       *
       * @param {module:Core/Context~Context} context the context
       * @param {module:Core/TileMesh~TileMesh} node the node to update
       * @param {module:entities/Map~Map} parent the map where the layers have been added
       * @param {boolean} [initOnly = false] if true, the update is stopped before the update command
       * there is only a check that the layer state is defined in the node.
       * @returns {null|Promise} null if the update is not done,
       * else, that succeeds if the update is made. Currently, only null is returned
       * since the method is empty.
       */
      // eslint-disable-next-line
    }, {
      key: "update",
      value: function update() {
        return null;
      }
      /**
       * Cleans the layer from a map
       *
       * @param {module:entities/Map~Map} object The map where the layer is added
       * @api
       */
      // eslint-disable-next-line
    }, {
      key: "clean",
      value: function clean() {
      }
      // TODO
    }]);
    return Layer2;
  }(_three2.EventDispatcher);
  var ImageryLayers = /* @__PURE__ */ function() {
    function ImageryLayers2() {
      (0, _classCallCheck22.default)(this, ImageryLayers2);
    }
    (0, _createClass22.default)(ImageryLayers2, null, [{
      key: "moveLayerToIndex",
      value: (
        /**
         * Moves the layer to the new index. The ordering of the other layers don't change.
         * After the modification :
         * - the minimum sequence will always be `0`
         * - the maximum sequence will always be `layers.length - 1`
         *
         * @api
         * @param {Layer} layer the layer to move
         * @param {number} newIndex the new index
         * @param {*} imageryLayers the collection of imagery layers to update.
         */
        function moveLayerToIndex(layer, newIndex, imageryLayers) {
          newIndex = Math.min(newIndex, imageryLayers.length - 1);
          newIndex = Math.max(newIndex, 0);
          var oldIndex = layer.sequence;
          var _iterator = _createForOfIteratorHelper2(imageryLayers), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var imagery = _step.value;
              if (imagery.id === layer.id) {
                imagery.sequence = newIndex;
              } else if (imagery.sequence > oldIndex && imagery.sequence <= newIndex) {
                imagery.sequence--;
              } else if (imagery.sequence >= newIndex && imagery.sequence < oldIndex) {
                imagery.sequence++;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      )
      /**
       * Moves the layer one step down.
       * If the layer is already at the bottom, nothing happens.
       *
       * @api
       * @param {Layer} layer the layer to move
       * @param {*} imageryLayers the collection of imagery layers to update.
       */
    }, {
      key: "moveLayerDown",
      value: function moveLayerDown(layer, imageryLayers) {
        if (layer.sequence > 0) {
          this.moveLayerToIndex(layer, layer.sequence - 1, imageryLayers);
        }
      }
      /**
       * Moves the layer one step up.
       * If the layer is already at the top, nothing happens.
       *
       * @api
       * @param {Layer} layer the layer to move
       * @param {*} imageryLayers the collection of imagery layers to update.
       */
    }, {
      key: "moveLayerUp",
      value: function moveLayerUp(layer, imageryLayers) {
        var m = imageryLayers.length - 1;
        if (layer.sequence < m) {
          this.moveLayerToIndex(layer, layer.sequence + 1, imageryLayers);
        }
      }
      /**
       * Gets the layers ordered by sequence (order in the hierarchy).
       *
       * @api
       * @param {Layer[]} imageryLayers the collection of imagery layers.
       * @returns {Array<Layer>} the ordered layers IDs
       */
    }, {
      key: "getColorLayersIdOrderedBySequence",
      value: function getColorLayersIdOrderedBySequence(imageryLayers) {
        var copy = Array.from(imageryLayers);
        copy.sort(function(a, b) {
          return a.sequence - b.sequence;
        });
        return copy.map(function(l) {
          return l.id;
        });
      }
    }]);
    return ImageryLayers2;
  }();
  Layer.ImageryLayers = ImageryLayers;
  var _default2 = Layer$1;
  Layer.default = _default2;
  return Layer;
}
var Entity3D = {};
var ColorLayer = {};
var LayerUpdateState = {};
var hasRequiredLayerUpdateState;
function requireLayerUpdateState() {
  if (hasRequiredLayerUpdateState)
    return LayerUpdateState;
  hasRequiredLayerUpdateState = 1;
  Object.defineProperty(LayerUpdateState, "__esModule", {
    value: true
  });
  LayerUpdateState.default = void 0;
  var UPDATE_STATE = {
    IDLE: 0,
    PENDING: 1,
    ERROR: 2,
    DEFINITIVE_ERROR: 3,
    FINISHED: 4
  };
  var PAUSE_BETWEEN_ERRORS = [1, 3, 7, 60];
  function LayerUpdateState$1() {
    this.state = UPDATE_STATE.IDLE;
    this.lastErrorTimestamp = 0;
    this.errorCount = 0;
  }
  LayerUpdateState$1.prototype.canTryUpdate = function(timestamp) {
    switch (this.state) {
      case UPDATE_STATE.IDLE: {
        return true;
      }
      case UPDATE_STATE.DEFINITIVE_ERROR:
      case UPDATE_STATE.PENDING:
      case UPDATE_STATE.FINISHED: {
        return false;
      }
      case UPDATE_STATE.ERROR:
      default: {
        var errorDuration = this.secondsUntilNextTry() * 1e3;
        return errorDuration <= timestamp - this.lastErrorTimestamp;
      }
    }
  };
  LayerUpdateState$1.prototype.secondsUntilNextTry = function() {
    if (this.state !== UPDATE_STATE.ERROR) {
      return 0;
    }
    var idx = Math.max(0, Math.min(this.errorCount, PAUSE_BETWEEN_ERRORS.length) - 1);
    return PAUSE_BETWEEN_ERRORS[idx];
  };
  LayerUpdateState$1.prototype.newTry = function() {
    this.state = UPDATE_STATE.PENDING;
  };
  LayerUpdateState$1.prototype.success = function() {
    this.failureParams = void 0;
    this.lastErrorTimestamp = 0;
    this.state = UPDATE_STATE.IDLE;
  };
  LayerUpdateState$1.prototype.noMoreUpdatePossible = function() {
    this.failureParams = void 0;
    this.state = UPDATE_STATE.FINISHED;
  };
  LayerUpdateState$1.prototype.failure = function(timestamp, definitive, failureParams) {
    this.failureParams = failureParams;
    this.lastErrorTimestamp = timestamp;
    this.state = definitive ? UPDATE_STATE.DEFINITIVE_ERROR : UPDATE_STATE.ERROR;
    this.errorCount++;
  };
  LayerUpdateState$1.prototype.inError = function() {
    return this.state === UPDATE_STATE.DEFINITIVE_ERROR || this.state === UPDATE_STATE.ERROR;
  };
  var _default2 = LayerUpdateState$1;
  LayerUpdateState.default = _default2;
  return LayerUpdateState;
}
var CancelledCommandException = {};
var hasRequiredCancelledCommandException;
function requireCancelledCommandException() {
  if (hasRequiredCancelledCommandException)
    return CancelledCommandException;
  hasRequiredCancelledCommandException = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(CancelledCommandException, "__esModule", {
    value: true
  });
  CancelledCommandException.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var CancelledCommandException$1 = /* @__PURE__ */ function() {
    function CancelledCommandException2(command) {
      (0, _classCallCheck22.default)(this, CancelledCommandException2);
      this.command = command;
    }
    (0, _createClass22.default)(CancelledCommandException2, [{
      key: "toString",
      value: function toString2() {
        return "Cancelled command ".concat(this.command.requester.id, "/").concat(this.command.layer.id);
      }
    }]);
    return CancelledCommandException2;
  }();
  var _default2 = CancelledCommandException$1;
  CancelledCommandException.default = _default2;
  return CancelledCommandException;
}
var hasRequiredColorLayer;
function requireColorLayer() {
  if (hasRequiredColorLayer)
    return ColorLayer;
  hasRequiredColorLayer = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  var _typeof2 = _typeofExports;
  Object.defineProperty(ColorLayer, "__esModule", {
    value: true
  });
  ColorLayer.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _assertThisInitialized22 = _interopRequireDefault2(requireAssertThisInitialized());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _LayerUpdateState = _interopRequireDefault2(requireLayerUpdateState());
  var _CancelledCommandException = _interopRequireDefault2(requireCancelledCommandException());
  var _Layer2 = _interopRequireWildcard2(requireLayer());
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache2(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var ColorLayer$1 = /* @__PURE__ */ function(_Layer3) {
    (0, _inherits22.default)(ColorLayer2, _Layer3);
    var _super = _createSuper2(ColorLayer2);
    function ColorLayer2(id) {
      var _this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _classCallCheck22.default)(this, ColorLayer2);
      _this = _super.call(this, id, options);
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "frozen", false);
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "visible", true);
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "opacity", 1);
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "sequence", 0);
      return _this;
    }
    (0, _createClass22.default)(ColorLayer2, [{
      key: "clean",
      value: function clean(object) {
        var _this2 = this;
        object.object3d.traverse(function(o) {
          if (o.layer === object) {
            delete o.layerUpdateState[_this2.id];
            if (o.material && o.material.indexOfColorLayer(_this2) !== -1) {
              o.material.removeLayer(_this2);
            }
          }
        });
      }
    }, {
      key: "initColorTexturesFromParent",
      value: function initColorTexturesFromParent(context, node, parent) {
        if (!parent.material || !parent.material.getColorTexture) {
          return false;
        }
        var extent2 = node.getExtentForLayer(this);
        while (parent && parent.material && parent.material.uniforms.colorTexture && parent.material.uniforms.colorTexture.value !== parent.material.texturesInfo.color.atlasTexture) {
          parent = parent.parent;
        }
        if (!parent || !parent.material) {
          return false;
        }
        var texture = parent.material.getColorTexture(this);
        if (!texture) {
          return false;
        }
        if (!texture || !texture.extent) {
          return false;
        }
        node.material.uniforms.colorTexture.value = parent.material.uniforms.colorTexture.value;
        node.material.setColorTextures(this, {
          texture,
          pitch: extent2.offsetToParent(texture.extent)
        }, true, context.instance);
        return true;
      }
      /**
       * Performs the update of the layer.
       *
       * @param {module:Core/Context~Context} context the context
       * @param {module:Core/TileMesh~TileMesh} node the node to update
       * @param {module:entities/Map~Map} parent the map where the layers have been added
       * @param {boolean} [initOnly = false] if true, the update is stopped before the update command
       * there is only a check that the layer state is defined in the node.
       * @returns {null|Promise} null if the update is not done,
       * else, that succeeds if the update is made.
       */
    }, {
      key: "update",
      value: function update(context, node, parent) {
        var _this3 = this;
        var initOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        var material = node.material;
        if (!node.parent || !material) {
          return null;
        }
        if (node.layerUpdateState[this.id] === void 0) {
          node.layerUpdateState[this.id] = new _LayerUpdateState.default();
          if (!this.tileInsideLimit(node, this)) {
            if (!(!this.noTextureParentOutsideLimit && parent && parent.material && parent.material.getColorTexture(this))) {
              node.layerUpdateState[this.id].noMoreUpdatePossible();
              return null;
            }
          }
          material.pushLayer(this, node.getExtentForLayer(this));
          if (parent && this.initColorTexturesFromParent(context, node, parent, this)) {
            context.instance.notifyChange(node, false);
            return null;
          }
        }
        if (!node.material.visible || initOnly) {
          return null;
        }
        material.setLayerVisibility(this, this.visible);
        material.setLayerOpacity(this, this.opacity);
        var ts = Date.now();
        if (this.frozen || !this.visible || !node.layerUpdateState[this.id].canTryUpdate(ts)) {
          return null;
        }
        var nextDownloads = this.getPossibleTextureImprovements(this, node.getExtentForLayer(this), node.material.getColorTexture(this), node.layerUpdateState[this.id].failureParams);
        if (nextDownloads === void 0) {
          node.layerUpdateState[this.id].noMoreUpdatePossible();
          return null;
        }
        if (nextDownloads === null || nextDownloads === false) {
          return null;
        }
        node.layerUpdateState[this.id].newTry();
        var command = {
          /* mandatory */
          view: context.instance,
          layer: this,
          requester: node,
          priority: (0, _Layer2.nodeCommandQueuePriorityFunction)(node),
          earlyDropFunction: _Layer2.refinementCommandCancellationFn,
          toDownload: nextDownloads
        };
        return context.scheduler.execute(command).then(function(result) {
          if (node.material === null) {
            return null;
          }
          return node.material.setColorTextures(_this3, result, false, context.instance).then(function() {
            node.layerUpdateState[_this3.id].success();
          });
        }, function(err) {
          if (err instanceof _CancelledCommandException.default) {
            node.layerUpdateState[_this3.id].success();
          } else {
            console.warn("Imagery texture update error for", node, err);
            var definitiveError = node.layerUpdateState[_this3.id].errorCount > _Layer2.MAX_RETRY;
            node.layerUpdateState[_this3.id].failure(Date.now(), definitiveError, err);
            if (!definitiveError) {
              window.setTimeout(function() {
                context.instance.notifyChange(node, false);
              }, node.layerUpdateState[_this3.id].secondsUntilNextTry() * 1e3);
            }
          }
        });
      }
    }]);
    return ColorLayer2;
  }(_Layer2.default);
  var _default2 = ColorLayer$1;
  ColorLayer.default = _default2;
  return ColorLayer;
}
var Picking = {};
var TileMesh = {};
var getExports = {};
var get$1 = {
  get exports() {
    return getExports;
  },
  set exports(v) {
    getExports = v;
  }
};
var superPropBaseExports = {};
var superPropBase = {
  get exports() {
    return superPropBaseExports;
  },
  set exports(v) {
    superPropBaseExports = v;
  }
};
var hasRequiredSuperPropBase;
function requireSuperPropBase() {
  if (hasRequiredSuperPropBase)
    return superPropBaseExports;
  hasRequiredSuperPropBase = 1;
  (function(module) {
    var getPrototypeOf2 = requireGetPrototypeOf();
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = getPrototypeOf2(object);
        if (object === null)
          break;
      }
      return object;
    }
    module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(superPropBase);
  return superPropBaseExports;
}
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet)
    return getExports;
  hasRequiredGet = 1;
  (function(module) {
    var superPropBase2 = requireSuperPropBase();
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _get = function _get2(target, property, receiver) {
          var base2 = superPropBase2(target, property);
          if (!base2)
            return;
          var desc = Object.getOwnPropertyDescriptor(base2, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }
      return _get.apply(this, arguments);
    }
    module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(get$1);
  return getExports;
}
var RendererConstant = {};
var hasRequiredRendererConstant;
function requireRendererConstant() {
  if (hasRequiredRendererConstant)
    return RendererConstant;
  hasRequiredRendererConstant = 1;
  Object.defineProperty(RendererConstant, "__esModule", {
    value: true
  });
  RendererConstant.default = void 0;
  var _default2 = {
    // final color
    FINAL: 0,
    // depth buffer
    DEPTH: 1,
    // id object
    ID: 2,
    // pack uv of current tile
    UV: 3
  };
  RendererConstant.default = _default2;
  return RendererConstant;
}
var OGCWebServiceHelper = {};
var Cache = {};
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache)
    return Cache;
  hasRequiredCache = 1;
  Object.defineProperty(Cache, "__esModule", {
    value: true
  });
  Cache.default = void 0;
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var data = /* @__PURE__ */ new Map();
  var stats = /* @__PURE__ */ new Map();
  var Cache$12 = {
    /**
     * Cache policies for flushing. Those policies can be used when something is
     * [set]{@link Cache.set} into the Cache, as the lifetime property.
     *
     * @name module:Cache
     * @typedef {object} module:Cache.POLICIES
     * @property {number} INFINITE - The entry is never flushed, except when the
     * <code>all</code> flag is set to <code>true</code> when calling {@link
     * Cache.flush}.
     * @property {number} TEXTURE - Shortcut for texture resources. Time is 15 minutes.
     * @property {number} ELEVATION - Shortcut for elevation resources. Time is 15
     * minutes.
     */
    POLICIES: {
      INFINITE: Infinity,
      TEXTURE: 9e5,
      ELEVATION: 9e5
    },
    /**
     * Returns the entry related to the specified key from the cache. The last
     * time used property of the entry is updated to extend the longevity of the
     * entry.
     *
     * @name module:Cache.get
     * @param {string} key the entry to get
     * @returns {object} the queried entry, or undefined if not found
     */
    get: function get2(key) {
      var entry = data.get(key);
      if (!stats.has(key)) {
        stats.set(key, {
          hit: 0,
          miss: 0
        });
      }
      var stat = stats.get(key);
      if (entry) {
        stat.hit++;
        entry.lastTimeUsed = Date.now();
        return entry.value;
      }
      stat.miss++;
      return void 0;
    },
    /**
     * Adds or updates an entry with a specified key. A lifetime can be added,
     * by specifying a numerical value or using the {@link Cache.POLICIES}
     * values. By default an entry has an infinite lifetime.
     *
     * @name module:Cache.set
     * @param {string} key the entry key to query
     * @param {object} value the entry value
     * @param {number} [lifetime] the lifetime of this entry, in milliseconds
     * @returns {object} the added value
     */
    set: function set2(key, value) {
      var lifetime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
      var entry = {
        value,
        lastTimeUsed: Date.now(),
        lifetime
      };
      data.set(key, entry);
      return value;
    },
    deletePrefix: function deletePrefix(prefix) {
      var _iterator = _createForOfIteratorHelper2(data.keys()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var key = _step.value;
          if (key.startsWith && key.startsWith(prefix)) {
            data.delete(key);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    /**
     * Deletes the specified entry from the cache.
     *
     * @name module:Cache.delete
     * @param {string} key the entry key
     * @returns {boolean} - Confirmation that the entry has been deleted.
     */
    delete: function _delete(key) {
      return data.delete(key);
    },
    /**
     * Removes all entries of the cache.
     *
     * @name module:Cache.clear
     * @function
     */
    clear: data.clear(),
    /**
     * Flush the cache: entries that have been present for too long since the
     * last time they were used, are removed from the cache. By default, the
     * time is the current time, but the interval can be reduced by doing
     * something like <code>Cache.flush(Date.now() - reductionTime)</code>. If
     * you want to clear the whole cache, use {@link Cache.clear} instead.
     *
     * @name module:Cache.flush
     * @param {number} [time] the timestamp to compare the lifetime of the entries
     * @returns {object} Statistics about the flush: <code>before</code>
     * gives the number of entries before flushing, <code>after</code> the
     * number after flushing, <code>hit</code> the number of total successful
     * hit on resources in the cache, and </code>miss</code> the number of
     * failed hit. The hit and miss are based since the last flush, and are
     * reset on every flush.
     */
    flush: function flush() {
      var time = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();
      var before = data.size;
      data.forEach(function(entry, key) {
        if (entry.lifetime < time - entry.lastTimeUsed) {
          data.delete(key);
        }
      });
      var hit = 0;
      var miss = 0;
      stats.forEach(function(stat) {
        hit += stat.hit;
        miss += stat.miss;
      });
      stats.clear();
      return {
        before,
        after: data.size,
        hit,
        miss
      };
    }
  };
  Object.freeze(Cache$12);
  var _default2 = Cache$12;
  Cache.default = _default2;
  return Cache;
}
var Projection = {};
var Extent = {};
var slicedToArrayExports = {};
var slicedToArray = {
  get exports() {
    return slicedToArrayExports;
  },
  set exports(v) {
    slicedToArrayExports = v;
  }
};
var arrayWithHolesExports = {};
var arrayWithHoles = {
  get exports() {
    return arrayWithHolesExports;
  },
  set exports(v) {
    arrayWithHolesExports = v;
  }
};
var hasRequiredArrayWithHoles;
function requireArrayWithHoles() {
  if (hasRequiredArrayWithHoles)
    return arrayWithHolesExports;
  hasRequiredArrayWithHoles = 1;
  (function(module) {
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(arrayWithHoles);
  return arrayWithHolesExports;
}
var iterableToArrayLimitExports = {};
var iterableToArrayLimit = {
  get exports() {
    return iterableToArrayLimitExports;
  },
  set exports(v) {
    iterableToArrayLimitExports = v;
  }
};
var hasRequiredIterableToArrayLimit;
function requireIterableToArrayLimit() {
  if (hasRequiredIterableToArrayLimit)
    return iterableToArrayLimitExports;
  hasRequiredIterableToArrayLimit = 1;
  (function(module) {
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(iterableToArrayLimit);
  return iterableToArrayLimitExports;
}
var nonIterableRestExports = {};
var nonIterableRest = {
  get exports() {
    return nonIterableRestExports;
  },
  set exports(v) {
    nonIterableRestExports = v;
  }
};
var hasRequiredNonIterableRest;
function requireNonIterableRest() {
  if (hasRequiredNonIterableRest)
    return nonIterableRestExports;
  hasRequiredNonIterableRest = 1;
  (function(module) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(nonIterableRest);
  return nonIterableRestExports;
}
var hasRequiredSlicedToArray;
function requireSlicedToArray() {
  if (hasRequiredSlicedToArray)
    return slicedToArrayExports;
  hasRequiredSlicedToArray = 1;
  (function(module) {
    var arrayWithHoles2 = requireArrayWithHoles();
    var iterableToArrayLimit2 = requireIterableToArrayLimit();
    var unsupportedIterableToArray2 = requireUnsupportedIterableToArray();
    var nonIterableRest2 = requireNonIterableRest();
    function _slicedToArray(arr, i) {
      return arrayWithHoles2(arr) || iterableToArrayLimit2(arr, i) || unsupportedIterableToArray2(arr, i) || nonIterableRest2();
    }
    module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(slicedToArray);
  return slicedToArrayExports;
}
var hasRequiredExtent;
function requireExtent() {
  if (hasRequiredExtent)
    return Extent;
  hasRequiredExtent = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  var _typeof2 = _typeofExports;
  Object.defineProperty(Extent, "__esModule", {
    value: true
  });
  Extent.default = void 0;
  var _construct2 = _interopRequireDefault2(requireConstruct());
  var _toConsumableArray22 = _interopRequireDefault2(requireToConsumableArray());
  var _slicedToArray2 = _interopRequireDefault2(requireSlicedToArray());
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _three2 = require$$8$1;
  var _Coordinates = _interopRequireWildcard2(requireCoordinates());
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache2(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function YToWGS84(y) {
    return _three2.MathUtils.radToDeg(2 * (Math.atan(Math.exp(-(y - 0.5) * Math.PI * 2)) - Math.PI / 4));
  }
  var CARDINAL = {
    WEST: 0,
    EAST: 1,
    SOUTH: 2,
    NORTH: 3
  };
  function _isTiledCRS(crs) {
    return crs.indexOf("WMTS:") === 0 || crs === "TMS";
  }
  var tmpCoords = new _Coordinates.default("EPSG:4326", 0, 0, 0);
  var Extent$1 = /* @__PURE__ */ function() {
    function Extent2(crs) {
      var _this = this;
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }
      (0, _classCallCheck22.default)(this, Extent2);
      this._crs = crs;
      if (_isTiledCRS(crs)) {
        if (values.length === 3) {
          this.zoom = values[0];
          this.row = values[1];
          this.col = values[2];
          if (this.zoom < 0) {
            throw new Error("invlid WTMS values ".concat(values));
          }
        } else {
          throw new Error("Unsupported constructor args '".concat(values, "'"));
        }
      } else if (values.length === 2 && values[0] instanceof _Coordinates.default && values[1] instanceof _Coordinates.default) {
        this._values = new Float64Array(4);
        var _values$0$_values = (0, _slicedToArray2.default)(values[0]._values, 2);
        this._values[CARDINAL.WEST] = _values$0$_values[0];
        this._values[CARDINAL.SOUTH] = _values$0$_values[1];
        var _values$1$_values = (0, _slicedToArray2.default)(values[1]._values, 2);
        this._values[CARDINAL.EAST] = _values$1$_values[0];
        this._values[CARDINAL.NORTH] = _values$1$_values[1];
      } else if (values.length === 1 && values[0].west !== void 0) {
        this._values = new Float64Array(4);
        this._values[CARDINAL.WEST] = values[0].west;
        this._values[CARDINAL.EAST] = values[0].east;
        this._values[CARDINAL.SOUTH] = values[0].south;
        this._values[CARDINAL.NORTH] = values[0].north;
      } else if (values.length === 4) {
        this._values = new Float64Array(4);
        Object.keys(CARDINAL).forEach(function(key) {
          var cardinal = CARDINAL[key];
          _this._values[cardinal] = values[cardinal];
        });
      } else {
        throw new Error("Unsupported constructor args '".concat(values, "'"));
      }
    }
    (0, _createClass22.default)(Extent2, [{
      key: "clone",
      value: function clone2() {
        if (_isTiledCRS(this._crs)) {
          return new Extent2(this._crs, this.zoom, this.row, this.col);
        }
        var result = (0, _construct2.default)(Extent2, [this._crs].concat((0, _toConsumableArray22.default)(this._values)));
        return result;
      }
      /**
       * Converts this extent into another CRS.
       * If `crs` is the same as the current CRS, the original object is returned.
       *
       * @api
       * @param {string} crs the new CRS
       * @returns {Extent} the converted extent.
       */
    }, {
      key: "as",
      value: function as(crs) {
        (0, _Coordinates.assertCrsIsValid)(crs);
        if (_isTiledCRS(this._crs)) {
          if (this._crs === "WMTS:PM") {
            var nbCol = Math.pow(2, this.zoom);
            var size = 360 / nbCol;
            var west = 180 - size * (nbCol - this.col);
            var east = 180 - size * (nbCol - (this.col + 1));
            var nbRow = nbCol;
            var sizeRow = 1 / nbRow;
            var Yn = 1 - sizeRow * (nbRow - this.row);
            var Ys = 1 - sizeRow * (nbRow - (this.row + 1));
            var north = YToWGS84(Yn);
            var south = YToWGS84(Ys);
            return new Extent2("EPSG:4326", {
              west,
              east,
              south,
              north
            }).as(crs);
          }
          if (this._crs === "WMTS:WGS84G" && crs === "EPSG:4326") {
            var _nbRow = Math.pow(2, this.zoom);
            var _size = 180 / _nbRow;
            var _north = _size * (_nbRow - this.row) - 90;
            var _south = _size * (_nbRow - (this.row + 1)) - 90;
            var _west = 180 - _size * (2 * _nbRow - this.col);
            var _east = 180 - _size * (2 * _nbRow - (this.col + 1));
            return new Extent2(crs, {
              west: _west,
              east: _east,
              south: _south,
              north: _north
            });
          }
          throw new Error("Unsupported yet");
        }
        if (this._crs !== crs && !((0, _Coordinates.is4326)(this._crs) && (0, _Coordinates.is4326)(crs))) {
          var cardinals = [];
          var c = this.center();
          cardinals.push(new _Coordinates.default(this._crs, this.west(), this.north()));
          cardinals.push(new _Coordinates.default(this._crs, c._values[0], this.north()));
          cardinals.push(new _Coordinates.default(this._crs, this.east(), this.north()));
          cardinals.push(new _Coordinates.default(this._crs, this.east(), c._values[1]));
          cardinals.push(new _Coordinates.default(this._crs, this.east(), this.south()));
          cardinals.push(new _Coordinates.default(this._crs, c._values[0], this.south()));
          cardinals.push(new _Coordinates.default(this._crs, this.west(), this.south()));
          cardinals.push(new _Coordinates.default(this._crs, this.west(), c._values[1]));
          var _north2 = -Infinity;
          var _south2 = Infinity;
          var _east2 = -Infinity;
          var _west2 = Infinity;
          for (var i = 0; i < cardinals.length; i++) {
            cardinals[i] = cardinals[i].as(crs);
            _north2 = Math.max(_north2, cardinals[i]._values[1]);
            _south2 = Math.min(_south2, cardinals[i]._values[1]);
            _east2 = Math.max(_east2, cardinals[i]._values[0]);
            _west2 = Math.min(_west2, cardinals[i]._values[0]);
          }
          return new Extent2(crs, {
            north: _north2,
            south: _south2,
            east: _east2,
            west: _west2
          });
        }
        return this;
      }
    }, {
      key: "offsetToParent",
      value: function offsetToParent(other) {
        var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _three2.Vector4();
        if (this.crs() !== other.crs()) {
          throw new Error("unsupported mix");
        }
        if (_isTiledCRS(this.crs())) {
          var diffLevel = this.zoom - other.zoom;
          var diff = Math.pow(2, diffLevel);
          var invDiff = 1 / diff;
          var r = (this.row - this.row % diff) * invDiff;
          var c = (this.col - this.col % diff) * invDiff;
          return target.set(this.col * invDiff - c, this.row * invDiff - r, invDiff, invDiff);
        }
        var oDim = other.dimensions();
        var dim = this.dimensions();
        var originX = Math.round(1e3 * (this.west() - other.west()) / oDim.x) * 1e-3;
        var originY = Math.round(1e3 * (other.north() - this.north()) / oDim.y) * 1e-3;
        var scaleX = Math.round(1e3 * dim.x / oDim.x) * 1e-3;
        var scaleY = Math.round(1e3 * dim.y / oDim.y) * 1e-3;
        return target.set(originX, originY, scaleX, scaleY);
      }
      /**
       * @api
       * @returns {number} the horizontal coordinate of the westernmost side
       */
    }, {
      key: "west",
      value: function west() {
        return this._values[CARDINAL.WEST];
      }
      /**
       * @api
       * @returns {number} the horizontal coordinate of the easternmost side
       */
    }, {
      key: "east",
      value: function east() {
        return this._values[CARDINAL.EAST];
      }
      /**
       * @api
       * @returns {number} the horizontal coordinate of the northernmost side
       */
    }, {
      key: "north",
      value: function north() {
        return this._values[CARDINAL.NORTH];
      }
      /**
       * @api
       * @returns {number} the horizontal coordinate of the southermost side
       */
    }, {
      key: "south",
      value: function south() {
        return this._values[CARDINAL.SOUTH];
      }
      /**
       * Gets the coordinate reference system of this extent.
       *
       * @api
       * @returns {string} the coordinate reference system of this object
       */
    }, {
      key: "crs",
      value: function crs() {
        return this._crs;
      }
      /**
       * Sets `target` with the center of this extent.
       *
       * @api
       * @param {object|Vector2} target the object to set with the center's X.
       * If none provided, a new one is created.
       * @param {number} target.x the `x` component
       * @param {number} target.y the `y` component
       * @returns {object|Vector2} the modified object passed in argument.
       */
    }, {
      key: "center",
      value: function center(target) {
        if (_isTiledCRS(this._crs)) {
          throw new Error("Invalid operation for WMTS bbox");
        }
        var c;
        if (target) {
          _Coordinates.default.call(target, this._crs, this._values[0], this._values[2]);
          c = target;
        } else {
          c = new _Coordinates.default(this._crs, this._values[0], this._values[2]);
        }
        var dim = this.dimensions();
        c._values[0] += dim.x * 0.5;
        c._values[1] += dim.y * 0.5;
        return c;
      }
      /**
       * Sets the target with the width and height of this extent.
       * The <code>x</code> property will be set with the width,
       * and the <code>y</code> property will be set with the height.
       *
       * @api
       * @param {object|Vector2} [target] the optional object to set with the width.
       * @returns {object|Vector2} the modified object passed in argument,
       * or a new object if none was provided.
       */
    }, {
      key: "dimensions",
      value: function dimensions(target) {
        target = target || {
          x: 0,
          y: 0
        };
        target.x = Math.abs(this.east() - this.west());
        target.y = Math.abs(this.north() - this.south());
        return target;
      }
      /**
       * Checks whether the specified coordinate is inside this extent.
       *
       * @api
       * @param {Coordinates} coord the coordinate to test
       * @param {number} [epsilon=0] the precision delta (+/- epsilon)
       * @returns {boolean} true if the coordinate is inside the bounding box
       */
    }, {
      key: "isPointInside",
      value: function isPointInside(coord) {
        var epsilon = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var c = this.crs() === coord.crs ? coord : coord.as(this.crs());
        if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
          return c.longitude() <= this.east() + epsilon && c.longitude() >= this.west() - epsilon && c.latitude() <= this.north() + epsilon && c.latitude() >= this.south() - epsilon;
        }
        return c.x() <= this.east() + epsilon && c.x() >= this.west() - epsilon && c.y() <= this.north() + epsilon && c.y() >= this.south() - epsilon;
      }
      /**
       * Tests whether this extent is contained in another extent.
       *
       * @api
       * @param {Extent} other the other extent to test
       * @param {number} [epsilon=null] the precision delta (+/- epsilon).
       * If this value is not provided, a reasonable epsilon will be computed.
       * @returns {boolean} true if this extent is contained in the other extent.
       */
    }, {
      key: "isInside",
      value: function isInside(other, epsilon) {
        if (_isTiledCRS(this.crs())) {
          if (this.zoom === other.zoom) {
            return this.row === other.row && this.col === other.col;
          }
          if (this.zoom < other.zoom) {
            return false;
          }
          var diffLevel = this.zoom - other.zoom;
          var diff = Math.pow(2, diffLevel);
          var invDiff = 1 / diff;
          var r = (this.row - this.row % diff) * invDiff;
          var c = (this.col - this.col % diff) * invDiff;
          return r === other.row && c === other.col;
        }
        var o = other.as(this._crs);
        epsilon = epsilon == null ? (0, _Coordinates.reasonnableEpsilonForCRS)(this._crs, this) : epsilon;
        return this.east() - o.east() <= epsilon && o.west() - this.west() <= epsilon && this.north() - o.north() <= epsilon && o.south() - this.south() <= epsilon;
      }
    }, {
      key: "offsetScale",
      value: function offsetScale(bbox) {
        if (bbox.crs() !== this.crs()) {
          throw new Error("unsupported offscale between 2 diff crs");
        }
        var dimension = {
          x: Math.abs(this.east() - this.west()),
          y: Math.abs(this.north() - this.south())
        };
        var originX = (bbox.west() - this.west()) / dimension.x;
        var originY = (bbox.north() - this.north()) / dimension.y;
        var scaleX = Math.abs(bbox.east() - bbox.west()) / dimension.x;
        var scaleY = Math.abs(bbox.north() - bbox.south()) / dimension.y;
        return new _three2.Vector4(originX, originY, scaleX, scaleY);
      }
      /**
       * Returns true if this bounding box intersect with the bouding box parameter
       *
       * @api
       * @param {Extent} bbox the bounding box to test
       * @returns {boolean} true if this bounding box intersects with the provided bounding box
       */
    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(bbox) {
        var other = bbox.as(this.crs());
        return !(this.west() >= other.east() || this.east() <= other.west() || this.south() >= other.north() || this.north() <= other.south());
      }
      /**
       * Set this extent to the intersection of itself and other
       *
       * @api
       * @param {Extent} other the bounding box to intersect
       * @returns {Extent} the modified extent
       */
    }, {
      key: "intersect",
      value: function intersect(other) {
        if (!this.intersectsExtent(other)) {
          this.set(this.crs(), 0, 0, 0, 0);
          return this;
        }
        if (other.crs() !== this.crs()) {
          other = other.as(this.crs());
        }
        this.set(this.crs(), Math.max(this.west(), other.west()), Math.min(this.east(), other.east()), Math.max(this.south(), other.south()), Math.min(this.north(), other.north()));
        return this;
      }
      /**
       * Set the coordinate reference system and values of this
       * extent.
       *
       * @api
       * @param {*} crs the new CRS
       * @param  {...any} values the new values
       * @returns {Extent} this object modified
       */
    }, {
      key: "set",
      value: function set2(crs) {
        var _this2 = this;
        for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          values[_key2 - 1] = arguments[_key2];
        }
        this._crs = crs;
        if (_isTiledCRS(this.crs())) {
          this.zoom = values[0];
          this.row = values[1];
          this.col = values[2];
        } else {
          Object.keys(CARDINAL).forEach(function(key) {
            var cardinal = CARDINAL[key];
            _this2._values[cardinal] = values[cardinal];
          });
        }
        return this;
      }
    }, {
      key: "copy",
      value: function copy(other) {
        var _this3 = this;
        this._crs = other.crs();
        if (_isTiledCRS(this.crs())) {
          this.zoom = other.zoom;
          this.row = other.row;
          this.col = other.col;
        } else {
          Object.keys(CARDINAL).forEach(function(key) {
            var cardinal = CARDINAL[key];
            _this3._values[cardinal] = other._values[cardinal];
          });
        }
        return this;
      }
    }, {
      key: "union",
      value: function union(extent2) {
        if (extent2.crs() !== this.crs()) {
          throw new Error("unsupported union between 2 diff crs");
        }
        var west = extent2.west();
        if (west < this.west()) {
          this._values[CARDINAL.WEST] = west;
        }
        var east = extent2.east();
        if (east > this.east()) {
          this._values[CARDINAL.EAST] = east;
        }
        var south = extent2.south();
        if (south < this.south()) {
          this._values[CARDINAL.SOUTH] = south;
        }
        var north = extent2.north();
        if (north > this.north()) {
          this._values[CARDINAL.NORTH] = north;
        }
      }
      /**
       * Expands the extent to contain the specified coordinates.
       *
       * @api
       * @param {Coordinates} coordinates The coordinates to include
       */
    }, {
      key: "expandByPoint",
      value: function expandByPoint(coordinates) {
        var coords = coordinates.as(this.crs());
        var we = coords._values[0];
        if (we < this.west()) {
          this._values[CARDINAL.WEST] = we;
        }
        if (we > this.east()) {
          this._values[CARDINAL.EAST] = we;
        }
        var sn = coords._values[1];
        if (sn < this.south()) {
          this._values[CARDINAL.SOUTH] = sn;
        }
        if (sn > this.north()) {
          this._values[CARDINAL.NORTH] = sn;
        }
      }
      /**
       * Moves the extent by the provided <code>x</code> and <code>y</code> values.
       *
       * @api
       * @param {number} x the horizontal shift
       * @param {number} y the vertical shift
       * @returns {Extent} the modified extents.
       */
    }, {
      key: "shift",
      value: function shift(x, y) {
        this._values[CARDINAL.WEST] += x;
        this._values[CARDINAL.EAST] += x;
        this._values[CARDINAL.SOUTH] += y;
        this._values[CARDINAL.NORTH] += y;
        return this;
      }
      /**
       * Constructs an extent from the specified box.
       *
       * @api
       * @static
       * @param {string} crs the coordinate reference system of the new extent.
       * @param {object} box the box to read values from
       * @param {object} box.min the lower left corner of the box
       * @param {number} box.min.x the x value of the lower left corner of the box
       * @param {number} box.min.y the y value of the lower left corner of the box
       * @param {object} box.max the upper right corner of the box
       * @param {number} box.max.x the x value of the upper right corner of the box
       * @param {number} box.max.y the y value of the upper right corner of the box
       * @returns {Extent} the constructed extent.
       */
    }, {
      key: "quadtreeSplit",
      value: function quadtreeSplit() {
        this.center(tmpCoords);
        var northWest = new Extent2(this.crs(), this.west(), tmpCoords._values[0], tmpCoords._values[1], this.north());
        var northEast = new Extent2(this.crs(), tmpCoords._values[0], this.east(), tmpCoords._values[1], this.north());
        var southWest = new Extent2(this.crs(), this.west(), tmpCoords._values[0], this.south(), tmpCoords._values[1]);
        var southEast = new Extent2(this.crs(), tmpCoords._values[0], this.east(), this.south(), tmpCoords._values[1]);
        return [northWest, northEast, southWest, southEast];
      }
    }, {
      key: "externalBorders",
      value: function externalBorders(ratio) {
        var result = [this.clone(), this.clone(), this.clone(), this.clone()];
        var dim = this.dimensions();
        result[0]._values[CARDINAL.SOUTH] = result[0]._values[CARDINAL.NORTH];
        result[0]._values[CARDINAL.NORTH] += dim.y * ratio;
        result[1]._values[CARDINAL.WEST] = result[1]._values[CARDINAL.EAST];
        result[1]._values[CARDINAL.EAST] += dim.x * ratio;
        result[2]._values[CARDINAL.NORTH] = result[2]._values[CARDINAL.SOUTH];
        result[2]._values[CARDINAL.SOUTH] -= dim.y * ratio;
        result[3]._values[CARDINAL.EAST] = result[3]._values[CARDINAL.WEST];
        result[3]._values[CARDINAL.WEST] -= dim.x * ratio;
        return result;
      }
    }], [{
      key: "fromBox3",
      value: function fromBox3(crs, box) {
        return new this(crs, {
          west: box.min.x,
          east: box.max.x,
          south: box.min.y,
          north: box.max.y
        });
      }
    }]);
    return Extent2;
  }();
  var _default2 = Extent$1;
  Extent.default = _default2;
  return Extent;
}
var hasRequiredProjection;
function requireProjection() {
  if (hasRequiredProjection)
    return Projection;
  hasRequiredProjection = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Projection, "__esModule", {
    value: true
  });
  Projection.default = void 0;
  var _three2 = require$$8$1;
  var _Coordinates = _interopRequireDefault2(requireCoordinates());
  var _Extent2 = _interopRequireDefault2(requireExtent());
  var PI_OV_FOUR = Math.PI / 4;
  var PI_OV_TWO = Math.PI / 2;
  var INV_TWO_PI = 1 / (Math.PI * 2);
  var LOG_TWO = Math.log(2);
  function WGS84LatitudeClamp(latitude) {
    return Math.min(84, Math.max(-86, latitude));
  }
  var dim = {
    x: 0,
    y: 0
  };
  var center = new _Coordinates.default("EPSG:4326", 0, 0, 0);
  var Projection$12 = {
    /**
     * Convert latitude to y coordinate in TileMatrixSet
     *
     * @param {number} latitude latitude in degrees
     * @returns {number} the Y coordinate
     */
    WGS84ToY: function WGS84ToY(latitude) {
      return 0.5 - Math.log(Math.tan(PI_OV_FOUR + _three2.Math.degToRad(latitude) * 0.5)) * INV_TWO_PI;
    },
    /**
     * Convert from y coordinate in TileMatrixSet to WGS84 latitude
     *
     * @param {number} y coords in TileMatrixSet
     * @returns {number} - latitude in degrees
     */
    YToWGS84: function YToWGS84(y) {
      return _three2.Math.radToDeg(2 * (Math.atan(Math.exp(-(y - 0.5) / INV_TWO_PI)) - PI_OV_FOUR));
    },
    getCoordWMTS_WGS84: function getCoordWMTS_WGS84(tileCoord, bbox, tileMatrixSet) {
      if (tileMatrixSet === "PM") {
        return wmtsWgs84ToWmtsPm(tileCoord, bbox);
      }
      if (tileMatrixSet === "WGS84G") {
        return [tileCoord.clone()];
      }
      throw new Error("Unsupported TileMatrixSet '".concat(tileMatrixSet, "'"));
    },
    WGS84toWMTS: function WGS84toWMTS(bbox) {
      var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _Extent2.default("WMTS:WGS84G", 0, 0, 0);
      bbox.dimensions(dim);
      var zoom = Math.floor(Math.log(Math.PI / _three2.Math.degToRad(dim.y)) / LOG_TWO + 0.5);
      var nY = Math.pow(2, zoom);
      var uX = Math.PI * 2 / (2 * nY);
      var uY = Math.PI / nY;
      bbox.center(center);
      var col = Math.floor((Math.PI + _three2.Math.degToRad(center.longitude())) / uX);
      var row = Math.floor(nY - (PI_OV_TWO + _three2.Math.degToRad(center.latitude())) / uY);
      return target.set("WMTS:WGS84G", zoom, row, col);
    },
    UnitaryToLongitudeWGS84: function UnitaryToLongitudeWGS84(u, bbox) {
      bbox.dimensions(dim);
      return bbox.west() + u * dim.x;
    },
    UnitaryToLatitudeWGS84: function UnitaryToLatitudeWGS84(v, bbox) {
      bbox.dimensions(dim);
      return bbox.south() + v * dim.y;
    }
  };
  function wmtsWgs84ToWmtsPm(cWMTS, bbox) {
    var wmtsBox = [];
    var level = cWMTS.zoom + 1;
    var nbRow = Math.pow(2, level);
    var sizeRow = 1 / nbRow;
    var yMin = Projection$12.WGS84ToY(WGS84LatitudeClamp(bbox.north()));
    var yMax = Projection$12.WGS84ToY(WGS84LatitudeClamp(bbox.south()));
    var maxRow;
    var minRow = Math.floor(yMin / sizeRow);
    maxRow = Math.ceil(yMax / sizeRow) - 1;
    maxRow = Math.min(maxRow, nbRow - 1);
    var minCol = cWMTS.col;
    for (var r = maxRow; r >= minRow; r--) {
      for (var c = minCol; c <= minCol; c++) {
        wmtsBox.push(new _Extent2.default("WMTS:PM", level, r, c));
      }
    }
    return wmtsBox;
  }
  var _default2 = Projection$12;
  Projection.default = _default2;
  return Projection;
}
var hasRequiredOGCWebServiceHelper;
function requireOGCWebServiceHelper() {
  if (hasRequiredOGCWebServiceHelper)
    return OGCWebServiceHelper;
  hasRequiredOGCWebServiceHelper = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(OGCWebServiceHelper, "__esModule", {
    value: true
  });
  OGCWebServiceHelper.default = OGCWebServiceHelper.SIZE_TEXTURE_TILE = void 0;
  var _three2 = require$$8$1;
  var _Fetcher = _interopRequireDefault2(requireFetcher());
  var _Cache = _interopRequireDefault2(requireCache());
  var _Projection = _interopRequireDefault2(requireProjection());
  var _Extent2 = _interopRequireDefault2(requireExtent());
  var SIZE_TEXTURE_TILE = 256;
  OGCWebServiceHelper.SIZE_TEXTURE_TILE = SIZE_TEXTURE_TILE;
  var getTextureFloat = function(buffer2) {
    var texture = new _three2.DataTexture(buffer2, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, _three2.AlphaFormat, _three2.FloatType);
    texture.needsUpdate = true;
    return texture;
  };
  var tileCoord = new _Extent2.default("WMTS:WGS84G", 0, 0, 0);
  var _default2 = {
    getColorTextureByUrl: function getColorTextureByUrl(url, networkOptions) {
      return _Cache.default.get(url) || _Cache.default.set(url, _Fetcher.default.texture(url, networkOptions).then(function(texture) {
        texture.generateMipmaps = false;
        texture.magFilter = _three2.LinearFilter;
        texture.minFilter = _three2.LinearFilter;
        texture.anisotropy = 16;
        return texture;
      }), _Cache.default.POLICIES.TEXTURE);
    },
    getXBilTextureByUrl: function getXBilTextureByUrl(url, networkOptions) {
      return _Cache.default.get(url) || _Cache.default.set(url, _Fetcher.default.arrayBuffer(url, networkOptions).then(function(buffer2) {
        var texture = getTextureFloat(buffer2);
        texture.generateMipmaps = false;
        texture.magFilter = _three2.LinearFilter;
        texture.minFilter = _three2.LinearFilter;
        return texture;
      }), _Cache.default.POLICIES.TEXTURE);
    },
    computeTileMatrixSetCoordinates: function computeTileMatrixSetCoordinates(tile, tileMatrixSet) {
      tileMatrixSet = tileMatrixSet || "WGS84G";
      if (!(tileMatrixSet in tile.wmtsCoords)) {
        if (tile.wmtsCoords.WGS84G) {
          var c = tile.wmtsCoords.WGS84G[0];
          tileCoord.zoom = c.zoom;
          tileCoord.col = c.col;
          tileCoord.row = c.row;
        } else {
          _Projection.default.WGS84toWMTS(tile.extent, tileCoord);
          tile.wmtsCoords.WGS84G = [tileCoord.clone()];
        }
        tile.wmtsCoords[tileMatrixSet] = _Projection.default.getCoordWMTS_WGS84(tileCoord, tile.extent, tileMatrixSet);
      }
    },
    // The origin parameter is to be set to the correct value, bottom or top
    // (default being bottom) if the computation of the coordinates needs to be
    // inverted to match the same scheme as OSM, Google Maps or other system.
    // See link below for more information
    // https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates/
    computeTMSCoordinates: function computeTMSCoordinates(tileExtent, extent2) {
      var origin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "bottom";
      if (tileExtent.crs() !== extent2.crs()) {
        throw new Error("Unsupported configuration. TMS is only supported when geometry has the same crs than TMS layer");
      }
      var c = tileExtent.center();
      var layerDimension = extent2.dimensions();
      var tileCount = Math.round(layerDimension.x / tileExtent.dimensions().x);
      var zoom = Math.floor(Math.log2(tileCount));
      var x = (c.x() - extent2.west()) / layerDimension.x;
      var y;
      if (origin === "top") {
        y = (extent2.north() - c.y()) / layerDimension.y;
      } else {
        y = (c.y() - extent2.south()) / layerDimension.y;
      }
      return [new _Extent2.default("TMS", zoom, Math.floor(y * tileCount), Math.floor(x * tileCount))];
    },
    WMTS_WGS84Parent: function WMTS_WGS84Parent(cWMTS, levelParent, pitch) {
      var target = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new _Extent2.default(cWMTS.crs(), 0, 0, 0);
      var diffLevel = cWMTS.zoom - levelParent;
      var diff = Math.pow(2, diffLevel);
      var invDiff = 1 / diff;
      var r = (cWMTS.row - cWMTS.row % diff) * invDiff;
      var c = (cWMTS.col - cWMTS.col % diff) * invDiff;
      if (pitch) {
        pitch.x = cWMTS.col * invDiff - c;
        pitch.y = cWMTS.row * invDiff - r;
        pitch.z = invDiff;
        pitch.w = invDiff;
      }
      return target.set(target.crs(), levelParent, r, c);
    }
  };
  OGCWebServiceHelper.default = _default2;
  return OGCWebServiceHelper;
}
var hasRequiredTileMesh;
function requireTileMesh() {
  if (hasRequiredTileMesh)
    return TileMesh;
  hasRequiredTileMesh = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(TileMesh, "__esModule", {
    value: true
  });
  TileMesh.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _get2 = _interopRequireDefault2(requireGet());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  var _RendererConstant = _interopRequireDefault2(requireRendererConstant());
  var _OGCWebServiceHelper = _interopRequireDefault2(requireOGCWebServiceHelper());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function applyChangeState(n, s) {
    if (n.changeState) {
      n.changeState(s);
    }
  }
  var TileMesh$1 = /* @__PURE__ */ function(_Mesh) {
    (0, _inherits22.default)(TileMesh2, _Mesh);
    var _super = _createSuper2(TileMesh2);
    function TileMesh2(layer, geometry, material, extent2, level) {
      var _this;
      (0, _classCallCheck22.default)(this, TileMesh2);
      _this = _super.call(this, geometry, material);
      _this.layer = layer;
      _this.matrixAutoUpdate = false;
      _this.rotationAutoUpdate = false;
      _this.level = level;
      _this.extent = extent2;
      _this.geometry = geometry;
      _this.obb = _this.geometry.OBB.clone();
      _this.frustumCulled = false;
      _this.setDisplayed(false);
      _this.layerUpdateState = {};
      _this.material.setUuid(_this.id);
      var dim = extent2.dimensions();
      _this.material.uniforms.tileDimensions.value.set(dim.x, dim.y);
      if (layer.minMaxFromElevationLayer) {
        _this.setBBoxZ(layer.minMaxFromElevationLayer.min, layer.minMaxFromElevationLayer.max);
      }
      return _this;
    }
    (0, _createClass22.default)(TileMesh2, [{
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        (0, _get2.default)((0, _getPrototypeOf22.default)(TileMesh2.prototype), "updateMatrixWorld", this).call(this, force);
        this.OBB().update();
      }
    }, {
      key: "isVisible",
      value: function isVisible() {
        return this.visible;
      }
    }, {
      key: "setDisplayed",
      value: function setDisplayed2(show) {
        this.material.visible = show && this.material.update();
        this.material.transparent = this.material.opacity !== 1 || this.material.uniforms.noTextureOpacity.value !== 1;
      }
    }, {
      key: "setVisibility",
      value: function setVisibility(show) {
        this.visible = show;
      }
    }, {
      key: "isDisplayed",
      value: function isDisplayed() {
        return this.material.visible;
      }
      // switch material in function of state
    }, {
      key: "changeState",
      value: function changeState(state) {
        if (state === this.material.uniforms.renderingState.value) {
          return;
        }
        this.material.uniforms.renderingState.value = state;
        if (state > _RendererConstant.default.FINAL) {
          this.material.transparent = false;
        } else {
          this.material.transparent = this.material.opacity !== 1 || this.material.uniforms.noTextureOpacity.value !== 1;
        }
        this.material.needsUpdate = true;
      }
    }, {
      key: "pushRenderState",
      value: function pushRenderState(state) {
        var _this2 = this;
        if (this.material.uniforms.renderingState.value === state) {
          return function() {
          };
        }
        var oldState = this.material.uniforms.renderingState.value;
        this.traverse(function(n) {
          return applyChangeState(n, state);
        });
        return function() {
          _this2.traverse(function(n) {
            return applyChangeState(n, oldState);
          });
        };
      }
    }, {
      key: "setFog",
      value: function setFog(fog) {
        this.material.setFogDistance(fog);
      }
    }, {
      key: "setSelected",
      value: function setSelected(select) {
        this.material.setSelected(select);
      }
    }, {
      key: "setTextureElevation",
      value: function setTextureElevation(layer, elevation) {
        if (this.material === null) {
          return;
        }
        this.setBBoxZ(elevation.min, elevation.max);
        this.material.setElevationTexture(layer, elevation);
      }
    }, {
      key: "setBBoxZ",
      value: function setBBoxZ(min, max) {
        if (min == null && max == null) {
          return;
        }
        if (Math.floor(min) !== Math.floor(this.obb.z.min) || Math.floor(max) !== Math.floor(this.obb.z.max)) {
          this.OBB().updateZ(min, max);
        }
      }
    }, {
      key: "OBB",
      value: function OBB2() {
        return this.obb;
      }
    }, {
      key: "removeColorLayer",
      value: function removeColorLayer(idLayer) {
        if (this.layerUpdateState && this.layerUpdateState[idLayer]) {
          delete this.layerUpdateState[idLayer];
        }
        this.material.removeColorLayer(idLayer);
      }
    }, {
      key: "changeSequenceLayers",
      value: function changeSequenceLayers(sequence) {
        var layerCount = this.material.getColorLayersCount();
        if (layerCount < 2) {
          return;
        }
        this.material.setSequence(sequence);
      }
    }, {
      key: "getExtentForLayer",
      value: function getExtentForLayer(layer) {
        if (layer.extent.crs() !== this.extent.crs()) {
          throw new Error("Layer should be in the same CRS of their supporting tile geometry, but layer crs is ".concat(layer.extent.crs(), " and tile crs is ").concat(this.extent.crs()));
        }
        if (layer.protocol === "tms" || layer.protocol === "xyz") {
          return _OGCWebServiceHelper.default.computeTMSCoordinates(this.extent, layer.extent, layer.origin)[0];
        }
        return this.extent;
      }
      /**
       * Search for a common ancestor between this tile and another one. It goes
       * through parents on each side until one is found.
       *
       * @param {TileMesh} tile the tile to evaluate
       * @returns {TileMesh} the resulting common ancestor
       */
    }, {
      key: "findCommonAncestor",
      value: function findCommonAncestor(tile) {
        if (!tile) {
          return void 0;
        }
        if (tile.level === this.level) {
          if (tile.id === this.id) {
            return tile;
          }
          if (tile.level !== 0) {
            return this.parent.findCommonAncestor(tile.parent);
          }
          return void 0;
        }
        if (tile.level < this.level) {
          return this.parent.findCommonAncestor(tile);
        }
        return this.findCommonAncestor(tile.parent);
      }
    }, {
      key: "isAncestorOf",
      value: function isAncestorOf(node) {
        return node.findCommonAncestor(this) === this;
      }
    }, {
      key: "findSmallestExtentCoveringGoingDown",
      value: function findSmallestExtentCoveringGoingDown(extent2) {
        if (this.children) {
          var _iterator = _createForOfIteratorHelper2(this.children), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var child = _step.value;
              if (child.extent) {
                if (extent2.isInside(child.extent)) {
                  return child.findSmallestExtentCoveringGoingDown(extent2);
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        return [this, extent2];
      }
    }, {
      key: "findSmallestExtentCoveringGoingUp",
      value: function findSmallestExtentCoveringGoingUp(extent2) {
        if (extent2.isInside(this.extent)) {
          return this;
        }
        if (!this.parent || !this.parent.extent) {
          if (this.level === 0 && this.parent.children.length) {
            var _iterator2 = _createForOfIteratorHelper2(this.parent.children), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var sibling = _step2.value;
                if (sibling.extent && extent2.isInside(sibling.extent)) {
                  return sibling;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          return void 0;
        }
        return this.parent.findSmallestExtentCoveringGoingUp(extent2);
      }
    }, {
      key: "findSmallestExtentCovering",
      value: function findSmallestExtentCovering(extent2) {
        var node = this.findSmallestExtentCoveringGoingUp(extent2);
        if (!node) {
          return null;
        }
        return node.findSmallestExtentCoveringGoingDown(extent2);
      }
    }, {
      key: "findNeighbours",
      value: function findNeighbours() {
        var _this3 = this;
        var borders = this.extent.externalBorders(0.1);
        return borders.map(function(border) {
          return _this3.findSmallestExtentCovering(border);
        });
      }
    }]);
    return TileMesh2;
  }(_three2.Mesh);
  var _default2 = TileMesh$1;
  TileMesh.default = _default2;
  return TileMesh;
}
var LayeredMaterial = {};
var DEMUtils = {};
var hasRequiredDEMUtils;
function requireDEMUtils() {
  if (hasRequiredDEMUtils)
    return DEMUtils;
  hasRequiredDEMUtils = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(DEMUtils, "__esModule", {
    value: true
  });
  DEMUtils.default = DEMUtils.ELEVATION_FORMAT = void 0;
  var _slicedToArray2 = _interopRequireDefault2(requireSlicedToArray());
  var _three2 = require$$8$1;
  var _Coordinates = _interopRequireDefault2(requireCoordinates());
  var FAST_READ_Z = 0;
  var PRECISE_READ_Z = 1;
  var ELEVATION_FORMAT = {
    MAPBOX_RGB: 0,
    HEIGHFIELD: 1,
    XBIL: 2,
    RATP_GEOL: 3
  };
  DEMUtils.ELEVATION_FORMAT = ELEVATION_FORMAT;
  function getElevationValueAt(entity, coord) {
    var method = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : FAST_READ_Z;
    var tileHint = arguments.length > 3 ? arguments[3] : void 0;
    var result = _readZ(entity, method, coord, tileHint || entity.level0Nodes);
    if (!result) {
      return null;
    }
    return {
      z: result.coord._values[2],
      texture: result.texture,
      tile: result.tile
    };
  }
  function placeObjectOnGround(entity, objectCRS, obj) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var tileHint = arguments.length > 4 ? arguments[4] : void 0;
    var tiles;
    if (tileHint) {
      tiles = tileHint.concat(entity.level0Nodes);
    } else {
      tiles = entity.level0Nodes;
    }
    if (!options.modifyGeometry) {
      if (options.cache) {
        options.cache.length = 1;
      }
      var _matrices = {
        worldFromLocal: obj.parent ? obj.parent.matrixWorld : void 0,
        localFromWorld: obj.parent ? new _three2.Matrix4().copy(obj.parent.matrixWorld).invert() : void 0
      };
      var result = _updateVector3(entity, options.method || FAST_READ_Z, tiles, objectCRS, obj.position, options.offset || 0, _matrices, void 0, options.cache ? options.cache[0] : void 0);
      if (!result) {
        return false;
      }
      if (options.cache) {
        options.cache[0] = result;
      }
      obj.updateMatrix();
      obj.updateMatrixWorld();
      return true;
    }
    var matrices = {
      worldFromLocal: obj.matrixWorld,
      localFromWorld: new _three2.Matrix4().copy(obj.matrixWorld).invert()
    };
    var geometry = obj.geometry;
    if (geometry.vertices) {
      if (options.cache) {
        options.cache.length = geometry.vertices.length;
      }
      var success = true;
      var coord = new _Coordinates.default(objectCRS);
      for (var i = 0; i < geometry.vertices.length; i++) {
        var cached = options.cache ? options.cache[i] : void 0;
        var result = _updateVector3(entity, options.method || FAST_READ_Z, tiles, objectCRS, geometry.vertices[i], options.offset || 0, matrices, coord, cached);
        if (options.cache) {
          options.cache[i] = result;
        }
        if (!result) {
          success = false;
        }
      }
      geometry.verticesNeedUpdate = true;
      return success;
    }
    if (geometry instanceof _three2.BufferGeometry) {
      if (options.cache) {
        options.cache.length = geometry.attributes.position.count;
      }
      var _success = true;
      var tmp2 = new _three2.Vector3();
      var _coord = new _Coordinates.default(objectCRS);
      for (var _i = 0; _i < geometry.attributes.position.count; _i++) {
        var _cached = options.cache ? options.cache[_i] : void 0;
        tmp2.fromBufferAttribute(geometry.attributes.position, _i);
        var prev = tmp2.z;
        var _result = _updateVector3(entity, options.method || FAST_READ_Z, tiles, objectCRS, tmp2, options.offset || 0, matrices, _coord, _cached);
        if (options.cache) {
          options.cache[_i] = _result;
        }
        if (!_result) {
          _success = false;
        }
        if (prev !== tmp2.z) {
          geometry.attributes.position.needsUpdate = true;
        }
        geometry.attributes.position.setXYZ(_i, tmp2.x, tmp2.y, tmp2.z);
      }
      return _success;
    }
    return false;
  }
  function decodeMapboxElevation(r, g, b) {
    return -1e4 + (r * 256 * 256 + g * 256 + b) * 0.1;
  }
  function tileAt(pt, tile) {
    if (!tile.extent) {
      return null;
    }
    if (!tile.extent.isPointInside(pt)) {
      return void 0;
    }
    for (var i = 0; i < tile.children.length; i++) {
      var t = tileAt(pt, tile.children[i]);
      if (t) {
        return t;
      }
    }
    return tile;
  }
  var _canvas2;
  var ctx;
  function _readTextureValueAt(textureInfo) {
    var texture = textureInfo.texture, format = textureInfo.elevationFormat;
    for (var _len = arguments.length, uv = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      uv[_key - 1] = arguments[_key];
    }
    for (var i = 0; i < uv.length; i += 2) {
      uv[i] = _three2.MathUtils.clamp(uv[i], 0, texture.image.width - 1);
      uv[i + 1] = _three2.MathUtils.clamp(uv[i + 1], 0, texture.image.height - 1);
    }
    if (texture.image.data) {
      if (uv.length === 2) {
        return texture.image.data[uv[1] * texture.image.width + uv[0]];
      }
      var _result2 = [];
      for (var _i2 = 0; _i2 < uv.length; _i2 += 2) {
        _result2.push(texture.image.data[uv[_i2 + 1] * texture.image.width + uv[_i2]]);
      }
      return _result2;
    }
    if (!_canvas2) {
      _canvas2 = document.createElement("canvas");
      _canvas2.width = 2;
      _canvas2.height = 2;
      ctx = _canvas2.getContext("2d");
    }
    var minx = Infinity;
    var miny = Infinity;
    var maxx = -Infinity;
    var maxy = -Infinity;
    for (var _i3 = 0; _i3 < uv.length; _i3 += 2) {
      minx = Math.min(uv[_i3], minx);
      miny = Math.min(uv[_i3 + 1], miny);
      maxx = Math.max(uv[_i3], maxx);
      maxy = Math.max(uv[_i3 + 1], maxy);
    }
    var dw = maxx - minx + 1;
    var dh = maxy - miny + 1;
    _canvas2.width = Math.max(_canvas2.width, dw);
    _canvas2.height = Math.max(_canvas2.height, dh);
    ctx.drawImage(texture.image, minx, miny, dw, dh, 0, 0, dw, dh);
    var d = ctx.getImageData(0, 0, dw, dh);
    var result = [];
    for (var _i4 = 0; _i4 < uv.length; _i4 += 2) {
      var ox = uv[_i4] - minx;
      var oy = uv[_i4 + 1] - miny;
      if (format === ELEVATION_FORMAT.MAPBOX_RGB) {
        result.push(decodeMapboxElevation(d.data[4 * oy * dw + 4 * ox], d.data[4 * oy * dw + 4 * ox + 1], d.data[4 * oy * dw + 4 * ox + 2]));
      } else if (format === ELEVATION_FORMAT.HEIGHFIELD) {
        var red = d.data[4 * oy * dw + 4 * ox] / 256;
        var elevation = textureInfo.heightFieldOffset + red * textureInfo.heightFieldScale;
        result.push(elevation);
      } else if (format === ELEVATION_FORMAT.XBIL) {
        throw new Error('Unimplemented reading elevation value for layer.elevationFormat "'.concat(format, "'"));
      } else if (format === ELEVATION_FORMAT.RATP_GEOL) {
        throw new Error('Unimplemented reading elevation value for layer.elevationFormat "'.concat(format, "'"));
      } else {
        throw new Error('Unsupported layer.elevationFormat "'.concat(format, "'"));
      }
    }
    if (uv.length === 2) {
      return result[0];
    }
    return result;
  }
  function _convertUVtoTextureCoords(texture, u, v) {
    var width = texture.image.width;
    var height = texture.image.height;
    var up = Math.max(0, u * width - 0.5);
    var vp = Math.max(0, v * height - 0.5);
    var u1 = Math.floor(up);
    var u2 = Math.ceil(up);
    var v1 = Math.floor(vp);
    var v2 = Math.ceil(vp);
    return {
      u1,
      u2,
      v1,
      v2,
      wu: up - u1,
      wv: vp - v1
    };
  }
  function _readTextureValueNearestFiltering(textureInfo, vertexU, vertexV) {
    var coords = _convertUVtoTextureCoords(textureInfo.texture, vertexU, vertexV);
    var u = coords.wu <= 0 ? coords.u1 : coords.u2;
    var v = coords.wv <= 0 ? coords.v1 : coords.v2;
    return _readTextureValueAt(textureInfo, u, v);
  }
  function _readTextureValueWithBilinearFiltering(textureInfo, vertexU, vertexV) {
    var coords = _convertUVtoTextureCoords(textureInfo.texture, vertexU, vertexV);
    var _readTextureValueAt2 = _readTextureValueAt(textureInfo, coords.u1, coords.v1, coords.u2, coords.v1, coords.u1, coords.v2, coords.u2, coords.v2), _readTextureValueAt3 = (0, _slicedToArray2.default)(_readTextureValueAt2, 4), z11 = _readTextureValueAt3[0], z21 = _readTextureValueAt3[1], z12 = _readTextureValueAt3[2], z22 = _readTextureValueAt3[3];
    var zu1 = _three2.MathUtils.lerp(z11, z21, coords.wu);
    var zu2 = _three2.MathUtils.lerp(z12, z22, coords.wu);
    return _three2.MathUtils.lerp(zu1, zu2, coords.wv);
  }
  function _readZFast(textureInfo, uv) {
    return _readTextureValueNearestFiltering(textureInfo, uv.x, uv.y);
  }
  var bary = new _three2.Vector3();
  function _readZCorrect(textureInfo, uv, tileDimensions, tileOwnerDimensions) {
    var modulo2 = tileDimensions.x / tileOwnerDimensions.x / (17 - 1);
    var u = Math.floor(uv.x / modulo2) * modulo2;
    var v = Math.floor(uv.y / modulo2) * modulo2;
    if (u === 1) {
      u -= modulo2;
    }
    if (v === 1) {
      v -= modulo2;
    }
    var u1 = u;
    var u2 = u + modulo2;
    var v1 = v;
    var v2 = v + modulo2;
    var lu = (uv.x - u) / modulo2;
    var lv = (uv.y - v) / modulo2;
    var tri = new _three2.Triangle(new _three2.Vector3(u1, v2), new _three2.Vector3(u2, v1), lv === 1 || lu / (1 - lv) >= 1 ? new _three2.Vector3(u2, v2) : new _three2.Vector3(u1, v1));
    tri.getBarycoord(new _three2.Vector3(uv.x, uv.y), bary);
    var z1 = _readTextureValueWithBilinearFiltering(textureInfo, tri.a.x, tri.a.y);
    var z2 = _readTextureValueWithBilinearFiltering(textureInfo, tri.b.x, tri.b.y);
    var z3 = _readTextureValueWithBilinearFiltering(textureInfo, tri.c.x, tri.c.y);
    return z1 * bary.x + z2 * bary.y + z3 * bary.z;
  }
  var temp = {
    v: new _three2.Vector3(),
    coord1: new _Coordinates.default("EPSG:4978"),
    coord2: new _Coordinates.default("EPSG:4978"),
    offset: new _three2.Vector2()
  };
  function _readZ(entity, method, coord, nodes, cache2) {
    var pt = coord.as(entity.extent.crs(), temp.coord1);
    var tile = null;
    if (cache2 && cache2.tile && cache2.tile.material) {
      tile = tileAt(pt, cache2.tile);
    }
    for (var i = 0; !tile && i < nodes.length; i++) {
      tile = tileAt(pt, nodes[i]);
    }
    if (!tile) {
      return null;
    }
    var textureInfo = tile.material.getElevationTextureInfo();
    if (!textureInfo) {
      return {
        coord: pt,
        tile
      };
    }
    var src = textureInfo.texture;
    if (cache2) {
      if (cache2.id === src.id && cache2.version === src.version) {
        return {
          coord: pt,
          texture: src,
          tile
        };
      }
    }
    var offset = pt.offsetInExtent(textureInfo.texture.extent);
    if (method === PRECISE_READ_Z) {
      pt._values[2] = _readZCorrect(textureInfo, offset, tile.extent.dimensions(), textureInfo.texture.extent.dimensions());
    } else {
      pt._values[2] = _readZFast(textureInfo, offset);
    }
    return {
      coord: pt,
      texture: src,
      tile
    };
  }
  function _updateVector3(entity, method, nodes, vecCRS, vec, offset) {
    var matrices = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {};
    var coords = arguments.length > 7 ? arguments[7] : void 0;
    var cache2 = arguments.length > 8 ? arguments[8] : void 0;
    var coord = coords || new _Coordinates.default(vecCRS);
    if (matrices.worldFromLocal) {
      coord.set(vecCRS, temp.v.copy(vec).applyMatrix4(matrices.worldFromLocal));
    } else {
      coord.set(vecCRS, vec);
    }
    var result = _readZ(entity, method, coord, nodes, cache2);
    if (!result) {
      return null;
    }
    result.coord._values[2] += offset;
    result.coord.as(vecCRS, temp.coord2).xyz(vec);
    if (matrices.localFromWorld) {
      vec.applyMatrix4(matrices.localFromWorld);
    }
    return {
      id: result.texture.id,
      version: result.texture.version,
      tile: result.tile
    };
  }
  var _default2 = {
    getElevationValueAt,
    placeObjectOnGround,
    decodeMapboxElevation,
    FAST_READ_Z,
    PRECISE_READ_Z
  };
  DEMUtils.default = _default2;
  return DEMUtils;
}
var hasRequiredLayeredMaterial;
function requireLayeredMaterial() {
  if (hasRequiredLayeredMaterial)
    return LayeredMaterial;
  hasRequiredLayeredMaterial = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(LayeredMaterial, "__esModule", {
    value: true
  });
  LayeredMaterial.default = void 0;
  LayeredMaterial.initDebugTool = initDebugTool;
  LayeredMaterial.unpack1K = unpack1K;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  var _RendererConstant = _interopRequireDefault2(requireRendererConstant());
  var _DEMUtils = requireDEMUtils();
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var TileVS = "#include <PrecisionQualifier>\n\nattribute vec3      position;\nattribute vec2      uv;\n\nuniform sampler2D   elevationTexture;\nuniform vec4        elevationOffsetScale;\n#if defined(STITCHING)\nuniform sampler2D nTex[4];\nuniform vec4 nOff[4];\nuniform float segments;\n#endif\n\nuniform mat4        projectionMatrix;\nuniform mat4        modelMatrix;\nuniform mat4        viewMatrix;\nuniform mat4 modelViewMatrix;\n\nuniform vec4 neighbourdiffLevel;\nuniform vec2 tileDimensions;\n\nvarying vec2        vUv;\nvarying vec4 vColor;\nvarying vec4 vPosition;\n\nuniform vec4 validityExtent;\n\n#include <GetElevation>\n#include <ComputeUV>\n\n#if defined(STITCHING)\nfloat readNeighbourElevation(vec2 uv, int neighbour, sampler2D texture) {\n    vec2 vv = uv;\n    // top\n    if (neighbour == 1 || neighbour == 3) {\n        vv.x = 1.0 - vv.x;\n    } else {\n        vv.y = 1.0 - vv.y;\n    }\n    vec2 vVv = computeUv(\n        vv,\n        nOff[neighbour].xy, nOff[neighbour].zw);\n    return getElevation(texture, vVv);\n}\n#endif\n\n\nvoid main() {\n    vUv = uv;\n    vPosition = vec4(position, 1.0);\n    vColor = vec4(0., 0., 0., 0.);\n\n    if(elevationOffsetScale.z > 0.) {\n        vec2 vVv = computeUv(vUv, elevationOffsetScale.xy, elevationOffsetScale.zw);\n        int weight = 1;\n\n        float elevation = getElevation(elevationTexture, vVv);\n\n#if defined(STITCHING)\n        // We process the 4 borders separatly. The logic is:\n        // - identify if the current vertex is on the border\n        // - then, if the neighbour tile is:\n        //     - at the same level (= precision): we average\n        //       both elevations\n        //     - at a lower level (less precise): we use its\n        //       elevation. And if this vertex has no direct\n        //       v-neighbour, it is shifted along the other\n        //       (x when processing north/south border, else\n        //       y) to be at the same position than the vertex\n        //       on the other tile. Eg, for vertex 'o' below:\n        //\n        //    ---xx--x--       ---xx--x--\n        //       ||  |            |||\n        //       |o--x--  =>      ||  x--\n        //       ||  |            ||  |\n        //    ---xx--x--       ---xx--x--\n        //       ||  |            ||  |\n        //\n        // factor: num_vert_in_tile / num_vert_in_neighbour_tile\n        //       = 2^(level_difference)\n        vec4 neighbourFactor = pow(vec4(2.0), abs(neighbourdiffLevel));\n        // Interval in current tile is: 1.0 / segments. If a neighbour\n        // has less vertices on our shared edges, its interval size is\n        // going to be:\n        vec4 modulo = neighbourFactor / segments;\n        // West border\n        if (vUv.x < 0.01) {\n            if (neighbourdiffLevel.w < 0.0) {\n                float offset = fract(vUv.y / modulo.w) * modulo.w;\n                vPosition.y -= tileDimensions.y * offset;\n                vUv.y -= offset;\n\n                elevation = readNeighbourElevation(vUv, 3, nTex[3]);\n                weight = 1;\n                // vColor = vec4(0.0, 1.0, 0.0, 0.5);\n            } else if (neighbourdiffLevel.w == 0.0) {\n                elevation += readNeighbourElevation(uv, 3, nTex[3]);\n                weight += 1;\n            }\n        }\n        // East border\n        else if (vUv.x > 0.99) {\n            if (neighbourdiffLevel.y < 0.0) {\n                float offset = fract(vUv.y / modulo.y) * modulo.y;\n                vPosition.y -= tileDimensions.y * offset;\n                vUv.y -= offset;\n                elevation = readNeighbourElevation(vUv, 1, nTex[1]);\n                weight = 1;\n                // vColor = vec4(1.0, 1.0, 0.0, 0.5);\n            } else if (neighbourdiffLevel.y == 0.0) {\n                elevation += readNeighbourElevation(uv, 1, nTex[1]);\n                weight += 1;\n            }\n        }\n        // South border\n        else if (vUv.y < 0.01) {\n            if (neighbourdiffLevel.z < 0.0) {\n                float offset = fract(vUv.x / modulo.z) * modulo.z;\n                // move to the left\n                vPosition.x -= tileDimensions.x * offset;\n                vUv.x -= offset;\n\n                elevation = readNeighbourElevation(vUv, 2, nTex[2]);\n                weight = 1;\n                // vColor = vec4(0.0, 1.0, 1.0, 0.5);\n            } else if (neighbourdiffLevel.z == 0.0) {\n                elevation += readNeighbourElevation(uv, 2, nTex[2]);\n                weight += 1;\n            }\n        }\n        // North border\n        else if (vUv.y > 0.99) {\n            if (neighbourdiffLevel.x < 0.0) {\n                float offset = fract(vUv.x / modulo.x) * modulo.x;\n                vPosition.x -= tileDimensions.x * offset;\n                vUv.x -= offset;\n\n                elevation = readNeighbourElevation(vUv, 0, nTex[0]);\n                weight = 1;\n                // vColor = vec4(0.0, 0.0, 1.0, 0.5);\n            } else if (neighbourdiffLevel.x == 0.0) {\n                elevation += readNeighbourElevation(uv, 0, nTex[0]);\n                weight += 1;\n            }\n        }\n\n        if (weight > 1) {\n            elevation /= float(weight);\n        }\n#endif\n        vPosition.z = elevation;\n    }\n\n    // colors from OGC EL.GridCoverage.Default style\n    // float z = vPosition.z;\n    // if (z < -100.0) {\n    //     vColor = vec4(float(0x00) / 255.0, float(0x5C) / 255.0, float(0xE6) / 255.0, 1.0);\n    // } else if (z <= 0.0) {\n    //     vColor = mix(\n    //         vec4(float(0x00) / 255.0, float(0x5C) / 255.0, float(0xE6) / 255.0, 1.0),\n    //         vec4(float(0x28) / 255.0, float(0xED) / 255.0, float(0xD6) / 255.0, 1.0),\n    //         -z / 100.0);\n    // } else if (z <= 50.0) {\n    //     vColor = mix(\n    //         vec4(float(0x00) / 255.0, float(0x5C) / 255.0, float(0xE6) / 255.0, 1.0),\n    //         vec4(float(0x28) / 255.0, float(0xED) / 255.0, float(0xD6) / 255.0, 1.0),\n    //         -z / 100.0);\n    // } else if (z <= 50.0) {\n    //     vColor = mix(\n    //         vec4(float(0x28) / 255.0, float(0xED) / 255.0, float(0xD6) / 255.0, 1.0),\n    //         vec4(float(0x54) / 255.0, float(0xF7) / 255.0, float(0x6D) / 255.0, 1.0),\n    //         z / 50.0);\n    // } else if (z <= 100.0) {\n    //     vColor = mix(\n    //         vec4(float(0x54) / 255.0, float(0xF7) / 255.0, float(0x6D) / 255.0, 1.0),\n    //         vec4(float(0x9A) / 255.0, float(0xFA) / 255.0, float(0x66) / 255.0, 1.0),\n    //         (z - 50.0)/ 50.0);\n    // } else {\n    //     vColor = mix(\n    //         vec4(float(0x9A) / 255.0, float(0xFA) / 255.0, float(0x66) / 255.0, 1.0),\n    //         vec4(float(0x7B) / 255.0, float(0xF2) / 255.0, float(0x3A) / 255.0, 1.0),\n    //         (z - 100.0)/ 50.0);\n    // }\n    gl_Position = projectionMatrix * modelViewMatrix * vPosition;\n}\n";
  var TileFS = "#include <PrecisionQualifier>\n\nuniform int renderingState;\nuniform sampler2D colorTexture;\n\n#if TEX_UNITS\nuniform vec4      colorOffsetScale[TEX_UNITS];\nuniform float     colorOpacity[TEX_UNITS];\nuniform bool      colorVisible[TEX_UNITS];\nuniform vec3      colors[TEX_UNITS];\n#endif\n\n// backgroundColor\nuniform float      noTextureOpacity;\nuniform vec3      noTextureColor;\n// tile opacity\nuniform float     opacity;\n\nvarying vec2        vUv;\nvarying vec4 vColor;\nvarying vec4 vPosition;\n\n#if defined(HILLSHADE)\n// hillshade support\nuniform sampler2D   elevationTexture;\nuniform vec4        elevationOffsetScale;\nuniform vec2 tileDimensions;\n\n#include <GetElevation>\n\nfloat ZENITH = 0.7857142857;\nfloat AZIMUTH = 2.3571428571;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// from https://github.com/PropellerAero/cesium-elevation-gradient/blob/master/lib/shaders/elevationGradientFrag.glsl\nfloat calcHillshade(float a, float b, float c, float d, float e, float f, float g, float h, float i, vec2 onePixel){\n    vec2 cellsize = tileDimensions / onePixel;\n    // http://edndoc.esri.com/arcobjects/9.2/net/shared/geoprocessing/spatial_analyst_tools/how_hillshade_works.htm\n\n    float dzdx = ((c + 2.0 * f + i) - (a + 2.0 * d + g)) / (8.0 * cellsize.x);\n    float dzdy = ((g + 2.0 * h + i) - (a + 2.0 * b + c)) / (8.0 * cellsize.y);\n    float slope = atan(1.0 * sqrt(dzdx * dzdx + dzdy * dzdy));\n\n    float aspect = atan(dzdy, -dzdx);\n\n    if(aspect < 0.0){\n        aspect = aspect +  2.0 * M_PI;\n    }\n\n    float hillshade = ((cos(ZENITH) * cos(slope)) + (sin(ZENITH) * sin(slope) * cos(AZIMUTH - aspect)));\n    return clamp(hillshade, 0., 1.);\n}\n#endif\n\nvec4 encodeHalfRGBA ( vec2 v ) {\n	vec4 encoded = vec4( 0.0 );\n	const vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n	encoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n	encoded.xy = encoded.xy - ( encoded.yy * offset );\n	encoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n	encoded.zw = encoded.zw - ( encoded.ww * offset );\n	return encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n#if defined(DEBUG)\nuniform bool showOutline;\nconst float sLine = 0.003;\n#endif\n\n#include <ComputeUV>\n\n#include <packing>\nuniform int  uuid;\n\nvoid main() {\n    if (renderingState == 2) {\n        gl_FragColor = packDepthToRGBA(float(uuid) / (256.0 * 256.0 * 256.0));\n    } else if (renderingState == 1) {\n        gl_FragColor = packDepthToRGBA(gl_FragCoord.z);\n    } else if (renderingState == 3) {\n        gl_FragColor = encodeHalfRGBA(vUv);\n    } else {\n\n        vec4 diffuseColor = vec4(noTextureColor, 0.0);\n\n        bool hasTexture = false;\n\n        #if TEX_UNITS\n        #pragma unroll_loop_start\n        for (int i = 0; i < TEX_UNITS; i++) {\n            if (colorVisible[i] && colorOpacity[i] > 0.0 && colorOffsetScale[i].zw != vec2(0.0)) {\n                vec2 uv = computeUv(vUv, colorOffsetScale[i].xy, colorOffsetScale[i].zw);\n                vec4 layerColor = texture2D(colorTexture, uv);\n                if (layerColor.a > 0.0) {\n                    hasTexture = true;\n                }\n                layerColor.rgb *= colors[i];\n                diffuseColor = diffuseColor * (1.0 - layerColor.a * colorOpacity[i]) + layerColor * colorOpacity[i];\n            }\n        }\n        #pragma unroll_loop_end\n        #endif\n\n\n        gl_FragColor = diffuseColor;\n\n#if defined(HILLSHADE)\n        vec2 onePixel = vec2(1.0) / 256.0;\n\n        vec2 vVv = vec2(\n                vUv.x * elevationOffsetScale.z + elevationOffsetScale.x,\n                (1.0 - vUv.y) * elevationOffsetScale.w + elevationOffsetScale.y);\n\n        float a = getElevation(elevationTexture, vVv + onePixel * vec2(-1.0, 1.0));\n        float b = getElevation(elevationTexture, vVv + onePixel * vec2( 0.0, 1.0));\n        float c = getElevation(elevationTexture, vVv + onePixel * vec2( 1.0, 1.0));\n        float d = getElevation(elevationTexture, vVv + onePixel * vec2(-1.0, 0.0));\n        float e = getElevation(elevationTexture, vVv + onePixel * vec2( 0.0, 0.0));\n        float f = getElevation(elevationTexture, vVv + onePixel * vec2( 1.0, 0.0));\n        float g = getElevation(elevationTexture, vVv + onePixel * vec2(-1.0, -1.0));\n        float h = getElevation(elevationTexture, vVv + onePixel * vec2( 0.0, -1.0));\n        float i = getElevation(elevationTexture, vVv + onePixel * vec2( 1.0, -1.0));\n\n        float hillshade = calcHillshade(a, b, c, d, e, f, g, h, i, elevationOffsetScale.zw * 256.0);\n\n        gl_FragColor.rgb *= hillshade;\n#endif\n\n        // gl_FragColor.rgb = mix(gl_FragColor.rgb, vColor.rgb, vColor.a);\n        if (hasTexture) {\n            gl_FragColor.a = max(gl_FragColor.a, noTextureOpacity);\n        } else {\n            gl_FragColor = vec4(noTextureColor, noTextureOpacity);\n        }\n\n#if defined(DEBUG)\n        if (showOutline && (vUv.x < sLine || vUv.x > 1.0 - sLine || vUv.y < sLine || vUv.y > 1.0 - sLine)) {\n            gl_FragColor.rgb = mix(vec3(1.0, 0.0, 0.0), gl_FragColor.rgb, 0.2);\n        }\n#endif\n\n    }\n\n}\n";
  var PrecisionQualifier = "precision highp float;\nprecision highp int;\n";
  var GetElevation = "#if defined HEIGHTFIELD_ELEVATION\nuniform float heightFieldOffset;\nuniform float heightFieldScale;\n#endif\n#if defined(RATP_GEOL_ELEVATION)\nconst float lShift8 = 256.0;\nconst vec4 zShift = vec4(\n  1.0,\n  lShift8,\n  lShift8 * lShift8,\n  lShift8 * lShift8 * lShift8);\n#endif\n\nfloat getElevation(sampler2D texture, vec2 uv) {\n    #if defined(HEIGHTFIELD_ELEVATION)\n        vec4 c = texture2D(texture, uv);\n        vec4 color = heightFieldOffset + c * heightFieldScale;\n        return color.r;\n    #elif defined(MAPBOX_RGB_ELEVATION)\n        vec4 color = texture2D(texture, uv) * (255.0 * 0.1);\n        return\n            -10000.0 +\n            color.r * 256.0 * 256.0 +\n            color.g * 256.0 +\n            color.b;\n    #elif defined(RATP_GEOL_ELEVATION)\n        vec4 val = texture2D(texture, uv);\n        if (val.w > 0.0) {\n            val /= (1.0 - max(1.0, val.w));\n        }\n        val *= zShift;\n        return (val.x + val.y + val.z) - 2000.0;\n    #else\n    return 0.0;\n    #endif\n}\n";
  var ComputeUV = "vec2 computeUv(vec2 uv, vec2 offset, vec2 scale) {\n    return vec2(\n        uv.x * scale.x + offset.x,\n        1.0 - (offset.y + (1.0 - uv.y) * scale.y));\n}\n";
  _three2.ShaderChunk.PrecisionQualifier = PrecisionQualifier;
  _three2.ShaderChunk.GetElevation = GetElevation;
  _three2.ShaderChunk.ComputeUV = ComputeUV;
  var emptyTexture2 = new _three2.Texture();
  var vector4 = new _three2.Vector4(0, 0, 0, 0);
  var UnpackDownscale = 255 / 256;
  function unpack1K(color, factor) {
    var bitSh = new _three2.Vector4(UnpackDownscale / (256 * 256 * 256), UnpackDownscale / (256 * 256), UnpackDownscale / 256, UnpackDownscale);
    return factor ? bitSh.dot(color) * factor : bitSh.dot(color);
  }
  function fillArray(array, remp) {
    for (var i = 0; i < array.length; i++) {
      array[i] = remp;
    }
  }
  var LayeredMaterial$1 = /* @__PURE__ */ function(_RawShaderMaterial) {
    (0, _inherits22.default)(LayeredMaterial2, _RawShaderMaterial);
    var _super = _createSuper2(LayeredMaterial2);
    function LayeredMaterial2() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var segments = arguments.length > 1 ? arguments[1] : void 0;
      var atlasInfo = arguments.length > 2 ? arguments[2] : void 0;
      (0, _classCallCheck22.default)(this, LayeredMaterial2);
      _this = _super.call(this);
      _this.atlasInfo = atlasInfo;
      _this.defines.STITCHING = 1;
      _this.uniforms.segments = new _three2.Uniform(segments);
      if (options.side) {
        _this.side = options.side;
      }
      _this.uniforms.renderingState = new _three2.Uniform(_RendererConstant.default.FINAL);
      _this.defines.TEX_UNITS = 0;
      _this.fragmentShader = TileFS;
      _this.vertexShader = TileVS;
      _this.canvas = document.createElement("canvas");
      _this.canvas.width = atlasInfo.maxX;
      _this.canvas.height = atlasInfo.maxY;
      _this.pendingUpdates = [];
      _this.texturesInfo = {
        color: {
          offsetScale: [],
          originalOffsetScale: [],
          atlasTexture: new _three2.CanvasTexture(_this.canvas),
          parentAtlasTexture: null,
          textures: [],
          opacity: [],
          visible: [],
          colors: []
        },
        elevation: {
          offsetScale: new _three2.Vector4(0, 0, 0, 0),
          texture: emptyTexture2,
          neighbours: {
            offsetScale: Array(4),
            texture: Array(4)
          },
          format: null
        }
      };
      fillArray(_this.texturesInfo.elevation.neighbours.texture, emptyTexture2);
      fillArray(_this.texturesInfo.elevation.neighbours.offsetScale, vector4);
      _this.canvasRevision = 0;
      _this.uniforms.tileDimensions = new _three2.Uniform(new _three2.Vector2());
      _this.uniforms.neighbourdiffLevel = new _three2.Uniform(new _three2.Vector4());
      _this.uniforms.elevationTexture = new _three2.Uniform(_this.texturesInfo.elevation.texture);
      _this.uniforms.elevationOffsetScale = new _three2.Uniform(_this.texturesInfo.elevation.offsetScale);
      _this.uniforms.nTex = new _three2.Uniform(_this.texturesInfo.elevation.neighbours.texture);
      _this.uniforms.nOff = new _three2.Uniform(_this.texturesInfo.elevation.neighbours.offsetScale);
      _this.uniforms.colorTexture = new _three2.Uniform(_this.texturesInfo.color.atlasTexture);
      _this.uniforms.colorOffsetScale = new _three2.Uniform();
      _this.uniforms.colorOpacity = new _three2.Uniform();
      _this.uniforms.colorVisible = new _three2.Uniform();
      _this.uniforms.colors = new _three2.Uniform(_this.texturesInfo.color.colors);
      _this.uniforms.uuid = new _three2.Uniform(0);
      _this.uniforms.noTextureColor = new _three2.Uniform(new _three2.Color());
      _this.uniforms.noTextureOpacity = new _three2.Uniform(1);
      _this.uniforms.opacity = new _three2.Uniform(1);
      _this.colorLayers = [];
      _this.texturesInfo.color.atlasTexture.generateMipmaps = false;
      _this.texturesInfo.color.atlasTexture.magFilter = _three2.LinearFilter;
      _this.texturesInfo.color.atlasTexture.minFilter = _three2.LinearFilter;
      _this.texturesInfo.color.atlasTexture.anisotropy = 1;
      _this.texturesInfo.color.atlasTexture.premultiplyAlpha = true;
      _this.texturesInfo.color.atlasTexture.needsUpdate = false;
      return _this;
    }
    (0, _createClass22.default)(LayeredMaterial2, [{
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
        this.disposed = true;
        this.texturesInfo.color.atlasTexture.dispose();
        this.texturesInfo.elevation.texture.dispose();
      }
    }, {
      key: "getColorTexture",
      value: function getColorTexture(layer) {
        var index = this.indexOfColorLayer(layer);
        if (index === -1) {
          return null;
        }
        return this.texturesInfo.color.textures[index];
      }
    }, {
      key: "setColorTextures",
      value: function setColorTextures(layer, textures, shortcut, view) {
        var _this2 = this;
        if (Array.isArray(textures)) {
          textures = textures[0];
        }
        var index = this.indexOfColorLayer(layer);
        this.texturesInfo.color.originalOffsetScale[index].copy(textures.pitch);
        this.texturesInfo.color.textures[index] = textures.texture;
        if (shortcut) {
          updateOffsetScale(layer.imageSize, this.atlasInfo.atlas[layer.id], this.texturesInfo.color.originalOffsetScale[index], this.uniforms.colorTexture.value.image, this.texturesInfo.color.offsetScale[index]);
          return Promise.resolve();
        }
        this.pendingUpdates.push(layer);
        if (this.setTimeoutId !== null) {
          clearTimeout(this.setTimeoutId);
        }
        this.setTimeoutId = setTimeout(function() {
          if (_this2.uniforms.colorTexture.value !== _this2.texturesInfo.color.atlasTexture) {
            _this2.uniforms.colorTexture.value = _this2.texturesInfo.color.atlasTexture;
            var _iterator = _createForOfIteratorHelper2(_this2.colorLayers), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var l = _step.value;
                if (_this2.pendingUpdates.indexOf(l) === -1) {
                  console.warn("no new texture for ", l.id, ". Redrawing the old one");
                  _this2.pendingUpdates.push(l);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          var _iterator2 = _createForOfIteratorHelper2(_this2.pendingUpdates), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var _l = _step2.value;
              var idx = _this2.indexOfColorLayer(_l);
              var atlas = _this2.atlasInfo.atlas[_l.id];
              updateOffsetScale(_l.imageSize, _this2.atlasInfo.atlas[_l.id], _this2.texturesInfo.color.originalOffsetScale[idx], _this2.uniforms.colorTexture.value.image, _this2.texturesInfo.color.offsetScale[idx]);
              var srcImage = _this2.texturesInfo.color.textures[idx].image;
              _this2.canvasRevision = drawLayerOnCanvas(_l, _this2.texturesInfo.color.atlasTexture, atlas, srcImage === _this2.canvas ? null : srcImage, _this2.texturesInfo.color.offsetScale[idx], _this2.canvasRevision);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          _this2.pendingUpdates.length = 0;
          _this2.texturesInfo.color.atlasTexture.needsUpdate = true;
          if (_this2.visible) {
            view.notifyChange();
          }
          _this2.setTimeoutId = null;
        }, 1);
        return Promise.resolve();
      }
      /**
       * Gets the elevation texture if an elevation layer texture has been loaded in this material.
       *
       * @returns {object|null} Returns the elevation texture or null
       */
    }, {
      key: "getElevationTextureInfo",
      value: function getElevationTextureInfo() {
        if (this.isElevationLayerTextureLoaded()) {
          return {
            texture: this.texturesInfo.elevation.texture,
            offsetScale: this.texturesInfo.elevation.offsetScale,
            elevationFormat: this.texturesInfo.elevation.format,
            heightFieldScale: this.texturesInfo.elevation.heightFieldScale,
            heightFieldOffset: this.texturesInfo.elevation.heightFieldOffset
          };
        }
        return null;
      }
    }, {
      key: "setElevationTexture",
      value: function setElevationTexture(layer, textureAndPitch) {
        if (layer.elevationFormat === _DEMUtils.ELEVATION_FORMAT.MAPBOX_RGB) {
          if (!this.defines.MAPBOX_RGB_ELEVATION) {
            this.defines.MAPBOX_RGB_ELEVATION = 1;
            this.needsUpdate = true;
          }
        } else if (layer.elevationFormat === _DEMUtils.ELEVATION_FORMAT.HEIGHFIELD) {
          if (!this.defines.HEIGHTFIELD_ELEVATION) {
            this.defines.HEIGHTFIELD_ELEVATION = 1;
            var heightFieldOffset = layer.heightFieldOffset || 0;
            this.texturesInfo.elevation.heightFieldOffset = heightFieldOffset;
            this.uniforms.heightFieldOffset = new _three2.Uniform(heightFieldOffset);
            var heightFieldScale = layer.heightFieldScale || 255;
            this.texturesInfo.elevation.heightFieldScale = heightFieldScale;
            this.uniforms.heightFieldScale = new _three2.Uniform(heightFieldScale);
            this.needsUpdate = true;
          }
        } else if (layer.elevationFormat === _DEMUtils.ELEVATION_FORMAT.RATP_GEOL) {
          if (!this.defines.RATP_GEOL_ELEVATION) {
            this.defines.RATP_GEOL_ELEVATION = 1;
          }
        } else {
          throw new Error("Missing layer.elevationFormat handling", layer.elevationFormat);
        }
        this.uniforms.elevationTexture.value = textureAndPitch.texture;
        this.texturesInfo.elevation.texture = textureAndPitch.texture;
        this.texturesInfo.elevation.offsetScale.copy(textureAndPitch.pitch);
        this.texturesInfo.elevation.format = layer.elevationFormat;
        return Promise.resolve(true);
      }
    }, {
      key: "pushLayer",
      value: function pushLayer(newLayer) {
        this.texturesInfo.color.opacity.push(newLayer.opacity);
        this.texturesInfo.color.visible.push(newLayer.visible);
        this.texturesInfo.color.offsetScale.push(new _three2.Vector4(0, 0, 0, 0));
        this.texturesInfo.color.originalOffsetScale.push(new _three2.Vector4(0, 0, 0, 0));
        this.texturesInfo.color.textures.push(emptyTexture2);
        this.texturesInfo.color.colors.push(newLayer.color || new _three2.Color(1, 1, 1));
        this.colorLayers.push(newLayer);
        if (this.colorLayers.length === 1) {
          this.uniforms.colorOffsetScale = new _three2.Uniform(this.texturesInfo.color.offsetScale);
          this.uniforms.colorOpacity = new _three2.Uniform(this.texturesInfo.color.opacity);
          this.uniforms.colorVisible = new _three2.Uniform(this.texturesInfo.color.visible);
        }
        this.defines.TEX_UNITS = this.colorLayers.length;
        this.needsUpdate = true;
      }
    }, {
      key: "removeLayer",
      value: function removeLayer(layer) {
        var index = this.indexOfColorLayer(layer);
        if (index === -1) {
          console.warn("Layer ".concat(layer.id, " not found, so not removed..."));
          return;
        }
        this.texturesInfo.color.opacity.splice(index, 1);
        this.texturesInfo.color.visible.splice(index, 1);
        this.texturesInfo.color.offsetScale.splice(index, 1);
        this.texturesInfo.color.originalOffsetScale.splice(index, 1);
        this.texturesInfo.color.textures.splice(index, 1);
        this.texturesInfo.color.colors.splice(index, 1);
        this.colorLayers.splice(index, 1);
        this.defines.TEX_UNITS = this.colorLayers.length;
        this.needsUpdate = true;
      }
    }, {
      key: "update",
      value: function update() {
        if (this.colorLayers.length === 0) {
          return true;
        }
        if (this.atlasInfo.maxX > this.canvas.width || this.atlasInfo.maxY > this.canvas.height) {
          var newCanvas = document.createElement("canvas");
          newCanvas.width = this.atlasInfo.maxX;
          newCanvas.height = this.atlasInfo.maxY;
          if (this.canvas.width > 0) {
            var ctx = newCanvas.getContext("2d");
            ctx.drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height);
          }
          this.texturesInfo.color.atlasTexture.dispose();
          this.texturesInfo.color.atlasTexture = new _three2.CanvasTexture(newCanvas);
          this.texturesInfo.color.atlasTexture.magFilter = _three2.LinearFilter;
          this.texturesInfo.color.atlasTexture.minFilter = _three2.LinearFilter;
          this.texturesInfo.color.atlasTexture.anisotropy = 1;
          this.texturesInfo.color.atlasTexture.premultiplyAlpha = true;
          this.texturesInfo.color.atlasTexture.needsUpdate = true;
          for (var i = 0; i < this.colorLayers.length; i++) {
            var layer = this.colorLayers[i];
            var atlas = this.atlasInfo.atlas[layer.id];
            var pitch = this.texturesInfo.color.originalOffsetScale[i];
            var xRatio = layer.imageSize.w / newCanvas.width;
            var yRatio = layer.imageSize.h / newCanvas.height;
            this.texturesInfo.color.offsetScale[i] = new _three2.Vector4(atlas.x / newCanvas.width + pitch.x * xRatio, (atlas.y + atlas.offset) / newCanvas.height + pitch.y * yRatio, pitch.z * xRatio, pitch.w * yRatio);
          }
          this.canvas = newCanvas;
          this.uniforms.colorTexture.value = this.texturesInfo.color.atlasTexture;
        }
        return this.canvas.width > 0;
      }
    }, {
      key: "indexOfColorLayer",
      value: function indexOfColorLayer(layer) {
        return this.colorLayers.indexOf(layer);
      }
    }, {
      key: "setLayerOpacity",
      value: function setLayerOpacity(layer, opacity) {
        var index = Number.isInteger(layer) ? layer : this.indexOfColorLayer(layer);
        this.texturesInfo.color.opacity[index] = opacity;
      }
    }, {
      key: "setLayerVisibility",
      value: function setLayerVisibility(layer, visible) {
        var index = Number.isInteger(layer) ? layer : this.indexOfColorLayer(layer);
        this.texturesInfo.color.visible[index] = visible;
      }
    }, {
      key: "isElevationLayerTextureLoaded",
      value: function isElevationLayerTextureLoaded() {
        return this.texturesInfo.elevation.texture !== emptyTexture2;
      }
    }, {
      key: "isColorLayerTextureLoaded",
      value: function isColorLayerTextureLoaded(layer) {
        var index = this.indexOfColorLayer(layer);
        if (index < 0) {
          return null;
        }
        return this.texturesInfo.color.textures[index] !== emptyTexture2;
      }
    }, {
      key: "setUuid",
      value: function setUuid(uuid) {
        this.uniforms.uuid.value = uuid;
      }
    }]);
    return LayeredMaterial2;
  }(_three2.RawShaderMaterial);
  function drawLayerOnCanvas(layer, atlasTexture, atlasInfo, image, interest, revision) {
    var canvas = atlasTexture.image;
    var ctx = canvas.getContext("2d");
    if (image !== void 0 && layer.transparent) {
      ctx.clearRect(atlasInfo.x, atlasInfo.y, layer.imageSize.w, layer.imageSize.h + 2 * atlasInfo.offset);
    }
    if (image) {
      ctx.drawImage(image, atlasInfo.x, atlasInfo.y + atlasInfo.offset, layer.imageSize.w, layer.imageSize.h);
      if (atlasInfo.offset) {
        ctx.drawImage(image, 0, 0, layer.imageSize.w, atlasInfo.offset, atlasInfo.x, atlasInfo.y, layer.imageSize.w, atlasInfo.offset);
        ctx.drawImage(image, 0, layer.imageSize.h - 1 - atlasInfo.offset, layer.imageSize.w, atlasInfo.offset, atlasInfo.x, atlasInfo.y + layer.imageSize.h + atlasInfo.offset, layer.imageSize.w, atlasInfo.offset);
      }
    }
    atlasTexture.needsUpdate = true;
    return revision + 1;
  }
  function updateOffsetScale(imageSize, atlas, originalOffsetScale, canvas, target) {
    if (originalOffsetScale.z === 0 || originalOffsetScale.w === 0) {
      target.set(0, 0, 0, 0);
      return;
    }
    var xRatio = imageSize.w / canvas.width;
    var yRatio = imageSize.h / canvas.height;
    target.set(atlas.x / canvas.width + originalOffsetScale.x * xRatio, (atlas.y + atlas.offset) / canvas.height + originalOffsetScale.y * yRatio, originalOffsetScale.z * xRatio, originalOffsetScale.w * yRatio);
  }
  function initDebugTool(view) {
    var div = document.createElement("div");
    div.style.top = "0";
    div.style.right = "0";
    div.style.width = "100%";
    div.style.position = "absolute";
    div.style.backgroundColor = "lightgray";
    document.getElementById("viewerDiv").appendChild(div);
    document.addEventListener("click", function(evt) {
      var r = view.tileLayer.pickObjectsAt(view, view.eventToViewCoords(evt), 1);
      if (!r.length)
        return;
      var obj = r[0].object;
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
      if (obj.material.canvas) {
        obj.material.uniforms.colorTexture.value.image.style.width = "100%";
        div.appendChild(obj.material.uniforms.colorTexture.value.image);
        obj.material.canvas.style.width = "100%";
        div.appendChild(obj.material.canvas);
      }
    });
  }
  var _default2 = LayeredMaterial$1;
  LayeredMaterial.default = _default2;
  return LayeredMaterial;
}
var hasRequiredPicking;
function requirePicking() {
  if (hasRequiredPicking)
    return Picking;
  hasRequiredPicking = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Picking, "__esModule", {
    value: true
  });
  Picking.default = void 0;
  var _three2 = require$$8$1;
  var _TileMesh = _interopRequireDefault2(requireTileMesh());
  var _RendererConstant = _interopRequireDefault2(requireRendererConstant());
  var _LayeredMaterial = requireLayeredMaterial();
  var _Coordinates = _interopRequireDefault2(requireCoordinates());
  var _DEMUtils = _interopRequireDefault2(requireDEMUtils());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function hideEverythingElse(view) {
    var threejsLayer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var prev = view.camera.camera3D.layers.mask;
    view.camera.camera3D.layers.mask = 1 << threejsLayer;
    return function() {
      view.camera.camera3D.layers.mask = prev;
    };
  }
  function unpackHalfRGBA(v, target) {
    if (!target || !target.isVector2) {
      target = new _three2.Vector2();
    }
    return target.set(v.x + v.y / 255, v.z + v.w / 255);
  }
  var depthRGBA = new _three2.Vector4();
  function screenCoordsToNodeId(view, tileLayer, viewCoords, radius) {
    var dim = view.mainLoop.gfxEngine.getWindowSize();
    viewCoords = viewCoords || new _three2.Vector2(Math.floor(dim.x / 2), Math.floor(dim.y / 2));
    var restore = tileLayer.level0Nodes.map(function(n) {
      return n.pushRenderState(_RendererConstant.default.ID);
    });
    var undoHide = hideEverythingElse(view, tileLayer.object3d, tileLayer.threejsLayer);
    var buffer2 = view.mainLoop.gfxEngine.renderViewToBuffer({
      camera: view.camera,
      scene: tileLayer.object3d
    }, {
      x: viewCoords.x - radius,
      y: viewCoords.y - radius,
      width: 1 + radius * 2,
      height: 1 + radius * 2
    });
    undoHide();
    restore.forEach(function(r) {
      return r();
    });
    var ids = [];
    traversePickingCircle(radius, function(x, y, idx) {
      var data = buffer2.slice(idx * 4, idx * 4 + 4);
      depthRGBA.fromArray(data).divideScalar(255);
      var unpack = (0, _LayeredMaterial.unpack1K)(depthRGBA, Math.pow(256, 3));
      var _id2 = Math.round(unpack);
      if (ids.indexOf(_id2) < 0) {
        ids.push(_id2);
      }
    });
    return ids;
  }
  function traversePickingCircle(radius, callback) {
    var prevSq;
    for (var r = 0; r <= radius; r++) {
      var sq = r * r;
      for (var x = -r; x <= r; x++) {
        var sqx = x * x;
        for (var y = -r; y <= r; y++) {
          var dist = sqx + y * y;
          if (dist > sq) {
            continue;
          }
          if (dist <= prevSq) {
            continue;
          }
          var realX = radius + x;
          var realY = radius + y;
          if (callback(realX, realY, realY * (2 * radius) + realX) === false) {
            return;
          }
        }
      }
      prevSq = sq;
    }
  }
  function findLayerInParent(obj) {
    if (obj.layer) {
      return obj.layer;
    }
    if (obj.parent) {
      return findLayerInParent(obj.parent);
    }
    return null;
  }
  var raycaster = new _three2.Raycaster();
  var tmpCoords = new _Coordinates.default("EPSG:3857", 0, 0, 0);
  var tmpColor = new _three2.Color();
  var _default2 = {
    pickTilesAt: function pickTilesAt(_instance, viewCoords, radius, layer) {
      var results = [];
      var _ids = screenCoordsToNodeId(_instance, layer, viewCoords, radius);
      var extractResult = function(node) {
        if (_ids.indexOf(node.id) >= 0 && node instanceof _TileMesh.default) {
          var restore = node.pushRenderState(_RendererConstant.default.UV);
          var buffer2 = _instance.mainLoop.gfxEngine.renderViewToBuffer({
            camera: _instance.camera,
            scene: node
          }, {
            x: Math.max(0, viewCoords.x - radius),
            y: Math.max(0, viewCoords.y - radius),
            width: 1 + radius * 2,
            height: 1 + radius * 2
          });
          var uvs = [];
          traversePickingCircle(radius, function(x, y, idx) {
            var data = buffer2.slice(idx * 4, idx * 4 + 4);
            depthRGBA.fromArray(data).divideScalar(255);
            uvs.push(unpackHalfRGBA(depthRGBA));
          });
          for (var _i = 0, _uvs = uvs; _i < _uvs.length; _i++) {
            var uv = _uvs[_i];
            tmpCoords.set(
              layer.extent.crs(),
              // TODO this looks a lot like PlanarTileBuilder.uProjecte
              node.extent.west() + uv.x * (node.extent.east() - node.extent.west()),
              node.extent.south() + uv.y * (node.extent.north() - node.extent.south()),
              0
            );
            var result = _DEMUtils.default.getElevationValueAt(layer, tmpCoords, _DEMUtils.default.FAST_READ_Z, [node]);
            if (result) {
              tmpCoords._values[2] = result.z;
              var coord = tmpCoords.as(_instance.referenceCrs, new _Coordinates.default(_instance.referenceCrs));
              var point = tmpCoords.xyz(new _three2.Vector3());
              results.push({
                object: node,
                layer,
                point,
                coord,
                distance: _instance.camera.camera3D.position.distanceTo(point)
              });
            }
          }
          restore();
        }
      };
      var _iterator = _createForOfIteratorHelper2(layer.level0Nodes), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var n = _step.value;
          n.traverse(extractResult);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return results;
    },
    pickPointsAt: function pickPointsAt(view, viewCoords, radius, layer, filter) {
      radius = Math.floor(radius);
      var visibleId = 1;
      layer.object3d.traverse(function(o) {
        if (o.isPoints && o.visible && o.material.visible && o.material.enablePicking) {
          o.material.enablePicking(visibleId++);
          if (visibleId === 1 << 12) {
            console.warn("Too much visible point instance. The next one won't be pickable");
          }
        }
      });
      var undoHide = hideEverythingElse(view, layer.object3d, layer.threejsLayer);
      var buffer2 = view.mainLoop.gfxEngine.renderViewToBuffer({
        camera: view.camera,
        scene: layer.object3d
      }, {
        x: Math.max(0, viewCoords.x - radius),
        y: Math.max(0, viewCoords.y - radius),
        width: 1 + radius * 2,
        height: 1 + radius * 2
      });
      undoHide();
      var candidates = [];
      traversePickingCircle(radius, function(x, y, idx) {
        var coord = {
          x: x + viewCoords.x,
          y: y + viewCoords.y,
          z: 0
        };
        if (filter && !filter(coord)) {
          return;
        }
        if (idx * 4 < 0 || (idx + 1) * 4 > buffer2.length) {
          console.error("azadaz");
        }
        var data = buffer2.slice(idx * 4, idx * 4 + 4);
        if (data[0] === 255 && data[1] === 255) {
          return;
        }
        var pickingId = data[0] + ((data[1] & 240) << 4);
        if (pickingId > visibleId) {
          console.warn("weird: pickingId (".concat(pickingId, ") > visibleId (").concat(visibleId, ")"));
        }
        var index = ((data[1] & 15) << 16) + (data[2] << 8) + data[3];
        var r = {
          pickingId,
          index,
          coord
        };
        for (var i = 0; i < candidates.length; i++) {
          if (candidates[i].pickingId === r.pickingId && candidates[i].index === r.index) {
            return;
          }
        }
        candidates.push(r);
      });
      var result = [];
      layer.object3d.traverse(function(o) {
        if (o.isPoints && o.visible && o.material.visible) {
          for (var i = 0; i < candidates.length; i++) {
            if (candidates[i].pickingId === o.material.pickingId) {
              var position = new _three2.Vector3().fromArray(o.geometry.attributes.position.array, 3 * candidates[i].index).applyMatrix4(o.matrixWorld);
              result.push({
                object: o,
                index: candidates[i].index,
                layer,
                point: position,
                coord: candidates[i].coord,
                distance: view.camera.camera3D.position.distanceTo(position)
              });
            }
          }
          o.material.enablePicking(0);
        }
      });
      return result;
    },
    /*
     * Default picking method. Uses Raycaster
     */
    pickObjectsAt: function pickObjectsAt(view, viewCoords, radius, object) {
      var target = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
      var zone = {
        x: viewCoords.x - radius,
        y: viewCoords.y - radius,
        width: 1 + radius * 2,
        height: 1 + radius * 2
      };
      var pixels = view.mainLoop.gfxEngine.renderViewToBuffer({
        scene: object,
        camera: view.camera
      }, zone);
      var clearColor = view.mainLoop.gfxEngine.renderer.getClearColor(tmpColor);
      var clearR = Math.round(255 * clearColor.r);
      var clearG = Math.round(255 * clearColor.g);
      var clearB = Math.round(255 * clearColor.b);
      var normalized = view.viewToNormalizedCoords(viewCoords);
      var tmp2 = normalized.clone();
      traversePickingCircle(radius, function(x, y) {
        var offset = ((y + radius) * (radius * 2 + 1) + (x + radius)) * 4;
        var r = pixels[offset];
        var g = pixels[offset + 1];
        var b = pixels[offset + 2];
        if (Math.abs(clearR - r) <= 1 && Math.abs(clearG - g) <= 1 && Math.abs(clearB - b) <= 1) {
          return null;
        }
        tmp2.setX(normalized.x + x / view.camera.width).setY(normalized.y + y / view.camera.height);
        raycaster.setFromCamera(tmp2, view.camera.camera3D);
        var intersects2 = raycaster.intersectObject(object, true);
        var _iterator2 = _createForOfIteratorHelper2(intersects2), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var inter = _step2.value;
            inter.layer = findLayerInParent(inter.object);
            target.push(inter);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return target.length === 0;
      });
      return target;
    },
    preparePointGeometryForPicking: function preparePointGeometryForPicking(pointsGeometry) {
      var numPoints = pointsGeometry.attributes.position.count;
      if (numPoints >= 1 << 20) {
        console.warn("picking issue: only ".concat(1 << 20, " points per Points object supported"));
      }
      var ids = new Uint8Array(4 * numPoints);
      for (var i = 0; i < numPoints; i++) {
        ids[4 * i + 0] = 0;
        ids[4 * i + 1] = (i & 983040) >> 16;
        ids[4 * i + 2] = (i & 65280) >> 8;
        ids[4 * i + 3] = (i & 255) >> 0;
      }
      pointsGeometry.setAttribute("unique_id", new _three2.BufferAttribute(ids, 4, true));
    }
  };
  Picking.default = _default2;
  return Picking;
}
var AtlasBuilder = {};
var Packer = {};
var hasRequiredPacker;
function requirePacker() {
  if (hasRequiredPacker)
    return Packer;
  hasRequiredPacker = 1;
  Object.defineProperty(Packer, "__esModule", {
    value: true
  });
  Packer.default = void 0;
  var _three2 = require$$8$1;
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function fit(blocks, w, h, previousRoot) {
    var root = previousRoot || {
      x: 0,
      y: 0,
      w,
      h
    };
    var maxX = 0;
    var maxY = 0;
    var _iterator = _createForOfIteratorHelper2(blocks), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var block = _step.value;
        var node = _findNode(root, block.w, block.h);
        if (node) {
          block.fit = _splitNode(node, block.w, block.h);
          maxX = Math.max(maxX, node.x + block.w);
          maxY = Math.max(maxY, node.y + block.h);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (!_three2.MathUtils.isPowerOfTwo(maxX)) {
      maxX = _three2.MathUtils.ceilPowerOfTwo(maxX);
    }
    if (!_three2.MathUtils.isPowerOfTwo(maxY)) {
      maxY = _three2.MathUtils.ceilPowerOfTwo(maxY);
    }
    return {
      maxX,
      maxY
    };
  }
  function _findNode(root, w, h) {
    if (root.used) {
      return _findNode(root.right, w, h) || _findNode(root.down, w, h);
    }
    if (w <= root.w && h <= root.h) {
      return root;
    }
    return null;
  }
  function _splitNode(node, w, h) {
    node.used = true;
    node.down = {
      x: node.x,
      y: node.y + h,
      w: node.w,
      h: node.h - h
    };
    node.right = {
      x: node.x + w,
      y: node.y,
      w: node.w - w,
      h
    };
    return node;
  }
  var _default2 = fit;
  Packer.default = _default2;
  return Packer;
}
var hasRequiredAtlasBuilder;
function requireAtlasBuilder() {
  if (hasRequiredAtlasBuilder)
    return AtlasBuilder;
  hasRequiredAtlasBuilder = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(AtlasBuilder, "__esModule", {
    value: true
  });
  AtlasBuilder.default = void 0;
  var _Packer = _interopRequireDefault2(requirePacker());
  var _default2 = {
    pack: function pack(maxSize, layerIds, imageSizes, oldAtlas) {
      maxSize = 2048;
      var colorBleedHalfOffset = 0;
      var blocks = [];
      for (var i = 0; i < imageSizes.length; i++) {
        if (oldAtlas && layerIds[i] in oldAtlas) {
          continue;
        }
        var sWidth = imageSizes[i].w;
        var sHeight = imageSizes[i].h;
        blocks.push({
          layerId: layerIds[i],
          w: Math.min(maxSize, sWidth),
          h: Math.min(maxSize, sHeight + 2 * colorBleedHalfOffset)
        });
      }
      blocks.sort(function(a, b) {
        return Math.max(a.w, a.h) < Math.max(b.w, b.h);
      });
      var previousRoot;
      if (oldAtlas) {
        for (var _i = 0, _Object$keys = Object.keys(oldAtlas); _i < _Object$keys.length; _i++) {
          var k = _Object$keys[_i];
          var fitResult = oldAtlas[k];
          if (fitResult.x === 0 && fitResult.y === 0) {
            previousRoot = fitResult;
            break;
          }
        }
      }
      if (oldAtlas && !previousRoot) {
        console.error("UH: oldAtlas is defined, but not previousRoot");
      }
      var _fit = (0, _Packer.default)(blocks, maxSize, maxSize, previousRoot), maxX = _fit.maxX, maxY = _fit.maxY;
      var atlas = oldAtlas || {};
      for (var i = 0; i < blocks.length; i++) {
        atlas[blocks[i].layerId] = blocks[i].fit;
        atlas[blocks[i].layerId].offset = colorBleedHalfOffset;
      }
      return {
        atlas,
        maxX,
        maxY
      };
    }
  };
  AtlasBuilder.default = _default2;
  return AtlasBuilder;
}
var Capabilities = {};
var hasRequiredCapabilities;
function requireCapabilities() {
  if (hasRequiredCapabilities)
    return Capabilities;
  hasRequiredCapabilities = 1;
  Object.defineProperty(Capabilities, "__esModule", {
    value: true
  });
  Capabilities.default = void 0;
  var SampleTestFS = "uniform sampler2D uni[SAMPLE];\nvoid main() {\n    gl_FragColor += texture2D(uni[SAMPLE-1], vec2(0));\n}";
  var SampleTestVS = "void main() {\n    gl_Position = vec4( 0.0, 0.0, 0.0, 1.0 );\n}";
  var logDepthBufferSupported = false;
  var maxTexturesUnits = 8;
  var maxTextureSize;
  function _WebGLShader(renderer, type, string) {
    var gl = renderer.getContext();
    var shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  function isFirefox() {
    return navigator && navigator.userAgent && navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  }
  var _default2 = {
    isLogDepthBufferSupported: function isLogDepthBufferSupported() {
      return logDepthBufferSupported;
    },
    isFirefox,
    isInternetExplorer: function isInternetExplorer() {
      var internetExplorer = !!document.documentMode;
      return internetExplorer;
    },
    getMaxTextureUnitsCount: function getMaxTextureUnitsCount() {
      return maxTexturesUnits;
    },
    getMaxTextureSize: function getMaxTextureSize() {
      return maxTextureSize;
    },
    updateCapabilities: function updateCapabilities(renderer) {
      var gl = renderer.getContext();
      maxTexturesUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      var program = gl.createProgram();
      var glVertexShader = _WebGLShader(renderer, gl.VERTEX_SHADER, SampleTestVS);
      var fragmentShader = "#define SAMPLE ".concat(maxTexturesUnits, "\n");
      fragmentShader += SampleTestFS;
      var glFragmentShader = _WebGLShader(renderer, gl.FRAGMENT_SHADER, fragmentShader);
      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);
      gl.linkProgram(program);
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        if (maxTexturesUnits > 16) {
          var info = gl.getProgramInfoLog(program);
          console.warn("".concat(info, ": using a maximum of 16 texture units instead of the reported value (").concat(maxTexturesUnits, ")"));
          if (isFirefox()) {
            console.warn("It can come from a Mesa/Firefox bug;\n                        the shader compiles to an error when using more than 16 sampler uniforms,\n                        see https://bugzilla.mozilla.org/show_bug.cgi?id=777028");
          }
          maxTexturesUnits = 16;
        } else {
          throw new Error("The GPU capabilities could not be determined accurately.\n                    Impossible to link a shader with the Maximum texture units ".concat(maxTexturesUnits));
        }
      }
      gl.deleteProgram(program);
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      logDepthBufferSupported = renderer.capabilities.logarithmicDepthBuffer;
    }
  };
  Capabilities.default = _default2;
  return Capabilities;
}
var Entity = {};
var hasRequiredEntity;
function requireEntity() {
  if (hasRequiredEntity)
    return Entity;
  hasRequiredEntity = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Entity, "__esModule", {
    value: true
  });
  Entity.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var Entity$1 = /* @__PURE__ */ function() {
    function Entity2(id) {
      (0, _classCallCheck22.default)(this, Entity2);
      if (!id) {
        throw new Error("Missing id parameter (Entity must have a unique id defined)");
      }
      Object.defineProperty(this, "id", {
        value: id,
        writable: false
      });
    }
    (0, _createClass22.default)(Entity2, [{
      key: "preUpdate",
      value: function preUpdate() {
        return null;
      }
      /**
       * Performs an update on an _element_ of the entity.
       *
       * Note: this method will be called for each element returned by `preUpdate()`.
       *
       * @api
       * @param {module:Core/Context~Context} context the update context.
       * This is the same object that the entity whose `update()` is being called.
       * @param {object} element the element to update.
       * This is one of the elements returned by
       * {@link module:entities/Entity~Entity#preUpdate preUpdate()}.
       */
    }, {
      key: "update",
      value: function update() {
      }
      /**
       * Method called after {@link module:entities/Entity~Entity#update update()}.
       *
       * @api
       * @param {module:Core/Context~Context} context the update context.
       * @param {Array<object>} changeSources the objects that triggered an update step.
       * This is useful to filter out unnecessary updates if no sources are
       * relevant to this entity. For example, if one of the sources is a
       * camera that moved during the previous frame, any entity that depends
       * on the camera's field of view should be updated.
       */
    }, {
      key: "postUpdate",
      value: function postUpdate() {
      }
    }]);
    return Entity2;
  }();
  var _default2 = Entity$1;
  Entity.default = _default2;
  return Entity;
}
var eventDispatcher = {};
var hasRequiredEventDispatcher;
function requireEventDispatcher() {
  if (hasRequiredEventDispatcher)
    return eventDispatcher;
  hasRequiredEventDispatcher = 1;
  Object.defineProperty(eventDispatcher, "__esModule", {
    value: true
  });
  eventDispatcher.default = void 0;
  var _three2 = require$$8$1;
  var eventDispatcher$1 = {
    dispatchEvent: _three2.EventDispatcher.prototype.dispatchEvent,
    addEventListener: _three2.EventDispatcher.prototype.addEventListener,
    hasEventListener: _three2.EventDispatcher.prototype.hasEventListener,
    removeEventListener: _three2.EventDispatcher.prototype.removeEventListener
  };
  var _default2 = eventDispatcher$1;
  eventDispatcher.default = _default2;
  return eventDispatcher;
}
var hasRequiredEntity3D;
function requireEntity3D() {
  if (hasRequiredEntity3D)
    return Entity3D;
  hasRequiredEntity3D = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Entity3D, "__esModule", {
    value: true
  });
  Entity3D.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _assertThisInitialized22 = _interopRequireDefault2(requireAssertThisInitialized());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  var _Layer2 = requireLayer();
  var _ColorLayer = _interopRequireDefault2(requireColorLayer());
  var _Picking2 = _interopRequireDefault2(requirePicking());
  var _AtlasBuilder = _interopRequireDefault2(requireAtlasBuilder());
  var _Capabilities = _interopRequireDefault2(requireCapabilities());
  var _Entity2 = _interopRequireDefault2(requireEntity());
  var _eventDispatcher = _interopRequireDefault2(requireEventDispatcher());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Entity3D$1 = /* @__PURE__ */ function(_Entity) {
    (0, _inherits22.default)(Entity3D2, _Entity);
    var _super = _createSuper2(Entity3D2);
    function Entity3D2(id, object3d) {
      var _this;
      (0, _classCallCheck22.default)(this, Entity3D2);
      _this = _super.call(this, id);
      if (!object3d || !object3d.isObject3D) {
        throw new Error("Missing/Invalid object3d parameter (must be a three.js Object3D instance)");
      }
      _this._attachedLayers = [];
      _this._instance = null;
      if (object3d && object3d.type === "Group" && object3d.name === "") {
        object3d.name = id;
      }
      _this.type = "geometry";
      Object.defineProperty((0, _assertThisInitialized22.default)(_this), "object3d", {
        value: object3d,
        writable: false
      });
      var changeOpacity = function(o) {
        if (o.material) {
          if (o.material.opacity != null) {
            o.material.transparent = _this.noTextureOpacity < 1 || _this.opacity < 1;
            o.material.opacity = _this.opacity;
          }
          if (o.material.uniforms && o.material.uniforms.opacity != null) {
            o.material.transparent = _this.noTextureOpacity < 1 || _this.opacity < 1;
            o.material.uniforms.opacity.value = _this.opacity;
          }
          o.material.depthWrite = !o.material.transparent;
        }
      };
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "opacity", 1, function() {
        if (_this.object3d) {
          _this.object3d.traverse(function(o) {
            if (o.layer !== (0, _assertThisInitialized22.default)(_this)) {
              return;
            }
            changeOpacity(o);
            if (o.content) {
              o.content.traverse(changeOpacity);
            }
          });
        }
      });
      var changeNoTextureColor = function(o) {
        if (o.material) {
          if (o.material.noTextureColor) {
            o.material.noTextureColor.value.copy(_this.noTextureColor);
          }
          if (o.material.uniforms && o.material.uniforms.noTextureColor) {
            o.material.uniforms.noTextureColor.value.copy(_this.noTextureColor);
          }
          o.material.depthWrite = !o.material.transparent;
        }
      };
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "noTextureColor", new _three2.Color(0.04, 0.23, 0.35), function() {
        if (_this.object3d) {
          _this.object3d.traverse(function(o) {
            if (o.layer !== (0, _assertThisInitialized22.default)(_this)) {
              return;
            }
            changeNoTextureColor(o);
            if (o.content) {
              o.content.traverse(changeNoTextureColor);
            }
          });
        }
      });
      var changeNoTextureOpacity = function(o) {
        if (o.material) {
          if (o.material.noTextureOpacity != null) {
            o.material.transparent = _this.noTextureOpacity < 1 || _this.opacity < 1;
            o.material.noTextureOpacity = _this.noTextureOpacity;
          }
          if (o.material.uniforms && o.material.uniforms.noTextureOpacity != null) {
            o.material.transparent = _this.noTextureOpacity < 1 || _this.opacity < 1;
            o.material.uniforms.noTextureOpacity.value = _this.noTextureOpacity;
          }
          o.material.depthWrite = !o.material.transparent;
        }
      };
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "noTextureOpacity", 1, function() {
        if (_this.object3d) {
          _this.object3d.traverse(function(o) {
            if (o.layer !== (0, _assertThisInitialized22.default)(_this)) {
              return;
            }
            changeNoTextureOpacity(o);
            if (o.content) {
              o.content.traverse(changeNoTextureOpacity);
            }
          });
        }
      });
      _this.atlasInfo = {
        maxX: 0,
        maxY: 0
      };
      _this.getObjectToUpdateForAttachedLayers = function(obj) {
        if (!obj.parent || !obj.material) {
          return null;
        }
        return {
          element: obj,
          parent: obj.parent
        };
      };
      _this._distance = {
        min: Infinity,
        max: 0
      };
      return _this;
    }
    (0, _createClass22.default)(Entity3D2, [{
      key: "pickObjectsAt",
      value: function pickObjectsAt(instance, coordinates, radius) {
        return _Picking2.default.pickObjectsAt(instance, coordinates, radius, this.object3d);
      }
    }, {
      key: "attach",
      value: function attach(layer) {
        if (!layer.update) {
          throw new Error("Missing 'update' function -> can't attach layer ".concat(layer.id));
        }
        layer = layer._preprocessLayer(this, this._instance);
        this._attachedLayers.push(layer);
        if (layer instanceof _ColorLayer.default) {
          var colorLayers = this._attachedLayers.filter(function(l) {
            return l instanceof _ColorLayer.default;
          });
          var _AtlasBuilder$pack = _AtlasBuilder.default.pack(_Capabilities.default.getMaxTextureSize(), colorLayers.map(function(l) {
            return l.id;
          }), colorLayers.map(function(l) {
            return l.imageSize;
          }), this.atlasInfo.atlas), atlas = _AtlasBuilder$pack.atlas, maxX = _AtlasBuilder$pack.maxX, maxY = _AtlasBuilder$pack.maxY;
          this.atlasInfo.atlas = atlas;
          this.atlasInfo.maxX = Math.max(this.atlasInfo.maxX, maxX);
          this.atlasInfo.maxY = Math.max(this.atlasInfo.maxY, maxY);
        }
      }
    }, {
      key: "detach",
      value: function detach(layer) {
        var count = this._attachedLayers.length;
        this._attachedLayers = this._attachedLayers.filter(function(attached) {
          return attached.id !== layer.id;
        });
        return this._attachedLayers.length < count;
      }
      /**
       * Get all the layers attached to this object.
       *
       * @param {function(module:Core/Layer~Layer):boolean} filter
       * Optional filter function for attached layers
       * @returns {Array<module:Core/Layer~Layer>} the layers attached to this object
       */
    }, {
      key: "getLayers",
      value: function getLayers(filter) {
        var result = [];
        var _iterator = _createForOfIteratorHelper2(this._attachedLayers), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var attached = _step.value;
            if (!filter || filter(attached)) {
              result.push(attached);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return result;
      }
    }]);
    return Entity3D2;
  }(_Entity2.default);
  Object.assign(Entity3D$1.prototype, _eventDispatcher.default);
  var _default2 = Entity3D$1;
  Entity3D.default = _default2;
  return Entity3D;
}
var Context = {};
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext)
    return Context;
  hasRequiredContext = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Context, "__esModule", {
    value: true
  });
  Context.default = void 0;
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _three2 = require$$8$1;
  var Context$1 = /* @__PURE__ */ (0, _createClass22.default)(
    /**
     * Constructs a context.
     *
     * @param {module:Renderer/Camera~Camera} camera the active camera.
     * @param {module:Core/Scheduler/Scheduler~Scheduler} scheduler the scheduler.
     * @param {module:Core/Instance~Instance} instance the giro3d instance.
     * @api
     */
    function Context2(camera, scheduler, instance) {
      (0, _classCallCheck22.default)(this, Context2);
      this.camera = camera;
      this.scheduler = scheduler;
      this.instance = instance;
      this.distance = {
        plane: new _three2.Plane().setFromNormalAndCoplanarPoint(
          camera.camera3D.getWorldDirection(new _three2.Vector3()),
          camera.camera3D.position
          /* TODO matrixWorld */
        ),
        min: Infinity,
        max: 0
      };
      this.fastUpdateHint = void 0;
    }
  );
  var _default2 = Context$1;
  Context.default = _default2;
  return Context;
}
var hasRequiredMainLoop;
function requireMainLoop() {
  if (hasRequiredMainLoop)
    return MainLoop;
  hasRequiredMainLoop = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(MainLoop, "__esModule", {
    value: true
  });
  MainLoop.default = MainLoop.RENDERING_SCHEDULED = MainLoop.RENDERING_PAUSED = MainLoop.MAIN_LOOP_EVENTS = void 0;
  var _three2 = require$$8$1;
  var _Layer2 = _interopRequireDefault2(requireLayer());
  var _Entity3D3 = _interopRequireDefault2(requireEntity3D());
  var _Cache = _interopRequireDefault2(requireCache());
  var _Context = _interopRequireDefault2(requireContext());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var RENDERING_PAUSED = 0;
  MainLoop.RENDERING_PAUSED = RENDERING_PAUSED;
  var RENDERING_SCHEDULED = 1;
  MainLoop.RENDERING_SCHEDULED = RENDERING_SCHEDULED;
  var MIN_DISTANCE = 0.1;
  var MAX_DISTANCE = 2e9;
  var _tmpSphere = new _three2.Sphere();
  var MAIN_LOOP_EVENTS = {
    UPDATE_START: "update_start",
    BEFORE_CAMERA_UPDATE: "before_camera_update",
    AFTER_CAMERA_UPDATE: "after_camera_update",
    BEFORE_LAYER_UPDATE: "before_layer_update",
    AFTER_LAYER_UPDATE: "after_layer_update",
    BEFORE_RENDER: "before_render",
    AFTER_RENDER: "after_render",
    UPDATE_END: "update_end"
  };
  MainLoop.MAIN_LOOP_EVENTS = MAIN_LOOP_EVENTS;
  function MainLoop$1(scheduler, engine) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.renderingState = RENDERING_PAUSED;
    this.needsRedraw = false;
    this.scheduler = scheduler;
    this.gfxEngine = engine;
    this._updateLoopRestarted = true;
    this.maxFar = options.maxFar || MAX_DISTANCE;
    this.minNear = options.minNear || MIN_DISTANCE;
  }
  MainLoop$1.prototype = Object.create(_three2.EventDispatcher.prototype);
  MainLoop$1.prototype.constructor = MainLoop$1;
  MainLoop$1.prototype.scheduleUpdate = function(instance, forceRedraw) {
    var _this = this;
    this.needsRedraw |= forceRedraw;
    if (this.renderingState !== RENDERING_SCHEDULED) {
      this.renderingState = RENDERING_SCHEDULED;
      requestAnimationFrame(function(timestamp) {
        _this._step(instance, timestamp);
      });
    }
  };
  function updateElements(context, entity, elements) {
    if (!elements) {
      return;
    }
    var _iterator = _createForOfIteratorHelper2(elements), _step2;
    try {
      for (_iterator.s(); !(_step2 = _iterator.n()).done; ) {
        var element = _step2.value;
        var newElementsToUpdate = entity.update(context, element);
        var sub = entity.getObjectToUpdateForAttachedLayers(element);
        if (sub) {
          if (sub.element) {
            var _iterator2 = _createForOfIteratorHelper2(entity._attachedLayers), _step3;
            try {
              for (_iterator2.s(); !(_step3 = _iterator2.n()).done; ) {
                var attachedLayer = _step3.value;
                if (attachedLayer.ready) {
                  attachedLayer.update(context, sub.element, sub.parent);
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          } else if (sub.elements) {
            for (var i = 0; i < sub.elements.length; i++) {
              if (!sub.elements[i].isObject3D) {
                throw new Error("\n                            Invalid object for attached layer to update.\n                            Must be a THREE.Object and have a THREE.Material");
              }
              var _iterator3 = _createForOfIteratorHelper2(entity._attachedLayers), _step4;
              try {
                for (_iterator3.s(); !(_step4 = _iterator3.n()).done; ) {
                  var _attachedLayer = _step4.value;
                  if (_attachedLayer.ready) {
                    _attachedLayer.update(context, sub.elements[i], sub.parent);
                  }
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          }
        }
        updateElements(context, entity, newElementsToUpdate);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  function filterChangeSources(updateSources, entity) {
    var fullUpdate = false;
    var filtered = /* @__PURE__ */ new Set();
    updateSources.forEach(function(src) {
      if (src === entity || src.isCamera) {
        fullUpdate = true;
      } else if (src.layer === entity) {
        filtered.add(src);
      }
    });
    return fullUpdate ? /* @__PURE__ */ new Set([entity]) : filtered;
  }
  MainLoop$1.prototype._update = function(instance, updateSources, dt) {
    var context = new _Context.default(instance.camera, this.scheduler, instance);
    instance.camera.camera3D.near = this.minNear;
    instance.camera.camera3D.far = this.maxFar;
    instance.camera.update();
    updateSources.forEach(function(src) {
      var layer = src.layer || src;
      if (layer instanceof _Layer2.default) {
        if (!(layer instanceof _Entity3D3.default)) {
          updateSources.add(instance.getOwner(layer));
        }
      }
    });
    var _iterator4 = _createForOfIteratorHelper2(instance.getObjects()), _step5;
    try {
      for (_iterator4.s(); !(_step5 = _iterator4.n()).done; ) {
        var entity = _step5.value;
        context.fastUpdateHint = void 0;
        context.entity = entity;
        if (entity.ready && entity.visible) {
          instance.execFrameRequesters(MAIN_LOOP_EVENTS.BEFORE_LAYER_UPDATE, dt, this._updateLoopRestarted, entity);
          var srcs = filterChangeSources(updateSources, entity);
          if (srcs.size > 0) {
            entity._distance.min = Infinity;
            entity._distance.max = 0;
            var elementsToUpdate = entity.preUpdate(context, srcs);
            updateElements(context, entity, elementsToUpdate);
            entity.postUpdate(context, updateSources);
          }
          if (entity._distance) {
            context.distance.min = Math.min(context.distance.min, entity._distance.min);
            if (entity._distance.max === Infinity) {
              context.distance.max = this.maxFar;
            } else {
              context.distance.max = Math.max(context.distance.max, entity._distance.max);
            }
          }
          instance.execFrameRequesters(MAIN_LOOP_EVENTS.AFTER_LAYER_UPDATE, dt, this._updateLoopRestarted, entity);
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    instance.threeObjects.traverse(function(o) {
      if (!o.visible) {
        return;
      }
      if (o.geometry && o.geometry.boundingSphere) {
        _tmpSphere.copy(o.geometry.boundingSphere);
        _tmpSphere.applyMatrix4(o.matrixWorld);
        var d = _tmpSphere.distanceToPoint(context.camera.camera3D.position);
        context.distance.min = _three2.Math.clamp(d, 0, context.distance.min);
        context.distance.max = Math.max(context.distance.max, d + 2 * _tmpSphere.radius);
      }
    });
    var minDistance = context.distance.min;
    if (instance.camera.camera3D.isPerspective) {
      minDistance *= minDistance * Math.cos(_three2.Math.degToRad(instance.camera.camera3D.fov / 2));
    }
    minDistance = minDistance === Infinity ? this.minNear : _three2.Math.clamp(minDistance, this.minNear, this.maxFar);
    instance.camera.camera3D.near = minDistance;
    var far = context.distance.max === 0 ? this.maxFar : _three2.Math.clamp(context.distance.max, minDistance, this.maxFar);
    instance.camera.camera3D.far = far;
    instance.camera.update();
  };
  MainLoop$1.prototype._step = function(instance, timestamp) {
    var dt = timestamp - this._lastTimestamp;
    instance._executeFrameRequestersRemovals();
    instance.execFrameRequesters(MAIN_LOOP_EVENTS.UPDATE_START, dt, this._updateLoopRestarted);
    var willRedraw = this.needsRedraw;
    this._lastTimestamp = timestamp;
    this.needsRedraw = false;
    this.renderingState = RENDERING_PAUSED;
    var updateSources = new Set(instance._changeSources);
    instance._changeSources.clear();
    var dim = this.gfxEngine.getWindowSize();
    instance.execFrameRequesters(MAIN_LOOP_EVENTS.BEFORE_CAMERA_UPDATE, dt, this._updateLoopRestarted);
    instance.camera.update(dim.x, dim.y);
    instance.execFrameRequesters(MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, dt, this._updateLoopRestarted);
    var oldAutoUpdate = instance.camera.camera3D.matrixAutoUpdate;
    instance.camera.camera3D.matrixAutoUpdate = false;
    this._update(instance, updateSources, dt);
    if (this.scheduler.commandsWaitingExecutionCount() === 0) {
      this.dispatchEvent({
        type: "command-queue-empty"
      });
    }
    if (willRedraw) {
      this._renderInstance(instance, dt);
    }
    this._updateLoopRestarted = this.renderingState === RENDERING_PAUSED;
    instance.camera.camera3D.matrixAutoUpdate = oldAutoUpdate;
    _Cache.default.flush();
    instance.execFrameRequesters(MAIN_LOOP_EVENTS.UPDATE_END, dt, this._updateLoopRestarted);
  };
  MainLoop$1.prototype._renderInstance = function(instance, dt) {
    instance.execFrameRequesters(MAIN_LOOP_EVENTS.BEFORE_RENDER, dt, this._updateLoopRestarted);
    if (instance.render) {
      instance.render();
    } else {
      this.gfxEngine.renderView(instance);
    }
    instance.execFrameRequesters(MAIN_LOOP_EVENTS.AFTER_RENDER, dt, this._updateLoopRestarted);
  };
  var _default2 = MainLoop$1;
  MainLoop.default = _default2;
  return MainLoop;
}
var c3DEngine = {};
var hasRequiredC3DEngine;
function requireC3DEngine() {
  if (hasRequiredC3DEngine)
    return c3DEngine;
  hasRequiredC3DEngine = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(c3DEngine, "__esModule", {
    value: true
  });
  c3DEngine.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _three2 = require$$8$1;
  var _Capabilities = _interopRequireDefault2(requireCapabilities());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var C3DEngine = /* @__PURE__ */ function() {
    function C3DEngine2(rendererOrDiv) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _classCallCheck22.default)(this, C3DEngine2);
      if (options.antialias === void 0) {
        options.antialias = true;
      }
      if (options.alpha === void 0) {
        options.alpha = true;
      }
      if (options.logarithmicDepthBuffer === void 0) {
        options.logarithmicDepthBuffer = false;
      }
      if (options.clearColor === void 0) {
        options.clearColor = 197896;
      }
      var renderer = rendererOrDiv.domElement ? rendererOrDiv : void 0;
      var viewerDiv = renderer ? void 0 : rendererOrDiv;
      this.width = (renderer ? renderer.domElement : viewerDiv).clientWidth;
      this.height = (renderer ? renderer.domElement : viewerDiv).clientHeight;
      this.positionBuffer = null;
      this._nextThreejsLayer = 1;
      this.fullSizeRenderTarget = new _three2.WebGLRenderTarget(this.width, this.height);
      this.fullSizeRenderTarget.texture.minFilter = _three2.LinearFilter;
      this.fullSizeRenderTarget.texture.magFilter = _three2.NearestFilter;
      this.fullSizeRenderTarget.texture.generateMipmaps = false;
      this.fullSizeRenderTarget.depthBuffer = true;
      this.fullSizeRenderTarget.depthTexture = new _three2.DepthTexture();
      this.fullSizeRenderTarget.depthTexture.type = _three2.UnsignedShortType;
      try {
        this.renderer = renderer || new _three2.WebGLRenderer({
          canvas: document.createElement("canvas"),
          antialias: options.antialias,
          alpha: options.alpha,
          logarithmicDepthBuffer: options.logarithmicDepthBuffer
        });
      } catch (ex) {
        console.error("Failed to create WebGLRenderer", ex);
        this.renderer = null;
      }
      if (!this.renderer) {
        var element = document.createElement("div");
        element.id = "webgl-error-message";
        element.style.fontFamily = "monospace";
        element.style.fontSize = "13px";
        element.style.fontWeight = "normal";
        element.style.textAlign = "center";
        element.style.background = "#fff";
        element.style.color = "#000";
        element.style.padding = "1.5em";
        element.style.width = "400px";
        element.style.margin = "5em auto 0";
        element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.<br>', 'See also <a href="https://www.khronos.org/webgl/wiki/BlacklistsAndWhitelists">graphics card blacklisting</a>'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.<br>', "You can also try another browser like Firefox or Chrome."].join("\n");
        viewerDiv.appendChild(element);
        throw new Error("WebGL unsupported");
      }
      if (!renderer && options.logarithmicDepthBuffer) {
        if (!this.renderer.extensions.get("EXT_frag_depth")) {
          var _canvas2 = this.renderer.domElement;
          this.renderer.dispose();
          this.renderer = new _three2.WebGLRenderer({
            canvas: _canvas2,
            antialias: options.antialias,
            alpha: options.alpha,
            logarithmicDepthBuffer: false
          });
        }
      }
      if (this.renderer.domElement.tabIndex === -1) {
        this.renderer.domElement.tabIndex = -1;
      }
      _Capabilities.default.updateCapabilities(this.renderer);
      if (options.clearColor !== false) {
        this.renderer.setClearColor(options.clearColor);
      }
      this.renderer.autoClear = false;
      this.renderer.sortObjects = true;
      if (!renderer) {
        this.renderer.setPixelRatio(viewerDiv.devicePixelRatio);
        this.renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);
        viewerDiv.appendChild(this.renderer.domElement);
      }
    }
    (0, _createClass22.default)(C3DEngine2, [{
      key: "renderView",
      value: function renderView(view, include2d) {
        this.renderer.setViewport(0, 0, this.width, this.height);
        this.renderer.clear();
        this.renderer.render(view.scene, view.camera.camera3D);
        if (include2d !== false) {
          this.renderer.clearDepth();
          this.renderer.render(view.scene2D, view.camera.camera2D);
        }
      }
    }, {
      key: "onWindowResize",
      value: function onWindowResize(w, h) {
        this.width = w;
        this.height = h;
        this.fullSizeRenderTarget.setSize(this.width, this.height);
        this.renderer.setSize(this.width, this.height);
      }
      /*
      * return
      */
    }, {
      key: "getWindowSize",
      value: function getWindowSize() {
        return new _three2.Vector2(this.width, this.height);
      }
      /**
       * return renderer js
       *
       * @returns {C3DEngine.WebGLRenderer} the js WebGL renderer,
       * if any. Otherwise <code>undefined</code>
       */
    }, {
      key: "getRenderer",
      value: function getRenderer() {
        return this.renderer;
      }
      /**
       * Render view to a Uint8Array.
       *
       * @param {module:Core/Instance~Instance} instance The giro3d instance to render
       * @param {object} [zone] partial zone to render
       * @param {number} zone.x x (in view coordinate)
       * @param {number} zone.y y (in view coordinate)
       * @param {number} zone.width width of area to render (in pixels)
       * @param {number} zone.height height of area to render (in pixels)
       * @returns {RenderTarget} - Uint8Array, 4 bytes per pixel. The first pixel in
       * the array is the bottom-left pixel.
       */
    }, {
      key: "renderViewToBuffer",
      value: function renderViewToBuffer(instance, zone) {
        if (!zone) {
          zone = {
            x: 0,
            y: 0,
            width: this.width,
            height: this.height
          };
        }
        this.renderViewToRenderTarget(instance, this.fullSizeRenderTarget, zone);
        zone.x = Math.max(0, Math.min(zone.x, this.width));
        zone.y = Math.max(0, Math.min(zone.y, this.height));
        var pixelBuffer = new Uint8Array(4 * zone.width * zone.height);
        this.renderer.readRenderTargetPixels(this.fullSizeRenderTarget, zone.x, this.height - (zone.y + zone.height), zone.width, zone.height, pixelBuffer);
        return pixelBuffer;
      }
      /**
       * Render view to a RenderTarget.
       *
       * @param {module:Core/Instance~Instance} instance The giro3d instance to render
       * @param {RenderTarget} [target] destination render target. Default value: full size
       * render target owned by C3DEngine.
       * @param {object} [zone] partial zone to render (zone x/y uses view coordinates) Note: target
       * must contain complete zone
       * @returns {RenderTarget} - the destination render target
       */
    }, {
      key: "renderViewToRenderTarget",
      value: function renderViewToRenderTarget(instance, target, zone) {
        if (!target) {
          target = this.fullSizeRenderTarget;
        }
        var current = this.renderer.getRenderTarget();
        target.viewport.set(0, 0, target.width, target.height);
        if (zone) {
          target.scissor.set(Math.max(0, zone.x), Math.max(target.height - (zone.y + zone.height)), zone.width, zone.height);
          target.scissorTest = true;
        }
        this.renderer.setRenderTarget(target);
        this.renderer.clear();
        this.renderer.render(instance.scene, instance.camera.camera3D);
        this.renderer.setRenderTarget(current);
        target.scissorTest = false;
        return target;
      }
    }, {
      key: "renderLayerTobuffer",
      value: function renderLayerTobuffer(view, layer, buffer2, x, y, width, height) {
        var previousVisibility = view._objects.map(function(l) {
          return l.visible;
        });
        var _iterator = _createForOfIteratorHelper2(view._objects), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var v = _step.value;
            v.visible = false;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        layer.visible = true;
        var current = this.renderer.getRenderTarget();
        this.renderer.setRenderTarget(buffer2);
        this.renderer.setViewport(0, 0, buffer2.width, buffer2.height);
        this.renderer.setScissor(x, y, width, height);
        this.renderer.setScissorTest(true);
        this.renderer.clear();
        this.renderer.render(layer.object3d, view.camera.camera3D);
        this.renderer.setScissorTest(false);
        var pixelBuffer = new Uint8Array(4 * width * height);
        this.renderer.readRenderTargetPixels(buffer2, x, y, width, height, pixelBuffer);
        this.renderer.setRenderTarget(current);
        for (var i = 0; i < previousVisibility.length; i++) {
          view._objects[i].visible = previousVisibility[i];
        }
        return pixelBuffer;
      }
    }, {
      key: "getUniqueThreejsLayer",
      value: function getUniqueThreejsLayer() {
        if (this._nextThreejsLayer > 31) {
          console.warn("Too much js layers. Starting from now all of them will use layerMask = 31");
          this._nextThreejsLayer = 31;
        }
        var result = this._nextThreejsLayer++;
        return result;
      }
    }], [{
      key: "bufferToImage",
      value: function bufferToImage(pixelBuffer, width, height) {
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        canvas.width = width;
        canvas.height = height;
        var imgData = ctx.getImageData(0, 0, width, height);
        imgData.data.set(pixelBuffer);
        ctx.putImageData(imgData, 0, 0);
        var image = new Image();
        image.src = canvas.toDataURL();
        return image;
      }
    }]);
    return C3DEngine2;
  }();
  var _default2 = C3DEngine;
  c3DEngine.default = _default2;
  return c3DEngine;
}
var Scheduler = {};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var priorityQueueExports = {};
var priorityQueue = {
  get exports() {
    return priorityQueueExports;
  },
  set exports(v) {
    priorityQueueExports = v;
  }
};
var hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue)
    return priorityQueueExports;
  hasRequiredPriorityQueue = 1;
  (function(module, exports2) {
    (function(f) {
      {
        module.exports = f();
      }
    })(function() {
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof commonjsRequire == "function" && commonjsRequire;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof commonjsRequire == "function" && commonjsRequire;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module2, exports3) {
        var AbstractPriorityQueue, ArrayStrategy, BHeapStrategy, BinaryHeapStrategy, PriorityQueue, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        AbstractPriorityQueue = _dereq_("./PriorityQueue/AbstractPriorityQueue");
        ArrayStrategy = _dereq_("./PriorityQueue/ArrayStrategy");
        BinaryHeapStrategy = _dereq_("./PriorityQueue/BinaryHeapStrategy");
        BHeapStrategy = _dereq_("./PriorityQueue/BHeapStrategy");
        PriorityQueue = function(superClass) {
          extend2(PriorityQueue2, superClass);
          function PriorityQueue2(options) {
            options || (options = {});
            options.strategy || (options.strategy = BinaryHeapStrategy);
            options.comparator || (options.comparator = function(a, b) {
              return (a || 0) - (b || 0);
            });
            PriorityQueue2.__super__.constructor.call(this, options);
          }
          return PriorityQueue2;
        }(AbstractPriorityQueue);
        PriorityQueue.ArrayStrategy = ArrayStrategy;
        PriorityQueue.BinaryHeapStrategy = BinaryHeapStrategy;
        PriorityQueue.BHeapStrategy = BHeapStrategy;
        module2.exports = PriorityQueue;
      }, { "./PriorityQueue/AbstractPriorityQueue": 2, "./PriorityQueue/ArrayStrategy": 3, "./PriorityQueue/BHeapStrategy": 4, "./PriorityQueue/BinaryHeapStrategy": 5 }], 2: [function(_dereq_, module2, exports3) {
        module2.exports = function() {
          function AbstractPriorityQueue(options) {
            var ref;
            if ((options != null ? options.strategy : void 0) == null) {
              throw "Must pass options.strategy, a strategy";
            }
            if ((options != null ? options.comparator : void 0) == null) {
              throw "Must pass options.comparator, a comparator";
            }
            this.priv = new options.strategy(options);
            this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;
          }
          AbstractPriorityQueue.prototype.queue = function(value) {
            this.length++;
            this.priv.queue(value);
            return void 0;
          };
          AbstractPriorityQueue.prototype.dequeue = function(value) {
            if (!this.length) {
              throw "Empty queue";
            }
            this.length--;
            return this.priv.dequeue();
          };
          AbstractPriorityQueue.prototype.peek = function(value) {
            if (!this.length) {
              throw "Empty queue";
            }
            return this.priv.peek();
          };
          AbstractPriorityQueue.prototype.clear = function() {
            this.length = 0;
            return this.priv.clear();
          };
          return AbstractPriorityQueue;
        }();
      }, {}], 3: [function(_dereq_, module2, exports3) {
        var binarySearchForIndexReversed;
        binarySearchForIndexReversed = function(array, value, comparator) {
          var high, low, mid;
          low = 0;
          high = array.length;
          while (low < high) {
            mid = low + high >>> 1;
            if (comparator(array[mid], value) >= 0) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return low;
        };
        module2.exports = function() {
          function ArrayStrategy(options) {
            var ref;
            this.options = options;
            this.comparator = this.options.comparator;
            this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];
            this.data.sort(this.comparator).reverse();
          }
          ArrayStrategy.prototype.queue = function(value) {
            var pos;
            pos = binarySearchForIndexReversed(this.data, value, this.comparator);
            this.data.splice(pos, 0, value);
            return void 0;
          };
          ArrayStrategy.prototype.dequeue = function() {
            return this.data.pop();
          };
          ArrayStrategy.prototype.peek = function() {
            return this.data[this.data.length - 1];
          };
          ArrayStrategy.prototype.clear = function() {
            this.data.length = 0;
            return void 0;
          };
          return ArrayStrategy;
        }();
      }, {}], 4: [function(_dereq_, module2, exports3) {
        module2.exports = function() {
          function BHeapStrategy(options) {
            var arr, j, k, len, ref, ref1, shift, value;
            this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
              return a - b;
            };
            this.pageSize = (options != null ? options.pageSize : void 0) || 512;
            this.length = 0;
            shift = 0;
            while (1 << shift < this.pageSize) {
              shift += 1;
            }
            if (1 << shift !== this.pageSize) {
              throw "pageSize must be a power of two";
            }
            this._shift = shift;
            this._emptyMemoryPageTemplate = arr = [];
            for (j = 0, ref = this.pageSize; 0 <= ref ? j < ref : j > ref; 0 <= ref ? ++j : --j) {
              arr.push(null);
            }
            this._memory = [];
            this._mask = this.pageSize - 1;
            if (options.initialValues) {
              ref1 = options.initialValues;
              for (k = 0, len = ref1.length; k < len; k++) {
                value = ref1[k];
                this.queue(value);
              }
            }
          }
          BHeapStrategy.prototype.queue = function(value) {
            this.length += 1;
            this._write(this.length, value);
            this._bubbleUp(this.length, value);
            return void 0;
          };
          BHeapStrategy.prototype.dequeue = function() {
            var ret, val;
            ret = this._read(1);
            val = this._read(this.length);
            this.length -= 1;
            if (this.length > 0) {
              this._write(1, val);
              this._bubbleDown(1, val);
            }
            return ret;
          };
          BHeapStrategy.prototype.peek = function() {
            return this._read(1);
          };
          BHeapStrategy.prototype.clear = function() {
            this.length = 0;
            this._memory.length = 0;
            return void 0;
          };
          BHeapStrategy.prototype._write = function(index, value) {
            var page;
            page = index >> this._shift;
            while (page >= this._memory.length) {
              this._memory.push(this._emptyMemoryPageTemplate.slice(0));
            }
            return this._memory[page][index & this._mask] = value;
          };
          BHeapStrategy.prototype._read = function(index) {
            return this._memory[index >> this._shift][index & this._mask];
          };
          BHeapStrategy.prototype._bubbleUp = function(index, value) {
            var compare, indexInPage, parentIndex, parentValue;
            compare = this.comparator;
            while (index > 1) {
              indexInPage = index & this._mask;
              if (index < this.pageSize || indexInPage > 3) {
                parentIndex = index & ~this._mask | indexInPage >> 1;
              } else if (indexInPage < 2) {
                parentIndex = index - this.pageSize >> this._shift;
                parentIndex += parentIndex & ~(this._mask >> 1);
                parentIndex |= this.pageSize >> 1;
              } else {
                parentIndex = index - 2;
              }
              parentValue = this._read(parentIndex);
              if (compare(parentValue, value) < 0) {
                break;
              }
              this._write(parentIndex, value);
              this._write(index, parentValue);
              index = parentIndex;
            }
            return void 0;
          };
          BHeapStrategy.prototype._bubbleDown = function(index, value) {
            var childIndex1, childIndex2, childValue1, childValue2, compare;
            compare = this.comparator;
            while (index < this.length) {
              if (index > this._mask && !(index & this._mask - 1)) {
                childIndex1 = childIndex2 = index + 2;
              } else if (index & this.pageSize >> 1) {
                childIndex1 = (index & ~this._mask) >> 1;
                childIndex1 |= index & this._mask >> 1;
                childIndex1 = childIndex1 + 1 << this._shift;
                childIndex2 = childIndex1 + 1;
              } else {
                childIndex1 = index + (index & this._mask);
                childIndex2 = childIndex1 + 1;
              }
              if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {
                childValue1 = this._read(childIndex1);
                childValue2 = this._read(childIndex2);
                if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {
                  this._write(childIndex1, value);
                  this._write(index, childValue1);
                  index = childIndex1;
                } else if (compare(childValue2, value) < 0) {
                  this._write(childIndex2, value);
                  this._write(index, childValue2);
                  index = childIndex2;
                } else {
                  break;
                }
              } else if (childIndex1 <= this.length) {
                childValue1 = this._read(childIndex1);
                if (compare(childValue1, value) < 0) {
                  this._write(childIndex1, value);
                  this._write(index, childValue1);
                  index = childIndex1;
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            return void 0;
          };
          return BHeapStrategy;
        }();
      }, {}], 5: [function(_dereq_, module2, exports3) {
        module2.exports = function() {
          function BinaryHeapStrategy(options) {
            var ref;
            this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
              return a - b;
            };
            this.length = 0;
            this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];
            this._heapify();
          }
          BinaryHeapStrategy.prototype._heapify = function() {
            var i, j, ref;
            if (this.data.length > 0) {
              for (i = j = 1, ref = this.data.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                this._bubbleUp(i);
              }
            }
            return void 0;
          };
          BinaryHeapStrategy.prototype.queue = function(value) {
            this.data.push(value);
            this._bubbleUp(this.data.length - 1);
            return void 0;
          };
          BinaryHeapStrategy.prototype.dequeue = function() {
            var last, ret;
            ret = this.data[0];
            last = this.data.pop();
            if (this.data.length > 0) {
              this.data[0] = last;
              this._bubbleDown(0);
            }
            return ret;
          };
          BinaryHeapStrategy.prototype.peek = function() {
            return this.data[0];
          };
          BinaryHeapStrategy.prototype.clear = function() {
            this.length = 0;
            this.data.length = 0;
            return void 0;
          };
          BinaryHeapStrategy.prototype._bubbleUp = function(pos) {
            var parent, x;
            while (pos > 0) {
              parent = pos - 1 >>> 1;
              if (this.comparator(this.data[pos], this.data[parent]) < 0) {
                x = this.data[parent];
                this.data[parent] = this.data[pos];
                this.data[pos] = x;
                pos = parent;
              } else {
                break;
              }
            }
            return void 0;
          };
          BinaryHeapStrategy.prototype._bubbleDown = function(pos) {
            var last, left, minIndex, right, x;
            last = this.data.length - 1;
            while (true) {
              left = (pos << 1) + 1;
              right = left + 1;
              minIndex = pos;
              if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {
                minIndex = left;
              }
              if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {
                minIndex = right;
              }
              if (minIndex !== pos) {
                x = this.data[minIndex];
                this.data[minIndex] = this.data[pos];
                this.data[pos] = x;
                pos = minIndex;
              } else {
                break;
              }
            }
            return void 0;
          };
          return BinaryHeapStrategy;
        }();
      }, {}] }, {}, [1])(1);
    });
  })(priorityQueue);
  return priorityQueueExports;
}
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(TileState$1);
var TileProvider = {};
var _Map = {};
var ElevationLayer = {};
var hasRequiredElevationLayer;
function requireElevationLayer() {
  if (hasRequiredElevationLayer)
    return ElevationLayer;
  hasRequiredElevationLayer = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  var _typeof2 = _typeofExports;
  Object.defineProperty(ElevationLayer, "__esModule", {
    value: true
  });
  ElevationLayer.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _assertThisInitialized22 = _interopRequireDefault2(requireAssertThisInitialized());
  var _get2 = _interopRequireDefault2(requireGet());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _DEMUtils = _interopRequireWildcard2(requireDEMUtils());
  var _LayerUpdateState = _interopRequireDefault2(requireLayerUpdateState());
  var _CancelledCommandException = _interopRequireDefault2(requireCancelledCommandException());
  var _Layer2 = _interopRequireWildcard2(requireLayer());
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache2(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var fooCanvas;
  var ElevationLayer$1 = /* @__PURE__ */ function(_Layer3) {
    (0, _inherits22.default)(ElevationLayer2, _Layer3);
    var _super = _createSuper2(ElevationLayer2);
    function ElevationLayer2(id) {
      var _this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _classCallCheck22.default)(this, ElevationLayer2);
      _this = _super.call(this, id, options);
      _this.elevationFormat = options.elevationFormat;
      if (_this.elevationFormat === _DEMUtils.ELEVATION_FORMAT.HEIGHFIELD) {
        _this.heightFieldOffset = options.heightFieldOffset || 0;
        _this.heightFieldScale = options.heightFieldScale || 255;
      }
      (0, _Layer2.defineLayerProperty)((0, _assertThisInitialized22.default)(_this), "frozen", false);
      return _this;
    }
    (0, _createClass22.default)(ElevationLayer2, [{
      key: "minMaxFromTexture",
      value: function minMaxFromTexture(texture) {
        if (texture.min != null && texture.max != null) {
          return {
            min: texture.min,
            max: texture.max
          };
        }
        var min = Infinity;
        var max = -Infinity;
        if (this.elevationFormat === _DEMUtils.ELEVATION_FORMAT.MAPBOX_RGB) {
          var _ElevationLayer$color = ElevationLayer2.colorImageSetup(texture), data = _ElevationLayer$color.data, stride = _ElevationLayer$color.stride, h = _ElevationLayer$color.h;
          for (var i = 0; i < h; i++) {
            for (var j = 0; j < stride; j += 4) {
              var val = _DEMUtils.default.decodeMapboxElevation(data[i * stride + j], data[i * stride + j + 1], data[i * stride + j + 2]);
              if (val < min) {
                min = val;
              }
              if (val > max) {
                max = val;
              }
            }
          }
        } else if (this.elevationFormat === _DEMUtils.ELEVATION_FORMAT.HEIGHFIELD) {
          var _ElevationLayer$color2 = ElevationLayer2.colorImageSetup(texture), _data = _ElevationLayer$color2.data, _stride = _ElevationLayer$color2.stride, _h = _ElevationLayer$color2.h;
          for (var _i = 0; _i < _h; _i++) {
            for (var _j = 0; _j < _stride; _j += 4) {
              min = Math.min(min, _data[_i * _stride + _j]);
              max = Math.max(max, _data[_i * _stride + _j]);
            }
          }
          min = this.heightFieldOffset + this.heightFieldScale * (min / 255);
          max = this.heightFieldOffset + this.heightFieldScale * (max / 255);
        } else if (this.elevationFormat === _DEMUtils.ELEVATION_FORMAT.XBIL) {
          for (var _i2 = 0; _i2 < texture.image.data.length; _i2++) {
            var _val = texture.image.data[_i2];
            if (_val > -1e3) {
              min = Math.min(min, _val);
              max = Math.max(max, _val);
            }
          }
        } else if (this.elevationFormat === _DEMUtils.ELEVATION_FORMAT.RATP_GEOL) {
          min = -1e3;
          max = 1e3;
        } else {
          throw new Error('Unsupported layer.elevationFormat "'.concat(this.elevationFormat, "'"));
        }
        texture.min = min;
        texture.max = max;
        return {
          min,
          max
        };
      }
    }, {
      key: "initNodeElevationTextureFromParent",
      value: function initNodeElevationTextureFromParent(node, parent) {
        var parentTextureInfo = parent.material.getElevationTextureInfo();
        if (!parentTextureInfo || !parentTextureInfo.texture.extent) {
          return;
        }
        var parentTexture = parentTextureInfo.texture;
        var extent2 = node.getExtentForLayer(this);
        var pitch = extent2.offsetToParent(parentTexture.extent);
        var elevation = {
          texture: parentTexture,
          pitch
        };
        var min = parentTexture.min, max = parentTexture.max;
        if (!min || !max) {
          var _this$minMaxFromTextu = this.minMaxFromTexture(parentTexture, pitch);
          min = _this$minMaxFromTextu.min;
          max = _this$minMaxFromTextu.max;
        }
        elevation.min = min;
        elevation.max = max;
        node.setTextureElevation(this, elevation);
      }
    }, {
      key: "_preprocessLayer",
      value: function _preprocessLayer(map, instance) {
        var _this2 = this;
        (0, _get2.default)((0, _getPrototypeOf22.default)(ElevationLayer2.prototype), "_preprocessLayer", this).call(this, map, instance);
        this.whenReady = this.whenReady.then(function() {
          var down = _this2.provider.getPossibleTextureImprovements(_this2, _this2.extent);
          return _this2.provider.executeCommand({
            layer: _this2,
            toDownload: down
          }).then(function(result) {
            var minmax = _this2.minMaxFromTexture(result.texture, result.pitch);
            result.texture.min = minmax.min;
            result.texture.max = minmax.max;
            _this2.minmax = minmax;
          });
        });
        this.whenReady = this.whenReady.then(function() {
          if (!_this2.minmax) {
            throw new Error("At this point the whole min/max should be known");
          }
          map.object3d.traverse(function(n) {
            if (n.setBBoxZ) {
              n.setBBoxZ(_this2.minmax.min, _this2.minmax.max);
            }
          });
          map.minMaxFromElevationLayer = {
            min: _this2.minmax.min,
            max: _this2.minmax.max
          };
          var _iterator = _createForOfIteratorHelper2(map.level0Nodes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var node = _step.value;
              node.traverse(function(n) {
                if (n.setBBoxZ) {
                  n.setBBoxZ(map.minMaxFromElevationLayer.min, map.minMaxFromElevationLayer.max);
                }
              });
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return _this2;
        });
        return this;
      }
      /**
       * Performs the update of the layer.
       *
       * @param {module:Core/Context~Context} context the context
       * @param {module:Core/TileMesh~TileMesh} node the node to update
       * @param {module:entities/Map~Map} parent the map where the layers have been added
       * @param {boolean} [initOnly = false] if true, the update is stopped before the update command
       * there is only a check that the layer state is defined in the node.
       * @returns {null|Promise} null if the update is not done,
       * else, that succeeds if the update is made.
       */
    }, {
      key: "update",
      value: function update(context, node, parent) {
        var _this3 = this;
        var initOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        var material = node.material;
        if (!node.parent || !material) {
          return null;
        }
        if (node.layerUpdateState[this.id] === void 0) {
          node.layerUpdateState[this.id] = new _LayerUpdateState.default();
          if (parent && parent.material && this.initNodeElevationTextureFromParent(node, parent)) {
            context.instance.notifyChange(node, false);
            return null;
          }
        }
        var ts = Date.now();
        if (initOnly || this.frozen || !node.material.visible || !node.layerUpdateState[this.id].canTryUpdate(ts)) {
          return null;
        }
        var textureInfo = node.material.getElevationTextureInfo();
        var nextDownloads = this.getPossibleTextureImprovements(this, node.getExtentForLayer(this), textureInfo && textureInfo.texture, node.layerUpdateState[this.id].failureParams);
        if (!nextDownloads) {
          node.layerUpdateState[this.id].noMoreUpdatePossible();
          return null;
        }
        node.layerUpdateState[this.id].newTry();
        var command = {
          /* mandatory */
          view: context.instance,
          layer: this,
          requester: node,
          priority: (0, _Layer2.nodeCommandQueuePriorityFunction)(node),
          earlyDropFunction: _Layer2.refinementCommandCancellationFn,
          toDownload: nextDownloads
        };
        return context.scheduler.execute(command).then(function(result) {
          if (node.material === null) {
            return null;
          }
          if (Array.isArray(result)) {
            result = result[0];
          }
          return result;
        }, function(err) {
          if (err instanceof _CancelledCommandException.default) {
            node.layerUpdateState[_this3.id].success();
          } else {
            console.warn("Elevation texture update error for", node, err);
            var definitiveError = node.layerUpdateState[_this3.id].errorCount > _Layer2.MAX_RETRY;
            node.layerUpdateState[_this3.id].failure(Date.now(), definitiveError, err);
            if (!definitiveError) {
              window.setTimeout(function() {
                context.instance.notifyChange(node, false);
              }, node.layerUpdateState[_this3.id].secondsUntilNextTry() * 1e3);
            }
          }
        }).then(function(elevation) {
          if (!elevation) {
            return;
          }
          var _this3$minMaxFromText = _this3.minMaxFromTexture(elevation.texture, elevation.pitch), min = _this3$minMaxFromText.min, max = _this3$minMaxFromText.max;
          elevation.min = min;
          elevation.max = max;
          node.setTextureElevation(_this3, elevation);
          node.layerUpdateState[_this3.id].success();
        });
      }
    }], [{
      key: "colorImageSetup",
      value: function colorImageSetup(texture) {
        if (!fooCanvas) {
          fooCanvas = document.createElement("canvas");
          fooCanvas.width = 256;
          fooCanvas.height = 256;
        }
        var w = texture.image.width;
        var h = texture.image.height;
        var fooCtx = fooCanvas.getContext("2d");
        fooCanvas.width = w;
        fooCanvas.height = h;
        fooCtx.drawImage(texture.image, 0, 0);
        var _fooCtx$getImageData = fooCtx.getImageData(0, 0, w, h), data = _fooCtx$getImageData.data;
        return {
          data,
          stride: w * 4,
          h
        };
      }
    }]);
    return ElevationLayer2;
  }(_Layer2.default);
  var _default2 = ElevationLayer$1;
  ElevationLayer.default = _default2;
  return ElevationLayer;
}
var PlanarTileBuilder = {};
var OBB = {};
var hasRequiredOBB;
function requireOBB() {
  if (hasRequiredOBB)
    return OBB;
  hasRequiredOBB = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(OBB, "__esModule", {
    value: true
  });
  OBB.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var OBB$1 = /* @__PURE__ */ function(_Object3D) {
    (0, _inherits22.default)(OBB2, _Object3D);
    var _super = _createSuper2(OBB2);
    function OBB2(min, max) {
      var _this;
      (0, _classCallCheck22.default)(this, OBB2);
      _this = _super.call(this);
      _this.box3D = new _three2.Box3(min.clone(), max.clone());
      _this.natBox = _this.box3D.clone();
      _this.z = {
        min: 0,
        max: 0
      };
      _this.topPointsWorld = [new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3()];
      _this.update();
      return _this;
    }
    (0, _createClass22.default)(OBB2, [{
      key: "clone",
      value: function clone2() {
        var cOBB = new OBB2(this.natBox.min, this.natBox.max);
        cOBB.position.copy(this.position);
        cOBB.quaternion.copy(this.quaternion);
        return cOBB;
      }
    }, {
      key: "updateMinMax",
      value: function updateMinMax(min, max) {
        this.box3D.min.copy(min);
        this.box3D.max.copy(max);
        this.natBox.copy(this.box3D);
        this.update();
        this.oPosition.copy(this.position);
      }
    }, {
      key: "update",
      value: function update() {
        this.updateMatrixWorld(true);
        this._cPointsWorld(this._points(this.topPointsWorld));
      }
    }, {
      key: "updateZ",
      value: function updateZ(min, max) {
        this.z = {
          min,
          max
        };
        this.box3D.min.z = this.natBox.min.z + min;
        this.box3D.max.z = this.natBox.max.z + max;
        this.update();
      }
    }, {
      key: "_points",
      value: function _points2(points) {
        points[0].set(this.box3D.max.x, this.box3D.max.y, this.box3D.max.z);
        points[1].set(this.box3D.min.x, this.box3D.max.y, this.box3D.max.z);
        points[2].set(this.box3D.min.x, this.box3D.min.y, this.box3D.max.z);
        points[3].set(this.box3D.max.x, this.box3D.min.y, this.box3D.max.z);
        if (points.length > 4) {
          points[4].set(this.box3D.max.x, this.box3D.max.y, this.box3D.min.z);
          points[5].set(this.box3D.min.x, this.box3D.max.y, this.box3D.min.z);
          points[6].set(this.box3D.min.x, this.box3D.min.y, this.box3D.min.z);
          points[7].set(this.box3D.max.x, this.box3D.min.y, this.box3D.min.z);
        }
        return points;
      }
    }, {
      key: "_cPointsWorld",
      value: function _cPointsWorld(points) {
        var m = this.matrixWorld;
        for (var i = 0, max = points.length; i < max; i++) {
          points[i].applyMatrix4(m);
        }
        return points;
      }
    }]);
    return OBB2;
  }(_three2.Object3D);
  var _default2 = OBB$1;
  OBB.default = _default2;
  return OBB;
}
var hasRequiredPlanarTileBuilder;
function requirePlanarTileBuilder() {
  if (hasRequiredPlanarTileBuilder)
    return PlanarTileBuilder;
  hasRequiredPlanarTileBuilder = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(PlanarTileBuilder, "__esModule", {
    value: true
  });
  PlanarTileBuilder.default = void 0;
  var _three2 = require$$8$1;
  var _OBB = _interopRequireDefault2(requireOBB());
  var _Coordinates = _interopRequireDefault2(requireCoordinates());
  var _Extent2 = _interopRequireDefault2(requireExtent());
  function PlanarTileBuilder$1() {
    this.tmp = {
      coords: new _Coordinates.default("EPSG:4326", 0, 0),
      position: new _three2.Vector3()
    };
    this.type = "p";
  }
  PlanarTileBuilder$1.prototype.constructor = PlanarTileBuilder$1;
  PlanarTileBuilder$1.prototype.Prepare = function(params2) {
    params2.nbRow = Math.pow(2, params2.zoom + 1);
    params2.projected = new _three2.Vector3();
  };
  var center = new _three2.Vector3();
  PlanarTileBuilder$1.prototype.Center = function(extent2) {
    extent2.center(this.tmp.coords);
    center.set(this.tmp.coords.x(), this.tmp.coords.y(), 0);
    return center;
  };
  PlanarTileBuilder$1.prototype.VertexPosition = function(params2) {
    this.tmp.position.set(params2.projected.x, params2.projected.y, 0);
    return this.tmp.position;
  };
  PlanarTileBuilder$1.prototype.uProjecte = function(u, params2) {
    params2.projected.x = params2.extent.west() + u * (params2.extent.east() - params2.extent.west());
  };
  PlanarTileBuilder$1.prototype.vProjecte = function(v, params2) {
    params2.projected.y = params2.extent.south() + v * (params2.extent.north() - params2.extent.south());
  };
  PlanarTileBuilder$1.prototype.OBB = function(boundingBox) {
    return new _OBB.default(boundingBox.min, boundingBox.max);
  };
  var quaternion = new _three2.Quaternion();
  PlanarTileBuilder$1.prototype.computeSharableExtent = function(extent2) {
    var dim = extent2.dimensions();
    var sharableExtent = new _Extent2.default(extent2.crs(), -dim.x * 0.5, dim.x * 0.5, -dim.y * 0.5, dim.y * 0.5);
    return {
      sharableExtent,
      quaternion,
      position: this.Center(extent2).clone()
    };
  };
  var _default2 = PlanarTileBuilder$1;
  PlanarTileBuilder.default = _default2;
  return PlanarTileBuilder;
}
var ObjectRemovalHelper = {};
var hasRequiredObjectRemovalHelper;
function requireObjectRemovalHelper() {
  if (hasRequiredObjectRemovalHelper)
    return ObjectRemovalHelper;
  hasRequiredObjectRemovalHelper = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(ObjectRemovalHelper, "__esModule", {
    value: true
  });
  ObjectRemovalHelper.default = void 0;
  var _toConsumableArray22 = _interopRequireDefault2(requireToConsumableArray());
  _interopRequireDefault2(requireLayer());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var _default2 = {
    /**
     * Cleanup obj to release three.js allocated resources
     *
     * @param {Object3D} obj object to release
     */
    cleanup: function cleanup(obj) {
      obj.layer = null;
      if (typeof obj.dispose === "function") {
        obj.dispose();
      } else {
        if (obj.geometry) {
          obj.geometry.dispose();
          obj.geometry = null;
        }
        if (obj.material) {
          obj.material.dispose();
          obj.material = null;
        }
      }
    },
    /**
     * Remove obj's children belonging to a layer.
     * Neither obj nor its children will be disposed!
     *
     * @param {Layer} layer The layer that objects must belong to. Other object are ignored
     * @param {Object3D} obj The Object3D we want to clean
     * @returns {Array} an array of removed Object3D from obj (not including the recursive removals)
     */
    removeChildren: function removeChildren(layer, obj) {
      var toRemove = obj.children.filter(function(c) {
        return c.layer === layer;
      });
      obj.remove.apply(obj, (0, _toConsumableArray22.default)(toRemove));
      return toRemove;
    },
    /**
     * Remove obj's children belonging to a layer and cleanup objexts.
     * obj will be disposed but its children **won't**!
     *
     * @param {Layer} layer The layer that objects must belong to. Other object are ignored
     * @param {Object3D} obj The Object3D we want to clean
     * @returns {Array} an array of removed Object3D from obj (not including the recursive removals)
     */
    removeChildrenAndCleanup: function removeChildrenAndCleanup(layer, obj) {
      var toRemove = obj.children.filter(function(c) {
        return c.layer === layer;
      });
      if (obj.layer === layer) {
        this.cleanup(obj);
      }
      obj.remove.apply(obj, (0, _toConsumableArray22.default)(toRemove));
      return toRemove;
    },
    /**
     * Recursively remove obj's children belonging to a layer.
     * All removed obj will have their geometry/material disposed.
     *
     * @param {Layer} layer The layer that objects must belong to. Other object are ignored
     * @param {Object3D} obj The Object3D we want to clean
     * @returns {Array} an array of removed Object3D from obj (not including the recursive removals)
     */
    removeChildrenAndCleanupRecursively: function removeChildrenAndCleanupRecursively(layer, obj) {
      var toRemove = obj.children.filter(function(c2) {
        return c2.layer === layer;
      });
      var _iterator = _createForOfIteratorHelper2(toRemove), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var c = _step.value;
          this.removeChildrenAndCleanupRecursively(layer, c);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (obj.layer === layer) {
        this.cleanup(obj);
      }
      obj.remove.apply(obj, (0, _toConsumableArray22.default)(toRemove));
      return toRemove;
    }
  };
  ObjectRemovalHelper.default = _default2;
  return ObjectRemovalHelper;
}
var ScreenSpaceError = {};
var hasRequiredScreenSpaceError;
function requireScreenSpaceError() {
  if (hasRequiredScreenSpaceError)
    return ScreenSpaceError;
  hasRequiredScreenSpaceError = 1;
  Object.defineProperty(ScreenSpaceError, "__esModule", {
    value: true
  });
  ScreenSpaceError.default = void 0;
  var _three2 = require$$8$1;
  var m = new _three2.Matrix4();
  var temp = [new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3(), new _three2.Vector3()];
  function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  function computeSSE(offset, size, matrix, camera, _3d) {
    temp[0].copy(offset);
    temp[0].applyMatrix4(matrix);
    matrix.extractBasis(temp[1], temp[2], temp[3]);
    temp[1].normalize().multiplyScalar(size.x);
    temp[2].normalize().multiplyScalar(size.y);
    temp[3] = temp[1].clone().add(temp[2]);
    if (_3d) {
      temp[4].normalize().multiplyScalar(size.z);
    }
    for (var i = 1; i < (_3d ? 5 : 4); i++) {
      temp[i].add(temp[0]);
    }
    var worldToNDC = camera._viewMatrix;
    for (var _i = 0; _i < (_3d ? 5 : 4); _i++) {
      temp[_i].applyMatrix4(worldToNDC);
      temp[_i].z = 0;
      temp[_i].x = (temp[_i].x + 1) * camera.width * 0.5;
      temp[_i].y = camera.height - (temp[_i].y + 1) * camera.height * 0.5;
    }
    var area2 = Math.abs(_three2.ShapeUtils.area([temp[0], temp[2], temp[3], temp[1]]));
    var result = {
      origin: temp[0].clone(),
      x: temp[1].clone(),
      y: temp[2].clone(),
      lengths: {},
      area: area2
    };
    result.lengths.x = temp[1].sub(temp[0]).length();
    result.lengths.y = temp[2].sub(temp[0]).length();
    if (_3d) {
      result.z = temp[4].clone();
      result.lengths.z = temp[4].sub(temp[0]).length();
    }
    result.ratio = easeInOutQuad(result.area / (result.lengths.x * result.lengths.y));
    return result;
  }
  function findBox3Distance(camera, box3, matrix) {
    m.copy(matrix).invert();
    var pt = new _three2.Vector3(0, 0, 0).applyMatrix4(camera.camera3D.matrixWorld).applyMatrix4(m);
    return box3.distanceToPoint(pt);
  }
  function computeSizeFromGeometricError(box3, geometricError, _3d) {
    var size = box3.getSize(temp[5]);
    var maxComponent = Math.max(size.x, size.y);
    if (_3d) {
      maxComponent = Math.max(maxComponent, size.z);
    }
    size.multiplyScalar(geometricError / maxComponent);
    return size;
  }
  var _default2 = {
    /*
     * Compute SSE based on the 2D bounding-box (ignore z size)
     */
    MODE_2D: 1,
    /*
     * Compute SSE based on the 3D bounding-box
     */
    MODE_3D: 2,
    //
    // Compute a "visible" error: project geometricError in meter on screen,
    // based on a bounding box and a transformation matrix.
    computeFromBox3: function computeFromBox3(camera, box3, matrix, geometricError, mode2) {
      if (!camera.camera3D.isOrthographicCamera) {
        var distance = findBox3Distance(camera, box3, matrix);
        if (distance <= geometricError) {
          return null;
        }
      }
      var size = computeSizeFromGeometricError(box3, geometricError, mode2 === this.MODE_3D);
      var offset = box3.min;
      var sse = computeSSE(offset, size, matrix, camera, mode2 === this.MODE_3D);
      return sse;
    },
    computeFromSphere: function computeFromSphere(camera, sphere2, matrix, geometricError) {
      var s = sphere2.clone().applyMatrix4(matrix);
      var distance = Math.max(0, s.distanceToPoint(camera.camera3D.position));
      temp[0].set(geometricError, 0, -distance);
      temp[0].applyMatrix4(camera.camera3D.projectionMatrix);
      temp[0].x = temp[0].x * camera.width * 0.5;
      temp[0].y = temp[0].y * camera.height * 0.5;
      temp[0].z = 0;
      return temp[0].length();
    },
    initDebugTool: function initDebugTool(view) {
      var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.style.top = "0px";
      svg.style.left = "0px";
      svg.style.width = "100%";
      svg.style.height = "100%";
      svg.style.position = "absolute";
      svg.style.pointerEvents = "none";
      document.getElementById("viewerDiv").appendChild(svg);
      document.addEventListener("click", function(evt) {
        var r = view.tileLayer.pickObjectsAt(view, view.eventToViewCoords(evt), 1);
        if (!r.length)
          return;
        var obj = r[0].object;
        console.log(obj);
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }
        function addLine(v1, v2, length, color) {
          var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", v1.x.toFixed());
          line.setAttribute("y1", v1.y.toFixed());
          line.setAttribute("x2", v2.x.toFixed());
          line.setAttribute("y2", v2.y.toFixed());
          line.setAttribute("stroke", color);
          svg.append(line);
          var text2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text2.setAttribute("x", ((v1.x + v2.x) * 0.5).toFixed());
          text2.setAttribute("y", ((v1.y + v2.y) * 0.5 - 10).toFixed());
          text2.setAttribute("stroke", color);
          text2.textContent = length.toFixed();
          svg.append(text2);
        }
        addLine(obj.sse.origin, obj.sse.x, obj.sse.lengths.x, "yellow");
        addLine(obj.sse.origin, obj.sse.y, obj.sse.lengths.y, "purple");
        var origin = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        origin.setAttribute("cx", obj.sse.origin.x.toFixed());
        origin.setAttribute("cy", obj.sse.origin.y.toFixed());
        origin.setAttribute("r", 5);
        origin.setAttribute("stroke", "black");
        svg.append(origin);
        var text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", (obj.sse.origin.x + 10).toFixed());
        text.setAttribute("y", (obj.sse.origin.y - 10).toFixed());
        text.textContent = obj.id;
        svg.append(text);
      });
    }
  };
  ScreenSpaceError.default = _default2;
  return ScreenSpaceError;
}
var TileGeometry = {};
var hasRequiredTileGeometry;
function requireTileGeometry() {
  if (hasRequiredTileGeometry)
    return TileGeometry;
  hasRequiredTileGeometry = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(TileGeometry, "__esModule", {
    value: true
  });
  TileGeometry.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function Buffers() {
    this.index = null;
    this.position = null;
    this.uv = null;
  }
  function UV_WGS84(out, id, u, v) {
    out.uv.array[id * 2 + 0] = u;
    out.uv.array[id * 2 + 1] = v;
  }
  function bufferize(outBuffers, va, vb, vc, idVertex) {
    outBuffers.index.array[idVertex + 0] = va;
    outBuffers.index.array[idVertex + 1] = vb;
    outBuffers.index.array[idVertex + 2] = vc;
    return idVertex + 3;
  }
  var TileGeometry$1 = /* @__PURE__ */ function(_BufferGeometry) {
    (0, _inherits22.default)(TileGeometry2, _BufferGeometry);
    var _super = _createSuper2(TileGeometry2);
    function TileGeometry2(params2, builder) {
      var _this;
      (0, _classCallCheck22.default)(this, TileGeometry2);
      _this = _super.call(this);
      _this.center = builder.Center(params2.extent).clone();
      _this.extent = params2.extent;
      var bufferAttribs = _this.computeBuffers(params2, builder);
      _this.setIndex(bufferAttribs.index);
      _this.setAttribute("position", bufferAttribs.position);
      _this.setAttribute("uv", bufferAttribs.uv);
      _this.computeBoundingBox();
      _this.OBB = builder.OBB(_this.boundingBox);
      return _this;
    }
    (0, _createClass22.default)(TileGeometry2, [{
      key: "computeBuffers",
      value: function computeBuffers(params2, builder) {
        var outBuffers = new Buffers();
        var nSeg = params2.segment;
        var nVertex = (nSeg + 1) * (nSeg + 1);
        outBuffers.position = new _three2.BufferAttribute(new Float32Array(nVertex * 3), 3);
        outBuffers.index = new _three2.BufferAttribute(new Uint32Array(nSeg * nSeg * 2 * 3), 1);
        outBuffers.uv = new _three2.BufferAttribute(new Float32Array(nVertex * 2), 2);
        var widthSegments = Math.max(2, Math.floor(nSeg) || 2);
        var heightSegments = Math.max(2, Math.floor(nSeg) || 2);
        var idVertex = 0;
        var vertices = [];
        builder.Prepare(params2);
        for (var y = 0; y <= heightSegments; y++) {
          var verticesRow = [];
          var v = y / heightSegments;
          builder.vProjecte(v, params2);
          for (var x = 0; x <= widthSegments; x++) {
            var u = x / widthSegments;
            var idM3 = idVertex * 3;
            builder.uProjecte(u, params2);
            var vertex2 = builder.VertexPosition(params2, params2.projected);
            vertex2.sub(this.center);
            vertex2.toArray(outBuffers.position.array, idM3);
            UV_WGS84(outBuffers, idVertex, u, v);
            verticesRow.push(idVertex);
            idVertex++;
          }
          vertices.push(verticesRow);
        }
        var idVertex2 = 0;
        for (var _y2 = 0; _y2 < heightSegments; _y2++) {
          for (var _x2 = 0; _x2 < widthSegments; _x2++) {
            var v1 = vertices[_y2][_x2 + 1];
            var v2 = vertices[_y2][_x2];
            var v3 = vertices[_y2 + 1][_x2];
            var v4 = vertices[_y2 + 1][_x2 + 1];
            idVertex2 = bufferize(outBuffers, v4, v2, v1, idVertex2);
            idVertex2 = bufferize(outBuffers, v4, v3, v2, idVertex2);
          }
        }
        return outBuffers;
      }
    }]);
    return TileGeometry2;
  }(_three2.BufferGeometry);
  var _default2 = TileGeometry$1;
  TileGeometry.default = _default2;
  return TileGeometry;
}
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map)
    return _Map;
  hasRequired_Map = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(_Map, "__esModule", {
    value: true
  });
  _Map.Map = void 0;
  _Map.requestNewTile = requestNewTile2;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  var _Coordinates = _interopRequireDefault2(requireCoordinates());
  var _Extent2 = _interopRequireDefault2(requireExtent());
  var _Layer2 = _interopRequireDefault2(requireLayer());
  var _ColorLayer = _interopRequireDefault2(requireColorLayer());
  var _ElevationLayer = _interopRequireDefault2(requireElevationLayer());
  var _Entity3D22 = _interopRequireDefault2(requireEntity3D());
  var _PlanarTileBuilder = _interopRequireDefault2(requirePlanarTileBuilder());
  var _ObjectRemovalHelper2 = _interopRequireDefault2(requireObjectRemovalHelper());
  var _Picking2 = _interopRequireDefault2(requirePicking());
  var _ScreenSpaceError2 = _interopRequireDefault2(requireScreenSpaceError());
  var _LayeredMaterial = _interopRequireDefault2(requireLayeredMaterial());
  var _TileMesh = _interopRequireDefault2(requireTileMesh());
  var _TileGeometry = _interopRequireDefault2(requireTileGeometry());
  var _Cache = _interopRequireDefault2(requireCache());
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function findCellWith(x, y, layerDimension, tileCount) {
    var tx = tileCount * x / layerDimension.x;
    var ty = tileCount * y / layerDimension.y;
    return {
      x: tx === 1 ? 0 : Math.floor(tx),
      y: ty === 1 ? 0 : Math.floor(ty)
    };
  }
  function compute3857Extent(tileExtent) {
    var extent2 = new _Extent2.default("EPSG:3857", -20037508342789244e-9, 20037508342789244e-9, -20037508342789244e-9, 20037508342789244e-9);
    var layerDimension = extent2.dimensions();
    var tileCount = Math.min(Math.floor(layerDimension.x / tileExtent.dimensions().x), Math.floor(layerDimension.y / tileExtent.dimensions().y));
    var zoom = Math.floor(Math.max(0, Math.log2(tileCount)));
    var tl = new _Coordinates.default("EPSG:3857", tileExtent.west(), tileExtent.north());
    var br = new _Coordinates.default("EPSG:3857", tileExtent.east(), tileExtent.south());
    var realTileCount = Math.pow(2, zoom);
    var topLeft = findCellWith(tl.x() - extent2.west(), extent2.north() - tl.y(), layerDimension, realTileCount);
    var bottomRight = findCellWith(br.x() - extent2.west(), extent2.north() - br.y(), layerDimension, realTileCount);
    var tileSize = {
      x: layerDimension.x / realTileCount,
      y: layerDimension.y / realTileCount
    };
    var extents = [];
    for (var i = topLeft.x; i <= bottomRight.x; i++) {
      for (var j = topLeft.y; j <= bottomRight.y; j++) {
        var west = extent2.west() + i * tileSize.x;
        var north = extent2.north() - j * tileSize.y;
        extents.push(new _Extent2.default("EPSG:3857", west, west + tileSize.x, north - tileSize.y, north));
      }
    }
    return extents;
  }
  function subdivideNode2(context, map, node) {
    if (!node.children.some(function(n) {
      return n.layer === map;
    })) {
      var extents = node.extent.quadtreeSplit();
      var _iterator = _createForOfIteratorHelper2(extents), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var extent2 = _step.value;
          var child = requestNewTile2(map, extent2, node);
          node.add(child);
          var _iterator2 = _createForOfIteratorHelper2(map.getElevationLayers()), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var e = _step2.value;
              e.update(context, child, node, true);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          var nodeUniforms = node.material.uniforms;
          if (nodeUniforms.colorTexture.value.image.width > 0) {
            var _iterator3 = _createForOfIteratorHelper2(map.getColorLayers()), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var c = _step3.value;
                c.update(context, child, node, true);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
          child.updateMatrixWorld(true);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      context.instance.notifyChange(node);
    }
  }
  function requestNewTile2(map, extent2, parent, level) {
    if (parent && !parent.material) {
      return null;
    }
    var builder = map.builder;
    level = level === void 0 ? parent.level + 1 : level;
    var _builder$computeShara = builder.computeSharableExtent(extent2), sharableExtent = _builder$computeShara.sharableExtent, quaternion = _builder$computeShara.quaternion, position = _builder$computeShara.position;
    var segment = map.segments || 8;
    var key = "".concat(builder.type, "_").concat(segment, "_").concat(level, "_").concat(sharableExtent._values.join(","));
    var geometry = _Cache.default.get(key);
    if (!geometry) {
      var paramsGeometry = {
        extent: sharableExtent,
        level,
        segment,
        disableSkirt: map.disableSkirt
      };
      geometry = new _TileGeometry.default(paramsGeometry, builder);
      _Cache.default.set(key, geometry);
      geometry._count = 0;
      geometry.dispose = function() {
        geometry._count--;
        if (geometry._count === 0) {
          _three2.BufferGeometry.prototype.dispose.call(geometry);
          _Cache.default.delete(key);
        }
      };
    }
    geometry._count++;
    var material = new _LayeredMaterial.default(map.materialOptions, segment, map.atlasInfo);
    var tile = new _TileMesh.default(map, geometry, material, extent2, level);
    tile.layers.set(map.threejsLayer);
    if (map.renderOrder !== void 0) {
      tile.renderOrder = map.renderOrder;
    }
    material.opacity = map.opacity;
    if (parent && parent instanceof _TileMesh.default) {
      var pTrans = builder.computeSharableExtent(parent.extent);
      position.sub(pTrans.position).applyQuaternion(pTrans.quaternion.invert());
      quaternion.premultiply(pTrans.quaternion);
    }
    tile.position.copy(position);
    tile.quaternion.copy(quaternion);
    tile.material.transparent = map.opacity < 1;
    tile.material.uniforms.opacity.value = map.opacity;
    tile.setVisibility(false);
    tile.updateMatrix();
    if (map.noTextureColor) {
      tile.material.uniforms.noTextureColor.value.copy(map.noTextureColor);
    }
    if (map.noTextureOpacity !== void 0) {
      tile.material.uniforms.noTextureOpacity.value = map.noTextureOpacity;
    }
    if (parent) {
      tile.setBBoxZ(parent.OBB().z.min, parent.OBB().z.max);
    } else {
      var elevation = map.getLayers(function(l) {
        return l instanceof _ElevationLayer.default;
      });
      if (elevation.length > 0) {
        if (!elevation[0].minmax) {
          console.error("fix the provider");
        }
        tile.setBBoxZ(elevation[0].minmax.min, elevation[0].minmax.max);
      }
    }
    tile.add(tile.OBB());
    map.onTileCreated(map, parent, tile);
    return tile;
  }
  var tmpVector = new _three2.Vector3();
  var Map2 = /* @__PURE__ */ function(_Entity3D3) {
    (0, _inherits22.default)(Map3, _Entity3D3);
    var _super = _createSuper2(Map3);
    function Map3(id) {
      var _this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _classCallCheck22.default)(this, Map3);
      _this = _super.call(this, id, options.object3d || new _three2.Group());
      var extent2 = options.extent;
      var crs = Array.isArray(extent2) ? extent2[0].crs() : extent2.crs();
      _this.validityExtent = extent2;
      if (crs === "EPSG:3857") {
        var aligned = compute3857Extent(extent2);
        _this.schemeTile = aligned;
      } else if (Array.isArray(extent2)) {
        _this.schemeTile = extent2;
      } else {
        _this.schemeTile = [extent2];
      }
      _this.extent = _this.schemeTile[0].clone();
      for (var i = 1; i < _this.schemeTile.length; i++) {
        _this.extent.union(_this.schemeTile[i]);
      }
      _this.sseScale = 1.5;
      _this.maxSubdivisionLevel = options.maxSubdivisionLevel || -1;
      _this.disableSkirt = true;
      _this.builder = new _PlanarTileBuilder.default();
      _this.protocol = "tile";
      _this.visible = true;
      _this.lighting = {
        enable: false,
        position: {
          x: -0.5,
          y: 0,
          z: 1
        }
      };
      _this.currentAddedLayerIds = [];
      return _this;
    }
    (0, _createClass22.default)(Map3, [{
      key: "pickObjectsAt",
      value: function pickObjectsAt(instance, mouse, radius) {
        return _Picking2.default.pickTilesAt(instance, mouse, radius, this);
      }
    }, {
      key: "preUpdate",
      value: function preUpdate(context, changeSources) {
        var _this2 = this;
        context.colorLayers = context.instance.getLayers(function(l, a) {
          return a && a.id === _this2.id && l instanceof _ColorLayer.default;
        });
        context.elevationLayers = context.instance.getLayers(function(l, a) {
          return a && a.id === _this2.id && l instanceof _ElevationLayer.default;
        });
        if (changeSources.has(void 0) || changeSources.size === 0) {
          return this.level0Nodes;
        }
        var commonAncestor;
        var _iterator4 = _createForOfIteratorHelper2(changeSources.values()), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var source = _step4.value;
            if (source.isCamera) {
              return this.level0Nodes;
            }
            if (source.layer === this.id) {
              if (!commonAncestor) {
                commonAncestor = source;
              } else {
                commonAncestor = source.findCommonAncestor(commonAncestor);
                if (!commonAncestor) {
                  return this.level0Nodes;
                }
              }
              if (commonAncestor.material == null) {
                commonAncestor = void 0;
              }
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        if (commonAncestor) {
          return [commonAncestor];
        }
        return this.level0Nodes;
      }
    }, {
      key: "update",
      value: function update(context, node) {
        var _this3 = this;
        if (!node.parent) {
          return _ObjectRemovalHelper2.default.removeChildrenAndCleanup(this, node);
        }
        if (context.fastUpdateHint) {
          if (!context.fastUpdateHint.isAncestorOf(node)) {
            if (node.material.visible) {
              this.updateMinMaxDistance(context, node);
              return null;
            }
            if (node.visible) {
              return node.children.filter(function(n) {
                return n.layer === _this3;
              });
            }
            return null;
          }
        }
        if (!this.frozen) {
          var isVisible = context.camera.isBox3Visible(node.OBB().box3D, node.OBB().matrixWorld);
          node.visible = isVisible;
        }
        if (node.visible) {
          var requestChildrenUpdate = false;
          if (!this.frozen) {
            var s = node.OBB().box3D.getSize(tmpVector);
            var obb = node.OBB();
            var sse = _ScreenSpaceError2.default.computeFromBox3(context.camera, obb.box3D, obb.matrixWorld, Math.max(s.x, s.y), _ScreenSpaceError2.default.MODE_2D);
            node.sse = sse;
            if (this.testTileSSE(node, sse) && this.hasEnoughTexturesToSubdivide(context, node)) {
              subdivideNode2(context, this, node);
              node.setDisplayed(false);
              requestChildrenUpdate = true;
            } else {
              node.setDisplayed(true);
            }
          } else {
            requestChildrenUpdate = true;
          }
          if (node.material.visible) {
            node.material.update();
            this.updateMinMaxDistance(context, node);
            if (!requestChildrenUpdate) {
              return _ObjectRemovalHelper2.default.removeChildren(this, node);
            }
          }
          return requestChildrenUpdate ? node.children.filter(function(n) {
            return n.layer === _this3;
          }) : void 0;
        }
        node.setDisplayed(false);
        return _ObjectRemovalHelper2.default.removeChildren(this, node);
      }
    }, {
      key: "postUpdate",
      value: function postUpdate() {
        var _this4 = this;
        var _iterator5 = _createForOfIteratorHelper2(this.level0Nodes), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var r = _step5.value;
            r.traverse(function(node) {
              if (node.layer !== _this4 || !node.material.visible) {
                return;
              }
              node.material.uniforms.neighbourdiffLevel.value.set(0, 0, 0, 1);
              var n = node.findNeighbours();
              if (n) {
                var dimensions = node.extent.dimensions();
                var elevationNeighbours = node.material.texturesInfo.elevation.neighbours;
                for (var i = 0; i < 4; i++) {
                  if (!n[i] || !n[i][0].material.visible) {
                    node.material.uniforms.neighbourdiffLevel.value.setComponent(i, 1);
                  } else {
                    var nn = n[i][0];
                    var targetExtent = n[i][1];
                    var diff = Math.log2(i % 2 ? Math.round(nn.extent.dimensions().y / dimensions.y) : Math.round(nn.extent.dimensions().x / dimensions.x));
                    node.material.uniforms.neighbourdiffLevel.value.setComponent(i, -diff);
                    elevationNeighbours.texture[i] = nn.material.texturesInfo.elevation.texture;
                    var offscale = targetExtent.offsetToParent(nn.extent);
                    elevationNeighbours.offsetScale[i] = nn.material.texturesInfo.elevation.offsetScale.clone();
                    elevationNeighbours.offsetScale[i].x += offscale.x * elevationNeighbours.offsetScale[i].z;
                    elevationNeighbours.offsetScale[i].y += offscale.y * elevationNeighbours.offsetScale[i].w;
                    elevationNeighbours.offsetScale[i].z *= offscale.z;
                    elevationNeighbours.offsetScale[i].w *= offscale.w;
                  }
                }
              }
            });
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
      // TODO this whole function should be either in providers or in layers
      /**
       * Adds a layer , then returns the created layer.
       * Before use this method, add the map in an instance.
       * If the extent or the projection of the layer is not provided,
       * the values from map will be used.
       *
       * @param {module:Core/layer/Layer~Layer} layer an object describing the layer options creation
       * @returns {Promise} a promise resolving when the layer is ready
       * @api
       */
    }, {
      key: "addLayer",
      value: function addLayer(layer) {
        var _this5 = this;
        return new Promise(function(resolve, reject) {
          if (!_this5._instance) {
            reject(new Error("map is not attached to an instance"));
            return;
          }
          if (!(layer instanceof _Layer2.default)) {
            reject(new Error("layer is not an instance of Layer"));
            return;
          }
          var duplicate = _this5.getLayers(function(l) {
            return l.id === layer.id;
          });
          if (duplicate.length > 0 || _this5.currentAddedLayerIds.includes(layer.id)) {
            reject(new Error("Invalid id '".concat(layer.id, "': id already used")));
            return;
          }
          _this5.currentAddedLayerIds.push(layer.id);
          if (!layer.extent) {
            layer.extent = _this5.extent;
          }
          if (!layer.projection) {
            layer.projection = _this5.projection;
          }
          layer = layer._preprocessLayer(_this5, _this5._instance);
          layer.whenReady.then(function(l) {
            _this5.attach(l);
            _this5._instance.notifyChange(_this5, false);
            resolve(l);
          }).catch(function(r) {
            reject(r);
          }).then(function() {
            _this5.currentAddedLayerIds = _this5.currentAddedLayerIds.filter(function(l) {
              return l !== layer.id;
            });
          });
        });
      }
      /**
       * Removes a layer from the map.
       *
       * @param {object} layer the layer to remove
       * @api
       */
    }, {
      key: "removeLayer",
      value: function removeLayer(layer) {
        if (layer.object3d) {
          _ObjectRemovalHelper2.default.removeChildrenAndCleanupRecursively(layer, layer.object3d);
          this.scene.remove(layer.object3d);
        }
        var parentLayer = this.getLayers(
          // TODO layer can have _attachedLayers ?
          function(l) {
            return l._attachedLayers && l._attachedLayers.includes(layer);
          }
        )[0];
        if (parentLayer) {
          parentLayer.detach(layer);
        }
        this._cleanLayer(layer);
        this.notifyChange(parentLayer || this._instance.camera.camera3D, true);
      }
      /**
       * Gets all layers that satisfy the filter predicate
       *
       * @api
       * @param {Function} [filter] the optional filter
       * @returns {Array<object>} the layers that matched the predicate,
       * or all layers if no predicate was provided.
       */
    }, {
      key: "getLayers",
      value: function getLayers(filter) {
        var result = [];
        var _iterator6 = _createForOfIteratorHelper2(this._attachedLayers), _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
            var layer = _step6.value;
            if (!filter || filter(layer)) {
              result.push(layer);
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return result;
      }
      /**
       * Gets all color layers
       *
       * @api
       * @returns {Array<object>} the color layers
       */
    }, {
      key: "getColorLayers",
      value: function getColorLayers() {
        return this.getLayers(function(l) {
          return l instanceof _ColorLayer.default;
        });
      }
      /**
       * Gets all elevation layers
       *
       * @api
       * @returns {Array<object>} the color layers
       */
    }, {
      key: "getElevationLayers",
      value: function getElevationLayers() {
        return this.getLayers(function(l) {
          return l instanceof _ElevationLayer.default;
        });
      }
      /**
       * Cleans all layers in the map.
       *
       * @api
       */
    }, {
      key: "clean",
      value: function clean() {
        var _iterator7 = _createForOfIteratorHelper2(this.getLayers()), _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
            var layer = _step7.value;
            layer.clean(this);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      }
    }, {
      key: "hasEnoughTexturesToSubdivide",
      value: function hasEnoughTexturesToSubdivide(context, node) {
        var _this6 = this;
        var _iterator8 = _createForOfIteratorHelper2(context.elevationLayers), _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
            var e = _step8.value;
            if (!e.frozen && e.ready && e.tileInsideLimit(node, e) && !node.material.isElevationLayerTextureLoaded(e)) {
              if (node.layerUpdateState[e.id] && node.layerUpdateState[e.id].inError()) {
                continue;
              }
              return false;
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
        if (node.children.some(function(n) {
          return n.layer === _this6;
        })) {
          return true;
        }
        return true;
      }
    }, {
      key: "testTileSSE",
      value: function testTileSSE(tile, sse) {
        if (this.maxSubdivisionLevel > 0 && this.maxSubdivisionLevel <= tile.level) {
          return false;
        }
        if (tile.extent.dimensions().x < 5) {
          return false;
        }
        if (!sse) {
          return true;
        }
        var values = [sse.lengths.x * sse.ratio, sse.lengths.y * sse.ratio];
        if (values.filter(function(v) {
          return v < 100 * tile.layer.sseScale;
        }).length >= 1) {
          return false;
        }
        return values.filter(function(v) {
          return v >= 384 * tile.layer.sseScale;
        }).length >= 2;
      }
    }, {
      key: "updateMinMaxDistance",
      value: function updateMinMaxDistance(context, node) {
        var bbox = node.OBB().box3D.clone().applyMatrix4(node.OBB().matrixWorld);
        var distance = context.distance.plane.distanceToPoint(bbox.getCenter(tmpVector));
        var radius = bbox.getSize(tmpVector).length() * 0.5;
        this._distance.min = Math.min(this._distance.min, distance - radius);
        this._distance.max = Math.max(this._distance.max, distance + radius);
      }
    }]);
    return Map3;
  }(_Entity3D22.default);
  _Map.Map = Map2;
  return _Map;
}
var hasRequiredTileProvider;
function requireTileProvider() {
  if (hasRequiredTileProvider)
    return TileProvider;
  hasRequiredTileProvider = 1;
  Object.defineProperty(TileProvider, "__esModule", {
    value: true
  });
  TileProvider.default = void 0;
  var _Map2 = require_Map();
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function preprocessDataLayer(map) {
    if (!map.schemeTile) {
      throw new Error("Cannot init tiled layer without schemeTile for layer ".concat(map.id));
    }
    map.level0Nodes = [];
    map.onTileCreated = map.onTileCreated || function() {
    };
    var promises = [];
    var _iterator = _createForOfIteratorHelper2(map.schemeTile), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var root = _step.value;
        promises.push((0, _Map2.requestNewTile)(map, root, void 0, 0));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return Promise.all(promises).then(function(level0s) {
      map.level0Nodes = level0s;
      var _iterator2 = _createForOfIteratorHelper2(level0s), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var level0 = _step2.value;
          map.object3d.add(level0);
          level0.updateMatrixWorld();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    });
  }
  function executeCommand() {
  }
  var _default2 = {
    preprocessDataLayer,
    executeCommand
  };
  TileProvider.default = _default2;
  return TileProvider;
}
var _3dTilesProvider = {};
var B3dmParser = {};
class GLTFLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let content;
    const extensions = {};
    const plugins = {};
    if (typeof data === "string") {
      content = data;
    } else {
      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else {
        content = LoaderUtils.decodeText(new Uint8Array(data));
      }
    }
    const json = JSON.parse(content);
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
}
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class GLTFLightsExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale2 = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale2, scale2);
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsSheenExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || 0;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
}
class GLTFMaterialsIorExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture).then(function(texture) {
        texture.encoding = sRGBEncoding;
      }));
    }
    return Promise.all(pending);
  }
}
class GLTFTextureBasisUExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const source = json.images[extension.source];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, source, loader);
  }
}
class GLTFTextureWebPExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFMeshoptCompression {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer2 = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder2 = this.parser.options.meshoptDecoder;
      if (!decoder2 || !decoder2.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return Promise.all([buffer2, decoder2.ready]).then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const result = new ArrayBuffer(count * stride);
        const source = new Uint8Array(res[0], byteOffset, byteLength);
        decoder2.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
        return result;
      });
    } else {
      return null;
    }
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform2) {
    if (transform2.texCoord !== void 0) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    if (transform2.offset === void 0 && transform2.rotation === void 0 && transform2.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform2.offset !== void 0) {
      texture.offset.fromArray(transform2.offset);
    }
    if (transform2.rotation !== void 0) {
      texture.rotation = transform2.rotation;
    }
    if (transform2.scale !== void 0) {
      texture.repeat.fromArray(transform2.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
}
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
  constructor(params2) {
    super();
    this.isGLTFSpecularGlossinessMaterial = true;
    const specularMapParsFragmentChunk = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join("\n");
    const glossinessMapParsFragmentChunk = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join("\n");
    const specularMapFragmentChunk = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join("\n");
    const glossinessMapFragmentChunk = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join("\n");
    const lightPhysicalFragmentChunk = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.roughness += geometryRoughness;",
      "material.roughness = min( material.roughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join("\n");
    const uniforms = {
      specular: { value: new Color().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function(shader) {
      for (const uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function() {
          return uniforms.specular.value;
        },
        set: function(v) {
          uniforms.specular.value = v;
        }
      },
      specularMap: {
        get: function() {
          return uniforms.specularMap.value;
        },
        set: function(v) {
          uniforms.specularMap.value = v;
          if (v) {
            this.defines.USE_SPECULARMAP = "";
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function() {
          return uniforms.glossiness.value;
        },
        set: function(v) {
          uniforms.glossiness.value = v;
        }
      },
      glossinessMap: {
        get: function() {
          return uniforms.glossinessMap.value;
        },
        set: function(v) {
          uniforms.glossinessMap.value = v;
          if (v) {
            this.defines.USE_GLOSSINESSMAP = "";
            this.defines.USE_UV = "";
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params2);
  }
  copy(source) {
    super.copy(source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  }
}
class GLTFMaterialsPbrSpecularGlossinessExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.specularGlossinessParams = [
      "color",
      "map",
      "lightMap",
      "lightMapIntensity",
      "aoMap",
      "aoMapIntensity",
      "emissive",
      "emissiveIntensity",
      "emissiveMap",
      "bumpMap",
      "bumpScale",
      "normalMap",
      "normalMapType",
      "displacementMap",
      "displacementScale",
      "displacementBias",
      "specularMap",
      "specular",
      "glossinessMap",
      "glossiness",
      "alphaMap",
      "envMap",
      "envMapIntensity",
      "refractionRatio"
    ];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pbrSpecularGlossiness = materialDef.extensions[this.name];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const pending = [];
    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
      const array = pbrSpecularGlossiness.diffuseFactor;
      materialParams.color.fromArray(array);
      materialParams.opacity = array[3];
    }
    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
    }
    materialParams.emissive = new Color(0, 0, 0);
    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
    materialParams.specular = new Color(1, 1, 1);
    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
    }
    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
      pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
      pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
    }
    return Promise.all(pending);
  }
  createMaterial(materialParams) {
    const material = new GLTFMeshStandardSGMaterial(materialParams);
    material.fog = true;
    material.color = materialParams.color;
    material.map = materialParams.map === void 0 ? null : materialParams.map;
    material.lightMap = null;
    material.lightMapIntensity = 1;
    material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
    material.aoMapIntensity = 1;
    material.emissive = materialParams.emissive;
    material.emissiveIntensity = 1;
    material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
    material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
    material.bumpScale = 1;
    material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
    material.normalMapType = TangentSpaceNormalMap;
    if (materialParams.normalScale)
      material.normalScale = materialParams.normalScale;
    material.displacementMap = null;
    material.displacementScale = 1;
    material.displacementBias = 0;
    material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
    material.specular = materialParams.specular;
    material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
    material.glossiness = materialParams.glossiness;
    material.alphaMap = null;
    material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
    material.envMapIntensity = 1;
    material.refractionRatio = 0.98;
    return material;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
}
GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
  const result = this.resultBuffer;
  const values = this.sampleValues;
  const stride = this.valueSize;
  const stride2 = stride * 2;
  const stride3 = stride * 3;
  const td = t1 - t0;
  const p = (t - t0) / td;
  const pp = p * p;
  const ppp = pp * p;
  const offset1 = i1 * stride3;
  const offset0 = offset1 - stride3;
  const s2 = -2 * ppp + 3 * pp;
  const s3 = ppp - pp;
  const s0 = 1 - s2;
  const s1 = s3 - pp + p;
  for (let i = 0; i !== stride; i++) {
    const p0 = values[offset0 + i + stride];
    const m0 = values[offset0 + i + stride2] * td;
    const p12 = values[offset1 + i + stride];
    const m1 = values[offset1 + i] * td;
    result[i] = s0 * p0 + s1 * m0 + s2 * p12 + s3 * m1;
  }
  return result;
};
const _q = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t, t1) {
    const result = super.interpolate_(i1, t0, t, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
}
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
const WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
const WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
const ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
const PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
const INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
const ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache2) {
  if (cache2["DefaultMaterial"] === void 0) {
    cache2["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache2["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (hasMorphPosition && hasMorphNormal)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let geometryKey;
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
class GLTFParser {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.textureCache = {};
    this.nodeNamesUsed = {};
    if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new TextureLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache2, index) {
    if (index === void 0)
      return;
    if (cache2.refs[index] === void 0) {
      cache2.refs[index] = cache2.uses[index] = 0;
    }
    cache2.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache2, index, object) {
    if (cache2.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone2) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone2, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone2.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache2.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this.loadNode(index);
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this.loadAnimation(index);
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          throw new Error("Unknown type: " + type);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs2 = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs2.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer2) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer2.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null);
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const source = json.images[textureDef.source];
    let loader = this.textureLoader;
    if (source.uri) {
      const handler = options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, source, loader);
  }
  loadTextureImage(textureIndex, source, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const cacheKey = (source.uri || source.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = source.uri || "";
    let isObjectURL = false;
    if (source.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: source.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (source.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.flipY = false;
      if (textureDef.name)
        texture.name = textureDef.name;
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform2 = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform2) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform2);
          parser.associations.set(texture, gltfReference);
        }
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial$1();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += "specular-glossiness:";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.format = RGBFormat;
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale2 = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale2, scale2);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
    }
    return Promise.all(pending).then(function() {
      let material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name)
        material.name = materialDef.name;
      if (material.map)
        material.map.encoding = sRGBEncoding;
      if (material.emissiveMap)
        material.emissiveMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    let name = sanitizedName;
    for (let i = 1; this.nodeNamesUsed[name]; ++i) {
      name = sanitizedName + "_" + i;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache2 = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache2[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache2[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points$1(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      const group = new Group();
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params2 = cameraDef[cameraDef.type];
    if (!params2) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params2.yfov), params2.aspectRatio || 1, params2.znear || 1, params2.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params2.xmag, params2.xmag, params2.ymag, -params2.ymag, params2.znear, params2.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const skinEntry = { joints: skinDef.joints };
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node !== void 0 ? target.node : target.id;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0)
          continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object) {
            if (object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale2 = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale2;
          }
          outputArray = scaled;
        }
        for (let j = 0, jl = targetNames.length; j < jl; j++) {
          const track = new TypedKeyframeTrack(
            targetNames[j] + "." + PATH_PROPERTIES[target.path],
            inputAccessor.array,
            outputArray,
            interpolation
          );
          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new AnimationClip(name, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    return function() {
      const pending = [];
      const meshPromise = parser._invokeOne(function(ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
      });
      if (meshPromise) {
        pending.push(meshPromise);
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));
    }
    return Promise.all(pending).then(function() {
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
}
function buildNodeHierarchy(nodeId, parentObject, json, parser) {
  const nodeDef = json.nodes[nodeId];
  return parser.getDependency("node", nodeId).then(function(node) {
    if (nodeDef.skin === void 0)
      return node;
    let skinEntry;
    return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
      skinEntry = skin;
      const pendingJoints = [];
      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {
        pendingJoints.push(parser.getDependency("node", skinEntry.joints[i]));
      }
      return Promise.all(pendingJoints);
    }).then(function(jointNodes) {
      node.traverse(function(mesh) {
        if (!mesh.isMesh)
          return;
        const bones = [];
        const boneInverses = [];
        for (let j = 0, jl = jointNodes.length; j < jl; j++) {
          const jointNode = jointNodes[j];
          if (jointNode) {
            bones.push(jointNode);
            const mat = new Matrix4();
            if (skinEntry.inverseBindMatrices !== void 0) {
              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
            }
            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
          }
        }
        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
      });
      return node;
    });
  }).then(function(node) {
    parentObject.add(node);
    const pending = [];
    if (nodeDef.children) {
      const children = nodeDef.children;
      for (let i = 0, il = children.length; i < il; i++) {
        const child = children[i];
        pending.push(buildNodeHierarchy(child, node, json, parser));
      }
    }
    return Promise.all(pending);
  });
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector2 = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector2.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector2.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector2.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector2.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector2);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere2 = new Sphere();
  box.getCenter(sphere2.center);
  sphere2.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere2;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
function toTrianglesDrawMode(geometry, drawMode) {
  let index = geometry.getIndex();
  if (index === null) {
    const indices = [];
    const position = geometry.getAttribute("position");
    if (position !== void 0) {
      for (let i = 0; i < position.count; i++) {
        indices.push(i);
      }
      geometry.setIndex(indices);
      index = geometry.getIndex();
    } else {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
      return geometry;
    }
  }
  const numberOfTriangles = index.count - 2;
  const newIndices = [];
  if (drawMode === TriangleFanDrawMode) {
    for (let i = 1; i <= numberOfTriangles; i++) {
      newIndices.push(index.getX(0));
      newIndices.push(index.getX(i));
      newIndices.push(index.getX(i + 1));
    }
  } else {
    for (let i = 0; i < numberOfTriangles; i++) {
      if (i % 2 === 0) {
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
        newIndices.push(index.getX(i + 2));
      } else {
        newIndices.push(index.getX(i + 2));
        newIndices.push(index.getX(i + 1));
        newIndices.push(index.getX(i));
      }
    }
  }
  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  }
  const newGeometry = geometry.clone();
  newGeometry.setIndex(newIndices);
  return newGeometry;
}
const GLTFLoader$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GLTFLoader
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$3 = /* @__PURE__ */ getAugmentedNamespace(GLTFLoader$1);
var LegacyGLTFLoader = {};
var hasRequiredLegacyGLTFLoader;
function requireLegacyGLTFLoader() {
  if (hasRequiredLegacyGLTFLoader)
    return LegacyGLTFLoader;
  hasRequiredLegacyGLTFLoader = 1;
  Object.defineProperty(LegacyGLTFLoader, "__esModule", {
    value: true
  });
  LegacyGLTFLoader.default = void 0;
  var _three2 = require$$8$1;
  var _default2 = function() {
    function LegacyGLTFLoader2(manager) {
      this.manager = manager !== void 0 ? manager : _three2.DefaultLoadingManager;
    }
    LegacyGLTFLoader2.prototype = {
      constructor: LegacyGLTFLoader2,
      crossOrigin: "Anonymous",
      load: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = this.path && typeof this.path === "string" ? this.path : _three2.LoaderUtils.extractUrlBase(url);
        var loader = new _three2.FileLoader(scope.manager);
        loader.setResponseType("arraybuffer");
        loader.load(url, function(data) {
          scope.parse(data, onLoad, path);
        }, onProgress, onError);
      },
      setCrossOrigin: function setCrossOrigin(value) {
        this.crossOrigin = value;
      },
      setPath: function setPath(value) {
        this.path = value;
      },
      parse: function parse2(data, callback, path) {
        var content;
        var extensions = {};
        var magic = _three2.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
        if (magic === BINARY_EXTENSION_HEADER_DEFAULTS.magic) {
          extensions[EXTENSIONS2.KHR_BINARY_GLTF] = new GLTFBinaryExtension2(data);
          content = extensions[EXTENSIONS2.KHR_BINARY_GLTF].content;
        } else {
          content = _three2.LoaderUtils.decodeText(new Uint8Array(data));
        }
        var json = JSON.parse(content);
        if (json.extensionsUsed && json.extensionsUsed.indexOf(EXTENSIONS2.KHR_MATERIALS_COMMON) >= 0) {
          extensions[EXTENSIONS2.KHR_MATERIALS_COMMON] = new GLTFMaterialsCommonExtension(json);
        }
        var parser = new GLTFParser2(json, extensions, {
          path: path || this.path,
          crossOrigin: this.crossOrigin
        });
        parser.parse(function(scene, scenes, cameras, animations) {
          callback({
            "scene": scene,
            "scenes": scenes,
            "cameras": cameras,
            "animations": animations
          });
        });
      }
    };
    function GLTFRegistry2() {
      var objects = {};
      return {
        get: function get2(key) {
          return objects[key];
        },
        add: function add2(key, object) {
          objects[key] = object;
        },
        remove: function remove(key) {
          delete objects[key];
        },
        removeAll: function removeAll() {
          objects = {};
        },
        update: function update(scene, camera) {
          for (var name in objects) {
            var object = objects[name];
            if (object.update) {
              object.update(scene, camera);
            }
          }
        }
      };
    }
    LegacyGLTFLoader2.Shaders = {
      update: function update() {
        console.warn("LegacyGLTFLoader.Shaders has been deprecated, and now updates automatically.");
      }
    };
    function GLTFShader(targetNode, allNodes) {
      var boundUniforms = {};
      var uniforms = targetNode.material.uniforms;
      for (var uniformId in uniforms) {
        var uniform = uniforms[uniformId];
        if (uniform.semantic) {
          var sourceNodeRef = uniform.node;
          var sourceNode = targetNode;
          if (sourceNodeRef) {
            sourceNode = allNodes[sourceNodeRef];
          }
          boundUniforms[uniformId] = {
            semantic: uniform.semantic,
            sourceNode,
            targetNode,
            uniform
          };
        }
      }
      this.boundUniforms = boundUniforms;
      this._m4 = new _three2.Matrix4();
    }
    GLTFShader.prototype.update = function(scene, camera) {
      var boundUniforms = this.boundUniforms;
      for (var name in boundUniforms) {
        var boundUniform = boundUniforms[name];
        switch (boundUniform.semantic) {
          case "MODELVIEW":
            var m4 = boundUniform.uniform.value;
            m4.multiplyMatrices(camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld);
            break;
          case "MODELVIEWINVERSETRANSPOSE":
            var m3 = boundUniform.uniform.value;
            this._m4.multiplyMatrices(camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld);
            m3.getNormalMatrix(this._m4);
            break;
          case "PROJECTION":
            var m4 = boundUniform.uniform.value;
            m4.copy(camera.projectionMatrix);
            break;
          case "JOINTMATRIX":
            var m4v = boundUniform.uniform.value;
            for (var mi = 0; mi < m4v.length; mi++) {
              m4v[mi].copy(boundUniform.sourceNode.matrixWorld).invert().multiply(boundUniform.targetNode.skeleton.bones[mi].matrixWorld).multiply(boundUniform.targetNode.skeleton.boneInverses[mi]).multiply(boundUniform.targetNode.bindMatrix);
            }
            break;
          default:
            console.warn("Unhandled shader semantic: " + boundUniform.semantic);
            break;
        }
      }
    };
    LegacyGLTFLoader2.Animations = {
      update: function update() {
        console.warn("LegacyGLTFLoader.Animation has been deprecated. Use AnimationMixer instead.");
      }
    };
    var EXTENSIONS2 = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_MATERIALS_COMMON: "KHR_materials_common"
    };
    function GLTFMaterialsCommonExtension(json) {
      this.name = EXTENSIONS2.KHR_MATERIALS_COMMON;
      this.lights = {};
      var extension = json.extensions && json.extensions[EXTENSIONS2.KHR_MATERIALS_COMMON] || {};
      var lights = extension.lights || {};
      for (var lightId in lights) {
        var light = lights[lightId];
        var lightNode;
        var lightParams = light[light.type];
        var color = new _three2.Color().fromArray(lightParams.color);
        switch (light.type) {
          case "directional":
            lightNode = new _three2.DirectionalLight(color);
            lightNode.position.set(0, 0, 1);
            break;
          case "point":
            lightNode = new _three2.PointLight(color);
            break;
          case "spot":
            lightNode = new _three2.SpotLight(color);
            lightNode.position.set(0, 0, 1);
            break;
          case "ambient":
            lightNode = new _three2.AmbientLight(color);
            break;
        }
        if (lightNode) {
          this.lights[lightId] = lightNode;
        }
      }
    }
    var BINARY_EXTENSION_HEADER_DEFAULTS = {
      magic: "glTF",
      version: 1,
      contentFormat: 0
    };
    var BINARY_EXTENSION_HEADER_LENGTH2 = 20;
    function GLTFBinaryExtension2(data) {
      this.name = EXTENSIONS2.KHR_BINARY_GLTF;
      var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH2);
      var header = {
        magic: _three2.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true),
        contentLength: headerView.getUint32(12, true),
        contentFormat: headerView.getUint32(16, true)
      };
      for (var key in BINARY_EXTENSION_HEADER_DEFAULTS) {
        var value = BINARY_EXTENSION_HEADER_DEFAULTS[key];
        if (header[key] !== value) {
          throw new Error('Unsupported glTF-Binary header: Expected "%s" to be "%s".', key, value);
        }
      }
      var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH2, header.contentLength);
      this.header = header;
      this.content = _three2.LoaderUtils.decodeText(contentArray);
      this.body = data.slice(BINARY_EXTENSION_HEADER_LENGTH2 + header.contentLength, header.length);
    }
    GLTFBinaryExtension2.prototype.loadShader = function(shader, bufferViews) {
      var bufferView = bufferViews[shader.extensions[EXTENSIONS2.KHR_BINARY_GLTF].bufferView];
      var array = new Uint8Array(bufferView);
      return _three2.LoaderUtils.decodeText(array);
    };
    GLTFBinaryExtension2.prototype.loadTextureSourceUri = function(source, bufferViews) {
      var metadata = source.extensions[EXTENSIONS2.KHR_BINARY_GLTF];
      var bufferView = bufferViews[metadata.bufferView];
      var stringData = _three2.LoaderUtils.decodeText(new Uint8Array(bufferView));
      return "data:" + metadata.mimeType + ";base64," + btoa(stringData);
    };
    var WEBGL_CONSTANTS2 = {
      FLOAT: 5126,
      //FLOAT_MAT2: 35674,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      TRIANGLES: 4,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123,
      VERTEX_SHADER: 35633,
      FRAGMENT_SHADER: 35632
    };
    var WEBGL_TYPE = {
      5126: Number,
      //35674: Matrix2,
      35675: _three2.Matrix3,
      35676: _three2.Matrix4,
      35664: _three2.Vector2,
      35665: _three2.Vector3,
      35666: _three2.Vector4,
      35678: _three2.Texture
    };
    var WEBGL_COMPONENT_TYPES2 = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    };
    var WEBGL_FILTERS2 = {
      9728: _three2.NearestFilter,
      9729: _three2.LinearFilter,
      9984: _three2.NearestMipmapNearestFilter,
      9985: _three2.LinearMipmapNearestFilter,
      9986: _three2.NearestMipmapLinearFilter,
      9987: _three2.LinearMipmapLinearFilter
    };
    var WEBGL_WRAPPINGS2 = {
      33071: _three2.ClampToEdgeWrapping,
      33648: _three2.MirroredRepeatWrapping,
      10497: _three2.RepeatWrapping
    };
    var WEBGL_TEXTURE_FORMATS = {
      6406: _three2.AlphaFormat,
      6407: _three2.RGBFormat,
      6408: _three2.RGBAFormat,
      6409: _three2.LuminanceFormat,
      6410: _three2.LuminanceAlphaFormat
    };
    var WEBGL_TEXTURE_DATATYPES = {
      5121: _three2.UnsignedByteType,
      32819: _three2.UnsignedShort4444Type,
      32820: _three2.UnsignedShort5551Type,
      33635: _three2.UnsignedShort565Type
    };
    var WEBGL_SIDES = {
      1028: _three2.BackSide,
      // Culling front
      1029: _three2.FrontSide
      // Culling back
      //1032: NoSide   // Culling front and back, what to do?
    };
    var WEBGL_DEPTH_FUNCS = {
      512: _three2.NeverDepth,
      513: _three2.LessDepth,
      514: _three2.EqualDepth,
      515: _three2.LessEqualDepth,
      516: _three2.GreaterEqualDepth,
      517: _three2.NotEqualDepth,
      518: _three2.GreaterEqualDepth,
      519: _three2.AlwaysDepth
    };
    var WEBGL_BLEND_EQUATIONS = {
      32774: _three2.AddEquation,
      32778: _three2.SubtractEquation,
      32779: _three2.ReverseSubtractEquation
    };
    var WEBGL_BLEND_FUNCS = {
      0: _three2.ZeroFactor,
      1: _three2.OneFactor,
      768: _three2.SrcColorFactor,
      769: _three2.OneMinusSrcColorFactor,
      770: _three2.SrcAlphaFactor,
      771: _three2.OneMinusSrcAlphaFactor,
      772: _three2.DstAlphaFactor,
      773: _three2.OneMinusDstAlphaFactor,
      774: _three2.DstColorFactor,
      775: _three2.OneMinusDstColorFactor,
      776: _three2.SrcAlphaSaturateFactor
      // The followings are not supported by Three.js yet
      //32769: CONSTANT_COLOR,
      //32770: ONE_MINUS_CONSTANT_COLOR,
      //32771: CONSTANT_ALPHA,
      //32772: ONE_MINUS_CONSTANT_COLOR
    };
    var WEBGL_TYPE_SIZES2 = {
      "SCALAR": 1,
      "VEC2": 2,
      "VEC3": 3,
      "VEC4": 4,
      "MAT2": 4,
      "MAT3": 9,
      "MAT4": 16
    };
    var PATH_PROPERTIES2 = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion"
    };
    var INTERPOLATION2 = {
      LINEAR: _three2.InterpolateLinear,
      STEP: _three2.InterpolateDiscrete
    };
    var STATES_ENABLES = {
      2884: "CULL_FACE",
      2929: "DEPTH_TEST",
      3042: "BLEND",
      3089: "SCISSOR_TEST",
      32823: "POLYGON_OFFSET_FILL",
      32926: "SAMPLE_ALPHA_TO_COVERAGE"
    };
    function _each(object, callback, thisObj) {
      if (!object) {
        return Promise.resolve();
      }
      var results;
      var fns = [];
      if (Object.prototype.toString.call(object) === "[object Array]") {
        results = [];
        var length = object.length;
        for (var idx = 0; idx < length; idx++) {
          var value = callback.call(thisObj || this, object[idx], idx);
          if (value) {
            fns.push(value);
            if (value instanceof Promise) {
              value.then(function(key2, value2) {
                results[key2] = value2;
              }.bind(this, idx));
            } else {
              results[idx] = value;
            }
          }
        }
      } else {
        results = {};
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            var value = callback.call(thisObj || this, object[key], key);
            if (value) {
              fns.push(value);
              if (value instanceof Promise) {
                value.then(function(key2, value2) {
                  results[key2] = value2;
                }.bind(this, key));
              } else {
                results[key] = value;
              }
            }
          }
        }
      }
      return Promise.all(fns).then(function() {
        return results;
      });
    }
    function resolveURL(url, path) {
      if (typeof url !== "string" || url === "")
        return "";
      if (/^(https?:)?\/\//i.test(url)) {
        return url;
      }
      if (/^data:.*,.*$/i.test(url)) {
        return url;
      }
      return (path || "") + url;
    }
    function replaceTHREEShaderAttributes(shaderText, technique) {
      var attributes = {};
      for (var attributeId in technique.attributes) {
        var pname = technique.attributes[attributeId];
        var param = technique.parameters[pname];
        var atype = param.type;
        var semantic = param.semantic;
        attributes[attributeId] = {
          type: atype,
          semantic
        };
      }
      var shaderParams = technique.parameters;
      var shaderAttributes = technique.attributes;
      var params2 = {};
      for (var attributeId in attributes) {
        var pname = shaderAttributes[attributeId];
        var shaderParam = shaderParams[pname];
        var semantic = shaderParam.semantic;
        if (semantic) {
          params2[attributeId] = shaderParam;
        }
      }
      for (var pname in params2) {
        var param = params2[pname];
        var semantic = param.semantic;
        var regEx = new RegExp("\\b" + pname + "\\b", "g");
        switch (semantic) {
          case "POSITION":
            shaderText = shaderText.replace(regEx, "position");
            break;
          case "NORMAL":
            shaderText = shaderText.replace(regEx, "normal");
            break;
          case "TEXCOORD_0":
          case "TEXCOORD0":
          case "TEXCOORD":
            shaderText = shaderText.replace(regEx, "uv");
            break;
          case "TEXCOORD_1":
            shaderText = shaderText.replace(regEx, "uv2");
            break;
          case "COLOR_0":
          case "COLOR0":
          case "COLOR":
            shaderText = shaderText.replace(regEx, "color");
            break;
          case "WEIGHT":
            shaderText = shaderText.replace(regEx, "skinWeight");
            break;
          case "JOINT":
            shaderText = shaderText.replace(regEx, "skinIndex");
            break;
        }
      }
      return shaderText;
    }
    function createDefaultMaterial2() {
      return new _three2.MeshPhongMaterial({
        color: 0,
        emissive: 8947848,
        specular: 0,
        shininess: 0,
        transparent: false,
        depthTest: true,
        side: _three2.FrontSide
      });
    }
    function DeferredShaderMaterial(params2) {
      this.isDeferredShaderMaterial = true;
      this.params = params2;
    }
    DeferredShaderMaterial.prototype.create = function() {
      var uniforms = _three2.UniformsUtils.clone(this.params.uniforms);
      for (var uniformId in this.params.uniforms) {
        var originalUniform = this.params.uniforms[uniformId];
        if (originalUniform.value instanceof _three2.Texture) {
          uniforms[uniformId].value = originalUniform.value;
          uniforms[uniformId].value.needsUpdate = true;
        }
        uniforms[uniformId].semantic = originalUniform.semantic;
        uniforms[uniformId].node = originalUniform.node;
      }
      this.params.uniforms = uniforms;
      return new _three2.RawShaderMaterial(this.params);
    };
    function GLTFParser2(json, extensions, options) {
      this.json = json || {};
      this.extensions = extensions || {};
      this.options = options || {};
      this.cache = new GLTFRegistry2();
    }
    GLTFParser2.prototype._withDependencies = function(dependencies) {
      var _dependencies = {};
      for (var i = 0; i < dependencies.length; i++) {
        var dependency = dependencies[i];
        var fnName = "load" + dependency.charAt(0).toUpperCase() + dependency.slice(1);
        var cached = this.cache.get(dependency);
        if (cached !== void 0) {
          _dependencies[dependency] = cached;
        } else if (this[fnName]) {
          var fn = this[fnName]();
          this.cache.add(dependency, fn);
          _dependencies[dependency] = fn;
        }
      }
      return _each(_dependencies, function(dependency2) {
        return dependency2;
      });
    };
    GLTFParser2.prototype.parse = function(callback) {
      var json = this.json;
      this.cache.removeAll();
      this._withDependencies(["scenes", "cameras", "animations"]).then(function(dependencies) {
        var scenes = [];
        for (var name in dependencies.scenes) {
          scenes.push(dependencies.scenes[name]);
        }
        var scene = json.scene !== void 0 ? dependencies.scenes[json.scene] : scenes[0];
        var cameras = [];
        for (var name in dependencies.cameras) {
          var camera = dependencies.cameras[name];
          cameras.push(camera);
        }
        var animations = [];
        for (var name in dependencies.animations) {
          animations.push(dependencies.animations[name]);
        }
        callback(scene, scenes, cameras, animations);
      });
    };
    GLTFParser2.prototype.loadShaders = function() {
      var json = this.json;
      var extensions = this.extensions;
      var options = this.options;
      return this._withDependencies(["bufferViews"]).then(function(dependencies) {
        return _each(json.shaders, function(shader) {
          if (shader.extensions && shader.extensions[EXTENSIONS2.KHR_BINARY_GLTF]) {
            return extensions[EXTENSIONS2.KHR_BINARY_GLTF].loadShader(shader, dependencies.bufferViews);
          }
          return new Promise(function(resolve) {
            var loader = new _three2.FileLoader();
            loader.setResponseType("text");
            loader.load(resolveURL(shader.uri, options.path), function(shaderText) {
              resolve(shaderText);
            });
          });
        });
      });
    };
    GLTFParser2.prototype.loadBuffers = function() {
      var json = this.json;
      var extensions = this.extensions;
      var options = this.options;
      return _each(json.buffers, function(buffer2, name) {
        if (name === "binary_glTF") {
          return extensions[EXTENSIONS2.KHR_BINARY_GLTF].body;
        }
        if (buffer2.type === "arraybuffer" || buffer2.type === void 0) {
          return new Promise(function(resolve) {
            var loader = new _three2.FileLoader();
            loader.setResponseType("arraybuffer");
            loader.load(resolveURL(buffer2.uri, options.path), function(buffer3) {
              resolve(buffer3);
            });
          });
        } else {
          console.warn("LegacyGLTFLoader: " + buffer2.type + " buffer type is not supported");
        }
      });
    };
    GLTFParser2.prototype.loadBufferViews = function() {
      var json = this.json;
      return this._withDependencies(["buffers"]).then(function(dependencies) {
        return _each(json.bufferViews, function(bufferView) {
          var arraybuffer2 = dependencies.buffers[bufferView.buffer];
          var byteLength = bufferView.byteLength !== void 0 ? bufferView.byteLength : 0;
          return arraybuffer2.slice(bufferView.byteOffset, bufferView.byteOffset + byteLength);
        });
      });
    };
    GLTFParser2.prototype.loadAccessors = function() {
      var json = this.json;
      return this._withDependencies(["bufferViews"]).then(function(dependencies) {
        return _each(json.accessors, function(accessor) {
          var arraybuffer2 = dependencies.bufferViews[accessor.bufferView];
          var itemSize = WEBGL_TYPE_SIZES2[accessor.type];
          var TypedArray = WEBGL_COMPONENT_TYPES2[accessor.componentType];
          var elementBytes = TypedArray.BYTES_PER_ELEMENT;
          if (accessor.byteStride && accessor.byteStride !== elementBytes * itemSize) {
            var array = new TypedArray(arraybuffer2);
            var ib = new _three2.InterleavedBuffer(array, accessor.byteStride / elementBytes);
            return new _three2.InterleavedBufferAttribute(ib, itemSize, accessor.byteOffset / elementBytes);
          } else {
            array = new TypedArray(arraybuffer2, accessor.byteOffset, accessor.count * itemSize);
            return new _three2.BufferAttribute(array, itemSize);
          }
        });
      });
    };
    GLTFParser2.prototype.loadTextures = function() {
      var json = this.json;
      var extensions = this.extensions;
      var options = this.options;
      return this._withDependencies(["bufferViews"]).then(function(dependencies) {
        return _each(json.textures, function(texture) {
          if (texture.source) {
            return new Promise(function(resolve) {
              var source = json.images[texture.source];
              var sourceUri = source.uri;
              if (source.extensions && source.extensions[EXTENSIONS2.KHR_BINARY_GLTF]) {
                sourceUri = extensions[EXTENSIONS2.KHR_BINARY_GLTF].loadTextureSourceUri(source, dependencies.bufferViews);
              }
              var textureLoader = _three2.Loader.Handlers.get(sourceUri);
              if (textureLoader === null) {
                textureLoader = new _three2.TextureLoader();
              }
              textureLoader.setCrossOrigin(options.crossOrigin);
              textureLoader.load(resolveURL(sourceUri, options.path), function(_texture) {
                _texture.flipY = false;
                if (texture.name !== void 0)
                  _texture.name = texture.name;
                _texture.format = texture.format !== void 0 ? WEBGL_TEXTURE_FORMATS[texture.format] : _three2.RGBAFormat;
                if (texture.internalFormat !== void 0 && _texture.format !== WEBGL_TEXTURE_FORMATS[texture.internalFormat]) {
                  console.warn("LegacyGLTFLoader: Three.js doesn't support texture internalFormat which is different from texture format. internalFormat will be forced to be the same value as format.");
                }
                _texture.type = texture.type !== void 0 ? WEBGL_TEXTURE_DATATYPES[texture.type] : _three2.UnsignedByteType;
                if (texture.sampler) {
                  var sampler = json.samplers[texture.sampler];
                  _texture.magFilter = WEBGL_FILTERS2[sampler.magFilter] || _three2.LinearFilter;
                  _texture.minFilter = WEBGL_FILTERS2[sampler.minFilter] || _three2.NearestMipmapLinearFilter;
                  _texture.wrapS = WEBGL_WRAPPINGS2[sampler.wrapS] || _three2.RepeatWrapping;
                  _texture.wrapT = WEBGL_WRAPPINGS2[sampler.wrapT] || _three2.RepeatWrapping;
                }
                resolve(_texture);
              }, void 0, function() {
                resolve();
              });
            });
          }
        });
      });
    };
    GLTFParser2.prototype.loadMaterials = function() {
      var json = this.json;
      return this._withDependencies(["shaders", "textures"]).then(function(dependencies) {
        return _each(json.materials, function(material) {
          var materialType;
          var materialValues = {};
          var materialParams = {};
          var khr_material;
          if (material.extensions && material.extensions[EXTENSIONS2.KHR_MATERIALS_COMMON]) {
            khr_material = material.extensions[EXTENSIONS2.KHR_MATERIALS_COMMON];
          }
          if (khr_material) {
            var keys = ["ambient", "emission", "transparent", "transmission", "doubleSided"];
            switch (khr_material.technique) {
              case "BLINN":
              case "PHONG":
                materialType = _three2.MeshPhongMaterial;
                keys.push("diffuse", "specular", "shininess");
                break;
              case "LAMBERT":
                materialType = _three2.MeshLambertMaterial;
                keys.push("diffuse");
                break;
              case "CONSTANT":
              default:
                materialType = _three2.MeshBasicMaterial;
                break;
            }
            keys.forEach(function(v) {
              if (khr_material.values[v] !== void 0)
                materialValues[v] = khr_material.values[v];
            });
            if (khr_material.doubleSided || materialValues.doubleSided) {
              materialParams.side = _three2.DoubleSide;
            }
            if (khr_material.transparent || materialValues.transparent) {
              materialParams.transparent = true;
              materialParams.opacity = materialValues.transmission !== void 0 ? materialValues.transmission : 1;
            }
          } else if (material.technique === void 0) {
            materialType = _three2.MeshPhongMaterial;
            Object.assign(materialValues, material.values);
          } else {
            materialType = DeferredShaderMaterial;
            var technique = json.techniques[material.technique];
            materialParams.uniforms = {};
            var program = json.programs[technique.program];
            if (program) {
              materialParams.fragmentShader = dependencies.shaders[program.fragmentShader];
              if (!materialParams.fragmentShader) {
                console.warn("ERROR: Missing fragment shader definition:", program.fragmentShader);
                materialType = _three2.MeshPhongMaterial;
              }
              var vertexShader = dependencies.shaders[program.vertexShader];
              if (!vertexShader) {
                console.warn("ERROR: Missing vertex shader definition:", program.vertexShader);
                materialType = _three2.MeshPhongMaterial;
              }
              materialParams.vertexShader = replaceTHREEShaderAttributes(vertexShader, technique);
              var uniforms = technique.uniforms;
              for (var uniformId in uniforms) {
                var pname = uniforms[uniformId];
                var shaderParam = technique.parameters[pname];
                var ptype = shaderParam.type;
                if (WEBGL_TYPE[ptype]) {
                  var pcount = shaderParam.count;
                  var value;
                  if (material.values !== void 0)
                    value = material.values[pname];
                  var uvalue = new WEBGL_TYPE[ptype]();
                  var usemantic = shaderParam.semantic;
                  var unode = shaderParam.node;
                  switch (ptype) {
                    case WEBGL_CONSTANTS2.FLOAT:
                      uvalue = shaderParam.value;
                      if (pname === "transmission") {
                        materialParams.transparent = true;
                      }
                      if (value !== void 0) {
                        uvalue = value;
                      }
                      break;
                    case WEBGL_CONSTANTS2.FLOAT_VEC2:
                    case WEBGL_CONSTANTS2.FLOAT_VEC3:
                    case WEBGL_CONSTANTS2.FLOAT_VEC4:
                    case WEBGL_CONSTANTS2.FLOAT_MAT3:
                      if (shaderParam && shaderParam.value) {
                        uvalue.fromArray(shaderParam.value);
                      }
                      if (value) {
                        uvalue.fromArray(value);
                      }
                      break;
                    case WEBGL_CONSTANTS2.FLOAT_MAT2:
                      console.warn("FLOAT_MAT2 is not a supported uniform type");
                      break;
                    case WEBGL_CONSTANTS2.FLOAT_MAT4:
                      if (pcount) {
                        uvalue = new Array(pcount);
                        for (var mi = 0; mi < pcount; mi++) {
                          uvalue[mi] = new WEBGL_TYPE[ptype]();
                        }
                        if (shaderParam && shaderParam.value) {
                          var m4v = shaderParam.value;
                          uvalue.fromArray(m4v);
                        }
                        if (value) {
                          uvalue.fromArray(value);
                        }
                      } else {
                        if (shaderParam && shaderParam.value) {
                          var m4 = shaderParam.value;
                          uvalue.fromArray(m4);
                        }
                        if (value) {
                          uvalue.fromArray(value);
                        }
                      }
                      break;
                    case WEBGL_CONSTANTS2.SAMPLER_2D:
                      if (value !== void 0) {
                        uvalue = dependencies.textures[value];
                      } else if (shaderParam.value !== void 0) {
                        uvalue = dependencies.textures[shaderParam.value];
                      } else {
                        uvalue = null;
                      }
                      break;
                  }
                  materialParams.uniforms[uniformId] = {
                    value: uvalue,
                    semantic: usemantic,
                    node: unode
                  };
                } else {
                  throw new Error("Unknown shader uniform param type: " + ptype);
                }
              }
              var states = technique.states || {};
              var enables = states.enable || [];
              var functions = states.functions || {};
              var enableCullFace = false;
              var enableDepthTest = false;
              var enableBlend = false;
              for (var i = 0, il = enables.length; i < il; i++) {
                var enable = enables[i];
                switch (STATES_ENABLES[enable]) {
                  case "CULL_FACE":
                    enableCullFace = true;
                    break;
                  case "DEPTH_TEST":
                    enableDepthTest = true;
                    break;
                  case "BLEND":
                    enableBlend = true;
                    break;
                  case "SCISSOR_TEST":
                  case "POLYGON_OFFSET_FILL":
                  case "SAMPLE_ALPHA_TO_COVERAGE":
                    break;
                  default:
                    throw new Error("Unknown technique.states.enable: " + enable);
                }
              }
              if (enableCullFace) {
                materialParams.side = functions.cullFace !== void 0 ? WEBGL_SIDES[functions.cullFace] : _three2.FrontSide;
              } else {
                materialParams.side = _three2.DoubleSide;
              }
              materialParams.depthTest = enableDepthTest;
              materialParams.depthFunc = functions.depthFunc !== void 0 ? WEBGL_DEPTH_FUNCS[functions.depthFunc] : _three2.LessDepth;
              materialParams.depthWrite = functions.depthMask !== void 0 ? functions.depthMask[0] : true;
              materialParams.blending = enableBlend ? _three2.CustomBlending : _three2.NoBlending;
              materialParams.transparent = enableBlend;
              var blendEquationSeparate = functions.blendEquationSeparate;
              if (blendEquationSeparate !== void 0) {
                materialParams.blendEquation = WEBGL_BLEND_EQUATIONS[blendEquationSeparate[0]];
                materialParams.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[blendEquationSeparate[1]];
              } else {
                materialParams.blendEquation = _three2.AddEquation;
                materialParams.blendEquationAlpha = _three2.AddEquation;
              }
              var blendFuncSeparate = functions.blendFuncSeparate;
              if (blendFuncSeparate !== void 0) {
                materialParams.blendSrc = WEBGL_BLEND_FUNCS[blendFuncSeparate[0]];
                materialParams.blendDst = WEBGL_BLEND_FUNCS[blendFuncSeparate[1]];
                materialParams.blendSrcAlpha = WEBGL_BLEND_FUNCS[blendFuncSeparate[2]];
                materialParams.blendDstAlpha = WEBGL_BLEND_FUNCS[blendFuncSeparate[3]];
              } else {
                materialParams.blendSrc = _three2.OneFactor;
                materialParams.blendDst = _three2.ZeroFactor;
                materialParams.blendSrcAlpha = _three2.OneFactor;
                materialParams.blendDstAlpha = _three2.ZeroFactor;
              }
            }
          }
          if (Array.isArray(materialValues.diffuse)) {
            materialParams.color = new _three2.Color().fromArray(materialValues.diffuse);
          } else if (typeof materialValues.diffuse === "string") {
            materialParams.map = dependencies.textures[materialValues.diffuse];
          }
          delete materialParams.diffuse;
          if (typeof materialValues.reflective === "string") {
            materialParams.envMap = dependencies.textures[materialValues.reflective];
          }
          if (typeof materialValues.bump === "string") {
            materialParams.bumpMap = dependencies.textures[materialValues.bump];
          }
          if (Array.isArray(materialValues.emission)) {
            if (materialType === _three2.MeshBasicMaterial) {
              materialParams.color = new _three2.Color().fromArray(materialValues.emission);
            } else {
              materialParams.emissive = new _three2.Color().fromArray(materialValues.emission);
            }
          } else if (typeof materialValues.emission === "string") {
            if (materialType === _three2.MeshBasicMaterial) {
              materialParams.map = dependencies.textures[materialValues.emission];
            } else {
              materialParams.emissiveMap = dependencies.textures[materialValues.emission];
            }
          }
          if (Array.isArray(materialValues.specular)) {
            materialParams.specular = new _three2.Color().fromArray(materialValues.specular);
          } else if (typeof materialValues.specular === "string") {
            materialParams.specularMap = dependencies.textures[materialValues.specular];
          }
          if (materialValues.shininess !== void 0) {
            materialParams.shininess = materialValues.shininess;
          }
          var _material = new materialType(materialParams);
          if (material.name !== void 0)
            _material.name = material.name;
          return _material;
        });
      });
    };
    GLTFParser2.prototype.loadMeshes = function() {
      var json = this.json;
      return this._withDependencies(["accessors", "materials"]).then(function(dependencies) {
        return _each(json.meshes, function(mesh) {
          var group = new _three2.Group();
          if (mesh.name !== void 0)
            group.name = mesh.name;
          if (mesh.extras)
            group.userData = mesh.extras;
          var primitives = mesh.primitives || [];
          for (var name in primitives) {
            var primitive = primitives[name];
            if (primitive.mode === WEBGL_CONSTANTS2.TRIANGLES || primitive.mode === void 0) {
              var geometry = new _three2.BufferGeometry();
              var attributes = primitive.attributes;
              for (var attributeId in attributes) {
                var attributeEntry = attributes[attributeId];
                if (!attributeEntry)
                  return;
                var bufferAttribute = dependencies.accessors[attributeEntry];
                switch (attributeId) {
                  case "POSITION":
                    geometry.setAttribute("position", bufferAttribute);
                    break;
                  case "NORMAL":
                    geometry.setAttribute("normal", bufferAttribute);
                    break;
                  case "TEXCOORD_0":
                  case "TEXCOORD0":
                  case "TEXCOORD":
                    geometry.setAttribute("uv", bufferAttribute);
                    break;
                  case "TEXCOORD_1":
                    geometry.setAttribute("uv2", bufferAttribute);
                    break;
                  case "COLOR_0":
                  case "COLOR0":
                  case "COLOR":
                    geometry.setAttribute("color", bufferAttribute);
                    break;
                  case "WEIGHT":
                    geometry.setAttribute("skinWeight", bufferAttribute);
                    break;
                  case "JOINT":
                    geometry.setAttribute("skinIndex", bufferAttribute);
                    break;
                  case "_BATCHID":
                    geometry.setAttribute("_BATCHID", bufferAttribute);
                    break;
                }
              }
              if (primitive.indices) {
                geometry.setIndex(dependencies.accessors[primitive.indices]);
              }
              var material = dependencies.materials !== void 0 ? dependencies.materials[primitive.material] : createDefaultMaterial2();
              var meshNode = new _three2.Mesh(geometry, material);
              meshNode.castShadow = true;
              meshNode.name = name === "0" ? group.name : group.name + name;
              if (primitive.extras)
                meshNode.userData = primitive.extras;
              group.add(meshNode);
            } else if (primitive.mode === WEBGL_CONSTANTS2.LINES || primitive.mode === WEBGL_CONSTANTS2.LINE_STRIP || primitive.mode === WEBGL_CONSTANTS2.LINE_LOOP) {
              var geometry = new _three2.BufferGeometry();
              var attributes = primitive.attributes;
              for (var attributeId in attributes) {
                var attributeEntry = attributes[attributeId];
                if (!attributeEntry)
                  return;
                var bufferAttribute = dependencies.accessors[attributeEntry];
                switch (attributeId) {
                  case "POSITION":
                    geometry.setAttribute("position", bufferAttribute);
                    break;
                  case "COLOR_0":
                  case "COLOR0":
                  case "COLOR":
                    geometry.setAttribute("color", bufferAttribute);
                    break;
                }
              }
              var material = dependencies.materials[primitive.material];
              var meshNode;
              if (primitive.indices) {
                geometry.setIndex(dependencies.accessors[primitive.indices]);
                meshNode = new _three2.LineSegments(geometry, material);
              } else {
                if (primitive.mode === WEBGL_CONSTANTS2.LINES) {
                  meshNode = new _three2.LineSegments(geometry, material);
                } else if (primitive.mode === WEBGL_CONSTANTS2.LINE_LOOP) {
                  meshNode = new _three2.LineLoop(geometry, material);
                } else {
                  meshNode = new _three2.Line(geometry, material);
                }
              }
              meshNode.name = name === "0" ? group.name : group.name + name;
              if (primitive.extras)
                meshNode.userData = primitive.extras;
              group.add(meshNode);
            } else {
              console.warn("Only triangular and line primitives are supported");
            }
          }
          return group;
        });
      });
    };
    GLTFParser2.prototype.loadCameras = function() {
      var json = this.json;
      return _each(json.cameras, function(camera) {
        if (camera.type === "perspective" && camera.perspective) {
          var yfov = camera.perspective.yfov;
          var aspectRatio = camera.perspective.aspectRatio !== void 0 ? camera.perspective.aspectRatio : 1;
          var _camera2 = new _three2.PerspectiveCamera(_three2.MathUtils.radToDeg(yfov * aspectRatio), aspectRatio, camera.perspective.znear || 1, camera.perspective.zfar || 2e6);
          if (camera.name !== void 0)
            _camera2.name = camera.name;
          if (camera.extras)
            _camera2.userData = camera.extras;
          return _camera2;
        } else if (camera.type === "orthographic" && camera.orthographic) {
          var _camera2 = new _three2.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, camera.orthographic.znear, camera.orthographic.zfar);
          if (camera.name !== void 0)
            _camera2.name = camera.name;
          if (camera.extras)
            _camera2.userData = camera.extras;
          return _camera2;
        }
      });
    };
    GLTFParser2.prototype.loadSkins = function() {
      var json = this.json;
      return this._withDependencies(["accessors"]).then(function(dependencies) {
        return _each(json.skins, function(skin) {
          var bindShapeMatrix = new _three2.Matrix4();
          if (skin.bindShapeMatrix !== void 0)
            bindShapeMatrix.fromArray(skin.bindShapeMatrix);
          var _skin = {
            bindShapeMatrix,
            jointNames: skin.jointNames,
            inverseBindMatrices: dependencies.accessors[skin.inverseBindMatrices]
          };
          return _skin;
        });
      });
    };
    GLTFParser2.prototype.loadAnimations = function() {
      var json = this.json;
      return this._withDependencies(["accessors", "nodes"]).then(function(dependencies) {
        return _each(json.animations, function(animation, animationId) {
          var tracks = [];
          for (var channelId in animation.channels) {
            var channel = animation.channels[channelId];
            var sampler = animation.samplers[channel.sampler];
            if (sampler) {
              var target = channel.target;
              var name = target.id;
              var input = animation.parameters !== void 0 ? animation.parameters[sampler.input] : sampler.input;
              var output = animation.parameters !== void 0 ? animation.parameters[sampler.output] : sampler.output;
              var inputAccessor = dependencies.accessors[input];
              var outputAccessor = dependencies.accessors[output];
              var node = dependencies.nodes[name];
              if (node) {
                node.updateMatrix();
                node.matrixAutoUpdate = true;
                var TypedKeyframeTrack = PATH_PROPERTIES2[target.path] === PATH_PROPERTIES2.rotation ? _three2.QuaternionKeyframeTrack : _three2.VectorKeyframeTrack;
                var targetName = node.name ? node.name : node.uuid;
                var interpolation = sampler.interpolation !== void 0 ? INTERPOLATION2[sampler.interpolation] : _three2.InterpolateLinear;
                tracks.push(new TypedKeyframeTrack(targetName + "." + PATH_PROPERTIES2[target.path], _three2.AnimationUtils.arraySlice(inputAccessor.array, 0), _three2.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation));
              }
            }
          }
          var name = animation.name !== void 0 ? animation.name : "animation_" + animationId;
          return new _three2.AnimationClip(name, void 0, tracks);
        });
      });
    };
    GLTFParser2.prototype.loadNodes = function() {
      var json = this.json;
      var extensions = this.extensions;
      var scope = this;
      return _each(json.nodes, function(node) {
        var matrix = new _three2.Matrix4();
        var _node;
        if (node.jointName) {
          _node = new _three2.Bone();
          _node.name = node.name !== void 0 ? node.name : node.jointName;
          _node.jointName = node.jointName;
        } else {
          _node = new _three2.Object3D();
          if (node.name !== void 0)
            _node.name = node.name;
        }
        if (node.extras)
          _node.userData = node.extras;
        if (node.matrix !== void 0) {
          matrix.fromArray(node.matrix);
          _node.applyMatrix4(matrix);
        } else {
          if (node.translation !== void 0) {
            _node.position.fromArray(node.translation);
          }
          if (node.rotation !== void 0) {
            _node.quaternion.fromArray(node.rotation);
          }
          if (node.scale !== void 0) {
            _node.scale.fromArray(node.scale);
          }
        }
        return _node;
      }).then(function(__nodes) {
        return scope._withDependencies(["meshes", "skins", "cameras"]).then(function(dependencies) {
          return _each(__nodes, function(_node, nodeId) {
            var node = json.nodes[nodeId];
            if (node.meshes !== void 0) {
              for (var meshId in node.meshes) {
                var mesh = node.meshes[meshId];
                var group = dependencies.meshes[mesh];
                if (group === void 0) {
                  console.warn(`LegacyGLTFLoader: Couldn't find node "` + mesh + '".');
                  continue;
                }
                for (var childrenId in group.children) {
                  var child = group.children[childrenId];
                  var originalMaterial = child.material;
                  var originalGeometry = child.geometry;
                  var originalUserData = child.userData;
                  var originalName = child.name;
                  var material;
                  if (originalMaterial.isDeferredShaderMaterial) {
                    originalMaterial = material = originalMaterial.create();
                  } else {
                    material = originalMaterial;
                  }
                  switch (child.type) {
                    case "LineSegments":
                      child = new _three2.LineSegments(originalGeometry, material);
                      break;
                    case "LineLoop":
                      child = new _three2.LineLoop(originalGeometry, material);
                      break;
                    case "Line":
                      child = new _three2.Line(originalGeometry, material);
                      break;
                    default:
                      child = new _three2.Mesh(originalGeometry, material);
                  }
                  child.castShadow = true;
                  child.userData = originalUserData;
                  child.name = originalName;
                  var skinEntry;
                  if (node.skin) {
                    skinEntry = dependencies.skins[node.skin];
                  }
                  if (skinEntry) {
                    var getJointNode = function getJointNode2(jointId2) {
                      var keys = Object.keys(__nodes);
                      for (var i2 = 0, il = keys.length; i2 < il; i2++) {
                        var n = __nodes[keys[i2]];
                        if (n.jointName === jointId2)
                          return n;
                      }
                      return null;
                    };
                    var material = originalMaterial;
                    child = new _three2.SkinnedMesh(originalGeometry, material);
                    child.castShadow = true;
                    child.userData = originalUserData;
                    child.name = originalName;
                    var bones = [];
                    var boneInverses = [];
                    for (var i = 0, l = skinEntry.jointNames.length; i < l; i++) {
                      var jointId = skinEntry.jointNames[i];
                      var jointNode = getJointNode(jointId);
                      if (jointNode) {
                        bones.push(jointNode);
                        var m = skinEntry.inverseBindMatrices.array;
                        var mat = new _three2.Matrix4().fromArray(m, i * 16);
                        boneInverses.push(mat);
                      } else {
                        console.warn("WARNING: joint: '" + jointId + "' could not be found");
                      }
                    }
                    child.bind(new _three2.Skeleton(bones, boneInverses), skinEntry.bindShapeMatrix);
                    var buildBoneGraph = function buildBoneGraph2(parentJson, parentObject, property) {
                      var children = parentJson[property];
                      if (children === void 0)
                        return;
                      for (var i2 = 0, il = children.length; i2 < il; i2++) {
                        var nodeId2 = children[i2];
                        var bone = __nodes[nodeId2];
                        var boneJson = json.nodes[nodeId2];
                        if (bone !== void 0 && bone.isBone === true && boneJson !== void 0) {
                          parentObject.add(bone);
                          buildBoneGraph2(boneJson, bone, "children");
                        }
                      }
                    };
                    buildBoneGraph(node, child, "skeletons");
                  }
                  _node.add(child);
                }
              }
            }
            if (node.camera !== void 0) {
              var camera = dependencies.cameras[node.camera];
              _node.add(camera);
            }
            if (node.extensions && node.extensions[EXTENSIONS2.KHR_MATERIALS_COMMON] && node.extensions[EXTENSIONS2.KHR_MATERIALS_COMMON].light) {
              var extensionLights = extensions[EXTENSIONS2.KHR_MATERIALS_COMMON].lights;
              var light = extensionLights[node.extensions[EXTENSIONS2.KHR_MATERIALS_COMMON].light];
              _node.add(light);
            }
            return _node;
          });
        });
      });
    };
    GLTFParser2.prototype.loadScenes = function() {
      var json = this.json;
      function buildNodeHierachy(nodeId, parentObject, allNodes) {
        var _node = allNodes[nodeId];
        parentObject.add(_node);
        var node = json.nodes[nodeId];
        if (node.children) {
          var children = node.children;
          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            buildNodeHierachy(child, _node, allNodes);
          }
        }
      }
      return this._withDependencies(["nodes"]).then(function(dependencies) {
        return _each(json.scenes, function(scene) {
          var _scene = new _three2.Scene();
          if (scene.name !== void 0)
            _scene.name = scene.name;
          if (scene.extras)
            _scene.userData = scene.extras;
          var nodes = scene.nodes || [];
          for (var i = 0, l = nodes.length; i < l; i++) {
            var nodeId = nodes[i];
            buildNodeHierachy(nodeId, _scene, dependencies.nodes);
          }
          _scene.traverse(function(child) {
            if (child.material && child.material.isRawShaderMaterial) {
              child.gltfShader = new GLTFShader(child, dependencies.nodes);
              child.onBeforeRender = function(renderer, scene2, camera) {
                this.gltfShader.update(scene2, camera);
              };
            }
          });
          return _scene;
        });
      });
    };
    return LegacyGLTFLoader2;
  }();
  LegacyGLTFLoader.default = _default2;
  return LegacyGLTFLoader;
}
var BatchTableParser = {};
var Utf8Decoder = {};
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0)
    return {};
  if (o === Object(o))
    return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string) {
  var s = String(string);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d = string.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b = d & 1023;
          u.push(65536 + (a << 10) + b);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s;
}
var end_of_stream = -1;
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    if (!this.tokens.length)
      return end_of_stream;
    return this.tokens.shift();
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(token) {
    if (Array.isArray(token)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token
      );
      while (tokens.length)
        this.tokens.unshift(tokens.pop());
    } else {
      this.tokens.unshift(token);
    }
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(token) {
    if (Array.isArray(token)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token
      );
      while (tokens.length)
        this.tokens.push(tokens.shift());
    } else {
      this.tokens.push(token);
    }
  }
};
var finished = -1;
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(encoding2, options) {
  if (!(this instanceof TextDecoder$1)) {
    return new TextDecoder$1(encoding2, options);
  }
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function decode2(input, options) {
    var bytes;
    if (typeof input === "object" && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(
        input.buffer,
        input.byteOffset,
        input.byteLength
      );
    } else {
      bytes = new Uint8Array(0);
    }
    options = ToDictionary(options);
    if (!this._streaming) {
      this._decoder = new UTF8Decoder({ fatal: this._fatal });
      this._BOMseen = false;
    }
    this._streaming = Boolean(options["stream"]);
    var input_stream = new Stream(bytes);
    var code_points = [];
    var result;
    while (!input_stream.endOfStream()) {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        code_points.push.apply(
          code_points,
          /**@type {!Array.<number>}*/
          result
        );
      else
        code_points.push(result);
    }
    if (!this._streaming) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(
            code_points,
            /**@type {!Array.<number>}*/
            result
          );
        else
          code_points.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }
    if (code_points.length) {
      if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
        if (code_points[0] === 65279) {
          this._BOMseen = true;
          code_points.shift();
        } else {
          this._BOMseen = true;
        }
      }
    }
    return codePointsToString(code_points);
  }
};
function TextEncoder$1(encoding2, options) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(encoding2, options);
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function encode2(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : "";
    options = ToDictionary(options);
    if (!this._streaming)
      this._encoder = new UTF8Encoder(this._options);
    this._streaming = Boolean(options["stream"]);
    var bytes = [];
    var input_stream = new Stream(stringToCodePoints(opt_string));
    var result;
    while (!input_stream.endOfStream()) {
      result = this._encoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        bytes.push.apply(
          bytes,
          /**@type {!Array.<number>}*/
          result
        );
      else
        bytes.push(result);
    }
    if (!this._streaming) {
      while (true) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes.push.apply(
            bytes,
            /**@type {!Array.<number>}*/
            result
          );
        else
          bytes.push(result);
      }
      this._encoder = null;
    }
    return new Uint8Array(bytes);
  }
};
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count, offset;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset = 240;
    }
    var bytes = [(code_point >> 6 * count) + offset];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes.push(128 | temp & 63);
      count -= 1;
    }
    return bytes;
  };
}
const encoding = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(encoding);
var hasRequiredUtf8Decoder;
function requireUtf8Decoder() {
  if (hasRequiredUtf8Decoder)
    return Utf8Decoder;
  hasRequiredUtf8Decoder = 1;
  Object.defineProperty(Utf8Decoder, "__esModule", {
    value: true
  });
  Utf8Decoder.default = Utf8Decoder.TextDecoder = void 0;
  var _textEncodingUtf = require$$0$2;
  var TextDecoder2 = typeof commonjsGlobal.TextDecoder === "function" ? commonjsGlobal.TextDecoder : _textEncodingUtf.TextDecoder;
  Utf8Decoder.TextDecoder = TextDecoder2;
  var _default2 = new TextDecoder2("utf-8");
  Utf8Decoder.default = _default2;
  return Utf8Decoder;
}
var hasRequiredBatchTableParser;
function requireBatchTableParser() {
  if (hasRequiredBatchTableParser)
    return BatchTableParser;
  hasRequiredBatchTableParser = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(BatchTableParser, "__esModule", {
    value: true
  });
  BatchTableParser.default = void 0;
  var _Utf8Decoder = _interopRequireDefault2(requireUtf8Decoder());
  var _default2 = {
    /** @module BatchTableParser */
    /**
     * Parse batch table buffer and convert to JSON
     *
     * @param {ArrayBuffer} buffer the batch table buffer.
     * @returns {Promise} - a promise that resolves with a JSON object.
     */
    parse: function parse2(buffer2) {
      var content = _Utf8Decoder.default.decode(new Uint8Array(buffer2));
      var json = JSON.parse(content);
      return Promise.resolve(json);
    }
  };
  BatchTableParser.default = _default2;
  return BatchTableParser;
}
var ShaderUtils = {};
var hasRequiredShaderUtils;
function requireShaderUtils() {
  if (hasRequiredShaderUtils)
    return ShaderUtils;
  hasRequiredShaderUtils = 1;
  Object.defineProperty(ShaderUtils, "__esModule", {
    value: true
  });
  ShaderUtils.default = void 0;
  var PrecisionQualifier = "precision highp float;\nprecision highp int;\n";
  var rePosition = new RegExp("gl_Position.*(?![^]*gl_Position)");
  var reMain = new RegExp("[^\\w]*main[^\\w]*(void)?[^\\w]*{");
  var _default2 = {
    patchMaterialForLogDepthSupport: function patchMaterialForLogDepthSupport(material) {
      if (material.vertexShader.indexOf("USE_LOGDEPTHBUF") !== -1 || material.vertexShader.indexOf("logdepthbuf_pars_vertex") !== -1) {
        return;
      }
      material.vertexShader = "#include <logdepthbuf_pars_vertex>\n#define EPSILON 1e-6\n".concat(material.vertexShader);
      var re = rePosition.exec(material.vertexShader);
      var idx = re[0].length + re.index;
      material.vertexShader = "".concat(material.vertexShader.slice(0, idx), "\n#include <logdepthbuf_vertex>\n").concat(material.vertexShader.slice(idx));
      material.fragmentShader = "".concat(PrecisionQualifier, "\n#include <logdepthbuf_pars_fragment>\n").concat(material.fragmentShader);
      re = reMain.exec(material.fragmentShader);
      idx = re[0].length + re.index;
      material.fragmentShader = "".concat(material.fragmentShader.slice(0, idx), "\n#include <logdepthbuf_fragment>\n").concat(material.fragmentShader.slice(idx));
      material.defines = {
        USE_LOGDEPTHBUF: 1,
        USE_LOGDEPTHBUF_EXT: 1
      };
    }
  };
  ShaderUtils.default = _default2;
  return ShaderUtils;
}
var hasRequiredB3dmParser;
function requireB3dmParser() {
  if (hasRequiredB3dmParser)
    return B3dmParser;
  hasRequiredB3dmParser = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(B3dmParser, "__esModule", {
    value: true
  });
  B3dmParser.default = void 0;
  var _typeof2 = _interopRequireDefault2(_typeofExports);
  var _three2 = require$$8$1;
  var _GLTFLoader = require$$3$3;
  var _LegacyGLTFLoader = _interopRequireDefault2(requireLegacyGLTFLoader());
  var _BatchTableParser = _interopRequireDefault2(requireBatchTableParser());
  var _Capabilities = _interopRequireDefault2(requireCapabilities());
  var _ShaderUtils = _interopRequireDefault2(requireShaderUtils());
  var _Utf8Decoder = _interopRequireDefault2(requireUtf8Decoder());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var matrixChangeUpVectorZtoY = new _three2.Matrix4().makeRotationX(Math.PI / 2);
  var matrixChangeUpVectorZtoX = new _three2.Matrix4().makeRotationZ(-Math.PI / 2);
  var glTFLoader = new _GLTFLoader.GLTFLoader();
  var legacyGLTFLoader = new _LegacyGLTFLoader.default();
  function filterUnsupportedSemantics(obj) {
    var supported = ["MODELVIEW", "MODELVIEWINVERSETRANSPOSE", "PROJECTION", "JOINTMATRIX"];
    if (obj.gltfShader) {
      var names2 = [];
      for (var _i = 0, _Object$keys = Object.keys(obj.gltfShader.boundUniforms); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i];
        names2.push(name);
      }
      for (var _i2 = 0, _names = names2; _i2 < _names.length; _i2++) {
        var _name = _names[_i2];
        var semantic = obj.gltfShader.boundUniforms[_name].semantic;
        if (supported.indexOf(semantic) < 0) {
          delete obj.gltfShader.boundUniforms[_name];
        }
      }
    }
  }
  function applyOptionalCesiumRTC(data, gltf) {
    var headerView = new DataView(data, 0, 20);
    var contentArray = new Uint8Array(data, 20, headerView.getUint32(12, true));
    var content = _Utf8Decoder.default.decode(new Uint8Array(contentArray));
    var json = JSON.parse(content);
    if (json.extensions && json.extensions.CESIUM_RTC) {
      gltf.position.fromArray(json.extensions.CESIUM_RTC.center);
      gltf.updateMatrixWorld(true);
    }
  }
  var _default2 = {
    /** @module B3dmParser */
    /**
     * Parse b3dm buffer and extract Scene and batch table
     *
     * @param {ArrayBuffer} buffer the b3dm buffer.
     * @param {object} options additional properties.
     * @param {string=} [options.gltfUpAxis='Y'] embedded glTF model up axis.
     * @param {string} options.urlBase the base url of the b3dm file (used to fetch textures for
     * the embedded glTF model).
     * @param {boolean=} [options.doNotPatchMaterial='false'] disable patching material with
     * logarithmic depth buffer support.
     * @param {number} [options.opacity=1.0] the b3dm opacity.
     * @param {boolean|Material} [options.overrideMaterials='false'] override b3dm's embedded
     * glTF materials. If overrideMaterials is a three.js material, it will be the material used to
     * override.
     * @returns {Promise} - a promise that resolves with an object containig
     * a Scene (gltf) and a batch table (batchTable).
     */
    parse: function parse2(buffer2, options) {
      var gltfUpAxis = options.gltfUpAxis;
      var urlBase = options.urlBase;
      if (!buffer2) {
        throw new Error("No array buffer provided.");
      }
      var view = new DataView(buffer2, 4);
      var byteOffset = 0;
      var b3dmHeader = {};
      b3dmHeader.magic = _Utf8Decoder.default.decode(new Uint8Array(buffer2, 0, 4));
      if (b3dmHeader.magic) {
        b3dmHeader.version = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        b3dmHeader.byteLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        b3dmHeader.FTJSONLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        b3dmHeader.FTBinaryLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        b3dmHeader.BTJSONLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        b3dmHeader.BTBinaryLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        var promises = [];
        if (b3dmHeader.BTJSONLength > 0) {
          var sizeBegin = 28 + b3dmHeader.FTJSONLength + b3dmHeader.FTBinaryLength;
          promises.push(_BatchTableParser.default.parse(buffer2.slice(sizeBegin, b3dmHeader.BTJSONLength + sizeBegin)));
        } else {
          promises.push(Promise.resolve({}));
        }
        promises.push(new Promise(function(resolve) {
          var onerror = function(error) {
            return console.error(error);
          };
          var onload = function(gltf) {
            var _iterator = _createForOfIteratorHelper2(gltf.scenes), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var scene = _step.value;
                scene.traverse(filterUnsupportedSemantics);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            if (gltfUpAxis === void 0 || gltfUpAxis === "Y") {
              gltf.scene.applyMatrix4(matrixChangeUpVectorZtoY);
            } else if (gltfUpAxis === "X") {
              gltf.scene.applyMatrix4(matrixChangeUpVectorZtoX);
            }
            applyOptionalCesiumRTC(buffer2.slice(28 + b3dmHeader.FTJSONLength + b3dmHeader.FTBinaryLength + b3dmHeader.BTJSONLength + b3dmHeader.BTBinaryLength), gltf.scene);
            gltf.scene.traverse(function(mesh) {
              mesh.frustumCulled = false;
              if (!mesh.material) {
                return;
              }
              if (options.overrideMaterials) {
                mesh.material.dispose();
                if ((0, _typeof2.default)(options.overrideMaterials) === "object" && options.overrideMaterials.isMaterial) {
                  mesh.material = options.overrideMaterials.clone();
                } else {
                  mesh.material = new _three2.MeshLambertMaterial({
                    color: 16777215
                  });
                }
              } else if (_Capabilities.default.isLogDepthBufferSupported() && mesh.material.isRawShaderMaterial && !options.doNotPatchMaterial) {
                _ShaderUtils.default.patchMaterialForLogDepthSupport(mesh.material);
                console.warn("b3dm shader has been patched to add log depth buffer support");
              }
              mesh.material.transparent = options.opacity < 1;
              mesh.material.opacity = options.opacity;
            });
            resolve(gltf);
          };
          var gltfBuffer = buffer2.slice(28 + b3dmHeader.FTJSONLength + b3dmHeader.FTBinaryLength + b3dmHeader.BTJSONLength + b3dmHeader.BTBinaryLength);
          var version = new DataView(gltfBuffer, 0, 20).getUint32(4, true);
          if (version === 1) {
            legacyGLTFLoader.parse(gltfBuffer, onload, urlBase);
          } else {
            glTFLoader.parse(gltfBuffer, urlBase, onload, onerror);
          }
        }));
        return Promise.all(promises).then(function(values) {
          return {
            gltf: values[1],
            batchTable: values[0]
          };
        });
      }
      throw new Error("Invalid b3dm file.");
    }
  };
  B3dmParser.default = _default2;
  return B3dmParser;
}
var PntsParser = {};
var hasRequiredPntsParser;
function requirePntsParser() {
  if (hasRequiredPntsParser)
    return PntsParser;
  hasRequiredPntsParser = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(PntsParser, "__esModule", {
    value: true
  });
  PntsParser.default = void 0;
  var _three2 = require$$8$1;
  var _BatchTableParser = _interopRequireDefault2(requireBatchTableParser());
  var _Utf8Decoder = _interopRequireDefault2(requireUtf8Decoder());
  var _default2 = {
    /** @module PntsParser */
    /**
     * Parse pnts buffer and extract Points and batch table
     *
     * @param {ArrayBuffer} buffer the pnts buffer.
     * @returns {Promise} - a promise that resolves with an object containig a Points (point)
     * and a batch table (batchTable).
     */
    parse: function(buffer2) {
      if (!buffer2) {
        throw new Error("No array buffer provided.");
      }
      var view = new DataView(buffer2);
      var byteOffset = 0;
      var pntsHeader = {};
      var batchTable = {};
      var point = {};
      pntsHeader.magic = _Utf8Decoder.default.decode(new Uint8Array(buffer2, byteOffset, 4));
      byteOffset += 4;
      if (pntsHeader.magic) {
        pntsHeader.version = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        pntsHeader.byteLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        pntsHeader.FTJSONLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        pntsHeader.FTBinaryLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        pntsHeader.BTJSONLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        pntsHeader.BTBinaryLength = view.getUint32(byteOffset, true);
        byteOffset += Uint32Array.BYTES_PER_ELEMENT;
        if (pntsHeader.FTBinaryLength > 0) {
          point = parseFeatureBinary(buffer2, byteOffset, pntsHeader.FTJSONLength);
        }
        if (pntsHeader.BTJSONLength > 0) {
          var sizeBegin = 28 + pntsHeader.FTJSONLength + pntsHeader.FTBinaryLength;
          batchTable = _BatchTableParser.default.parse(buffer2.slice(sizeBegin, pntsHeader.BTJSONLength + sizeBegin));
        }
        var pnts = {
          point,
          batchTable
        };
        return Promise.resolve(pnts);
      }
      throw new Error("Invalid pnts file.");
    }
  };
  PntsParser.default = _default2;
  function parseFeatureBinary(array, byteOffset, FTJSONLength) {
    var geometry = new _three2.BufferGeometry();
    var subArrayJson = _Utf8Decoder.default.decode(new Uint8Array(array, byteOffset, FTJSONLength));
    var parseJSON = JSON.parse(subArrayJson);
    var lengthFeature;
    if (parseJSON.POINTS_LENGTH) {
      lengthFeature = parseJSON.POINTS_LENGTH;
    }
    if (parseJSON.POSITION) {
      var byteOffsetPos = parseJSON.POSITION.byteOffset + subArrayJson.length + byteOffset;
      var positionArray = new Float32Array(array, byteOffsetPos, lengthFeature * 3);
      geometry.setAttribute("position", new _three2.BufferAttribute(positionArray, 3));
    }
    if (parseJSON.RGB) {
      var byteOffsetCol = parseJSON.RGB.byteOffset + subArrayJson.length + byteOffset;
      var colorArray = new Uint8Array(array, byteOffsetCol, lengthFeature * 3);
      geometry.setAttribute("color", new _three2.BufferAttribute(colorArray, 3, true));
    }
    if (parseJSON.POSITION_QUANTIZED) {
      throw new Error("For pnts loader, POSITION_QUANTIZED: not yet managed");
    }
    if (parseJSON.RGBA) {
      throw new Error("For pnts loader, RGBA: not yet managed");
    }
    if (parseJSON.RGB565) {
      throw new Error("For pnts loader, RGB565: not yet managed");
    }
    if (parseJSON.NORMAL) {
      throw new Error("For pnts loader, NORMAL: not yet managed");
    }
    if (parseJSON.NORMAL_OCT16P) {
      throw new Error("For pnts loader, NORMAL_OCT16P: not yet managed");
    }
    if (parseJSON.BATCH_ID) {
      throw new Error("For pnts loader, BATCH_ID: not yet managed");
    }
    var offset = parseJSON.RTC_CENTER ? new _three2.Vector3().fromArray(parseJSON.RTC_CENTER) : void 0;
    return {
      geometry,
      offset
    };
  }
  return PntsParser;
}
var Points2 = {};
var PointsMaterial2 = {};
var hasRequiredPointsMaterial;
function requirePointsMaterial() {
  if (hasRequiredPointsMaterial)
    return PointsMaterial2;
  hasRequiredPointsMaterial = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(PointsMaterial2, "__esModule", {
    value: true
  });
  PointsMaterial2.default = PointsMaterial2.MODE = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _get2 = _interopRequireDefault2(requireGet());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  var _Capabilities = _interopRequireDefault2(requireCapabilities());
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var PointsVS = "precision highp float;\nprecision highp int;\n\n#include <logdepthbuf_pars_vertex>\n#define EPSILON 1e-6\n\nattribute vec3 position;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float size;\n\nuniform int pickingId;\nuniform int mode;\nuniform float opacity;\nuniform vec4 overlayColor;\nattribute vec3 color;\nattribute vec4 unique_id;\nattribute float intensity;\n\n#if defined(NORMAL_OCT16)\nattribute vec2 oct16Normal;\n#elif defined(NORMAL_SPHEREMAPPED)\nattribute vec2 sphereMappedNormal;\n#else\nattribute vec3 normal;\n#endif\n\nuniform sampler2D overlayTexture;\nuniform vec4 offsetScale;\nuniform vec2 extentTopLeft;\nuniform vec2 extentSize;\n\nvarying vec4 vColor;\n\n// see https://web.archive.org/web/20150303053317/http://lgdv.cs.fau.de/get/1602\n// and implementation in PotreeConverter (BINPointReader.cpp) and potree (BinaryDecoderWorker.js)\n#if defined(NORMAL_OCT16)\nvec3 decodeOct16Normal(vec2 encodedNormal) {\n    vec2 nNorm = 2. * (encodedNormal / 255.) - 1.;\n    vec3 n;\n    n.z = 1. - abs(nNorm.x) - abs(nNorm.y);\n    if (n.z >= 0.) {\n        n.x = nNorm.x;\n        n.y = nNorm.y;\n    } else {\n        n.x = sign(nNorm.x) - sign(nNorm.x) * sign(nNorm.y) * nNorm.y;\n        n.y = sign(nNorm.y) - sign(nNorm.y) * sign(nNorm.x) * nNorm.x;\n    }\n    return normalize(n);\n}\n#elif defined(NORMAL_SPHEREMAPPED)\n// see http://aras-p.info/texts/CompactNormalStorage.html method #4\n// or see potree's implementation in BINPointReader.cpp\nvec3 decodeSphereMappedNormal(vec2 encodedNormal) {\n    vec2 fenc = 2. * encodedNormal / 255. - 1.;\n    float f = dot(fenc,fenc);\n    float g = 2. * sqrt(1. - f);\n    vec3 n;\n    n.xy = fenc * g;\n    n.z = 1. - 2. * f;\n    return n;\n}\n#endif\n\n#ifdef DEFORMATION_SUPPORT\nuniform int enableTransfo;\nuniform mat4 transformations[NUM_TRANSFO];\nuniform vec3 vec[NUM_TRANSFO];\nuniform vec2 origin[NUM_TRANSFO];\nuniform vec2 influence[NUM_TRANSFO];\nuniform vec4 tColors[NUM_TRANSFO];\n#endif\n\nvoid main() {\n\n#if defined(NORMAL_OCT16)\n    vec3  normal = decodeOct16Normal(oct16Normal);\n#elif defined(NORMAL_SPHEREMAPPED)\n    vec3 normal = decodeSphereMappedNormal(sphereMappedNormal);\n#elif defined(NORMAL)\n    // nothing to do\n#else\n    // default to color\n    vec3 normal = color;\n#endif\n\n    if (pickingId > 0) {\n        vColor = unique_id;\n\n        int left4bitsShift = 16; // << 4 <=> * 2^4\n        int left8bitsShift = left4bitsShift * left4bitsShift;\n        // 20 bits for 'unique_id' (= the point index in the buffer)\n        // 12 bits for 'pickingId' (= the point instance id)\n        // (see Picking.js)\n        //     = |4bits||     8 bits     |\n        //          ^ left-most 4 bits of the green channel\n        //                     ^ red channel\n        int upperPart = pickingId / left8bitsShift;\n        int lowerPart = pickingId - upperPart * left8bitsShift; // 8 bits\n        vColor.r = float(lowerPart) / 255.0;\n        vColor.g += float(upperPart * 8) / 255.0; // << 4\n        // vColor.g += float(upperPart * left4bitsShift) / 255.0;\n    } else if (mode == MODE_INTENSITY) {\n        vColor = vec4(intensity, intensity, intensity, opacity);\n    } else if (mode == MODE_NORMAL) {\n        vColor = vec4(abs(normal), opacity);\n    } else if (mode == MODE_TEXTURE) {\n        vec2 pp = (modelMatrix * vec4(position, 1.0)).xy;\n        // offsetScale is from topleft\n        pp.x -= extentTopLeft.x;\n        pp.y = extentTopLeft.y - pp.y;\n        pp *= offsetScale.zw / extentSize;\n        pp += offsetScale.xy;\n        pp.y = 1.0 - pp.y;\n        vec3 textureColor = texture2D(overlayTexture, pp).rgb;\n        vColor = vec4(mix(textureColor, overlayColor.rgb, overlayColor.a), opacity);\n    } else if (mode == MODE_ELEVATION) {\n        float z = (modelMatrix * vec4(position, 1.0)).z;\n        // colors from OGC EL.GridCoverage.Default style\n        if (z < -100.0) {\n            vColor = vec4(float(0x00) / 255.0, float(0x5C) / 255.0, float(0xE6) / 255.0, 1.0);\n        } else if (z <= 0.0) {\n            vColor = mix(\n                vec4(float(0x00) / 255.0, float(0x5C) / 255.0, float(0xE6) / 255.0, 1.0),\n                vec4(float(0x28) / 255.0, float(0xED) / 255.0, float(0xD6) / 255.0, 1.0),\n                -z / 100.0);\n        } else if (z <= 50.0) {\n            vColor = mix(\n                vec4(float(0x00) / 255.0, float(0x5C) / 255.0, float(0xE6) / 255.0, 1.0),\n                vec4(float(0x28) / 255.0, float(0xED) / 255.0, float(0xD6) / 255.0, 1.0),\n                -z / 100.0);\n        } else if (z <= 50.0) {\n            vColor = mix(\n                vec4(float(0x28) / 255.0, float(0xED) / 255.0, float(0xD6) / 255.0, 1.0),\n                vec4(float(0x54) / 255.0, float(0xF7) / 255.0, float(0x6D) / 255.0, 1.0),\n                z / 50.0);\n        } else if (z <= 100.0) {\n            vColor = mix(\n                vec4(float(0x54) / 255.0, float(0xF7) / 255.0, float(0x6D) / 255.0, 1.0),\n                vec4(float(0x9A) / 255.0, float(0xFA) / 255.0, float(0x66) / 255.0, 1.0),\n                (z - 50.0)/ 50.0);\n        } else {\n            vColor = mix(\n                vec4(float(0x9A) / 255.0, float(0xFA) / 255.0, float(0x66) / 255.0, 1.0),\n                vec4(float(0x7B) / 255.0, float(0xF2) / 255.0, float(0x3A) / 255.0, 1.0),\n                (z - 100.0)/ 50.0);\n        }\n        vColor.a = opacity;\n    } else {\n        // default to color mode\n        vColor = vec4(mix(color, overlayColor.rgb, overlayColor.a), opacity);\n    }\n\n    mat4 mvMatrix = modelViewMatrix;\n\n    #ifdef DEFORMATION_SUPPORT\n    if (!pickingMode) {\n        vColor = enableTransfo > 0 ?\n            vec4(0.0, 1.0, 1.0, 1.0):\n            vec4(1.0, 0.0, 1.0, 1.0);\n    }\n    if (enableTransfo > 0) {\n        vec4 mPosition = modelMatrix * vec4(position, 1.0);\n        float minDistance = 1000.0;\n        int bestChoice = -1;\n        for (int i = 0; i < NUM_TRANSFO; i++) {\n            if (i >= enableTransfo) {\n                break;\n            }\n            vec2 v = vec[i].xy;\n            float length = vec[i].z;\n            float depassement_x =\n                length * (influence[i].x - 1.0);\n\n            vec2 diff = mPosition.xy - origin[i];\n            float distance_x = dot(diff, v);\n\n            if (-depassement_x <= distance_x &&\n                    distance_x <= (length + depassement_x)) {\n                vec2 normal = vec2(-v.y, v.x);\n                float d = abs(dot(diff, normal));\n                if (d < minDistance && d <= influence[i].y) {\n                    minDistance = d;\n                    bestChoice = i;\n                }\n            }\n        }\n\n        if (bestChoice >= 0) {\n            // override modelViewMatrix\n            mvMatrix = transformations[bestChoice];\n            vColor = mix(\n                tColors[bestChoice],\n                vec4(color, 1.0),\n                0.5);\n        }\n    }\n    #endif\n\n    vec4 mvPosition = mvMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    if (size > 0.) {\n        gl_PointSize = size;\n    } else {\n        gl_PointSize = clamp(-size / gl_Position.w, 3.0, 10.0);\n    }\n\n    #include <logdepthbuf_vertex>\n}\n";
  var PointsFS = "precision highp float;\nprecision highp int;\n\n#include <logdepthbuf_pars_fragment>\n\nvarying vec4 vColor;\n\nvoid main() {\n    // circular point rendering\n    if(length(gl_PointCoord - 0.5) > 0.5){\n        discard;\n    }\n\n    gl_FragColor = vColor;\n\n    #include <logdepthbuf_fragment>\n}\n";
  var MODE = {
    /** The points are colored using their own color */
    COLOR: 0,
    /** The points are colored using their intensity */
    INTENSITY: 1,
    /** The points are colored using their classification */
    CLASSIFICATION: 2,
    /** The points are colored using their normal */
    NORMAL: 3,
    /** The points are colored using an external texture, such as a color layer */
    TEXTURE: 4,
    /** The points are colored using their elevation */
    ELEVATION: 5
  };
  PointsMaterial2.MODE = MODE;
  var NUM_TRANSFO = 16;
  var PointsMaterial$12 = /* @__PURE__ */ function(_RawShaderMaterial) {
    (0, _inherits22.default)(PointsMaterial3, _RawShaderMaterial);
    var _super = _createSuper2(PointsMaterial3);
    function PointsMaterial3() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, _classCallCheck22.default)(this, PointsMaterial3);
      _this = _super.call(this);
      _this.vertexShader = PointsVS;
      _this.fragmentShader = PointsFS;
      _this.size = options.size || 0;
      _this.scale = options.scale || 0.05 * 0.5 / Math.tan(1 / 2);
      _this.overlayColor = options.overlayColor || new _three2.Vector4(0, 0, 0, 0);
      _this.mode = options.mode || MODE.COLOR;
      _this.pickingId = 0;
      for (var _i = 0, _Object$keys = Object.keys(MODE); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (Object.prototype.hasOwnProperty.call(MODE, key)) {
          _this.defines["MODE_".concat(key)] = MODE[key];
        }
      }
      _this.uniforms.size = new _three2.Uniform(_this.size);
      _this.uniforms.mode = new _three2.Uniform(_this.mode);
      _this.uniforms.pickingId = new _three2.Uniform(_this.pickingId);
      _this.uniforms.opacity = new _three2.Uniform(_this.opacity);
      _this.uniforms.overlayColor = new _three2.Uniform(_this.overlayColor);
      if (_Capabilities.default.isLogDepthBufferSupported()) {
        _this.defines.USE_LOGDEPTHBUF = 1;
        _this.defines.USE_LOGDEPTHBUF_EXT = 1;
      }
      _this.extensions.fragDepth = true;
      _this.uniforms.enableTransfo = new _three2.Uniform(0);
      _this.transformations = [];
      for (var i = 0; i < NUM_TRANSFO; i++) {
        _this.transformations.push(new _three2.Matrix4());
      }
      _this.uniforms.transformations = new _three2.Uniform(_this.transformations);
      _this.vec = [];
      for (var _i2 = 0; _i2 < NUM_TRANSFO; _i2++) {
        _this.vec.push(new _three2.Vector3());
      }
      _this.uniforms.vec = new _three2.Uniform(_this.vec);
      _this.origin = [];
      for (var _i3 = 0; _i3 < NUM_TRANSFO; _i3++) {
        _this.origin.push(new _three2.Vector2());
      }
      _this.uniforms.origin = new _three2.Uniform(_this.origin);
      _this.influence = [];
      for (var _i4 = 0; _i4 < NUM_TRANSFO; _i4++) {
        _this.influence.push(new _three2.Vector2());
      }
      _this.uniforms.influence = new _three2.Uniform(_this.influence);
      _this.tColors = [];
      for (var _i5 = 0; _i5 < NUM_TRANSFO; _i5++) {
        _this.tColors.push(new _three2.Color());
      }
      _this.colorLayer = null;
      _this.uniforms.tColors = new _three2.Uniform(_this.tColors);
      _this.updateUniforms();
      return _this;
    }
    (0, _createClass22.default)(PointsMaterial3, [{
      key: "clone",
      value: function clone2() {
        var cl = (0, _get2.default)((0, _getPrototypeOf22.default)(PointsMaterial3.prototype), "clone", this).call(this, this);
        cl.update(this);
        return cl;
      }
    }, {
      key: "enablePicking",
      value: function enablePicking(picking) {
        this.pickingId = picking;
        this.blending = picking ? _three2.NoBlending : _three2.NormalBlending;
        this.updateUniforms();
      }
    }, {
      key: "updateUniforms",
      value: function updateUniforms() {
        this.uniforms.size.value = this.size > 0 ? this.size : -this.scale * window.innerHeight;
        this.uniforms.mode.value = this.mode;
        this.uniforms.pickingId.value = this.pickingId;
        this.uniforms.opacity.value = this.opacity;
        this.uniforms.overlayColor.value = this.overlayColor;
      }
    }, {
      key: "update",
      value: function update(source) {
        if (source) {
          this.visible = source.visible;
          this.opacity = source.opacity;
          this.transparent = source.transparent;
          this.size = source.size;
          this.mode = source.mode;
          this.pickingId = source.pickingId;
          this.scale = source.scale;
          this.overlayColor.copy(source.overlayColor);
        }
        this.updateUniforms();
        if (source) {
          Object.assign(this.defines, source.defines);
        }
        return this;
      }
      // Coloring support
    }, {
      key: "pushLayer",
      value: function pushLayer(layer, extent2) {
        this.mode = MODE.TEXTURE;
        this.updateUniforms();
        this.colorLayer = layer;
        this.uniforms.overlayTexture = new _three2.Uniform();
        this.uniforms.offsetScale = new _three2.Uniform(new _three2.Vector4(0, 0, 1, 1));
        this.uniforms.extentTopLeft = new _three2.Uniform(new _three2.Vector2(extent2.west(), extent2.north()));
        var dim = extent2.dimensions();
        this.uniforms.extentSize = new _three2.Uniform(new _three2.Vector2(dim.x, dim.y));
      }
    }, {
      key: "getColorTexture",
      value: function getColorTexture(layer) {
        if (layer !== this.colorLayer) {
          return null;
        }
        return this.uniforms.overlayTexture.value;
      }
    }, {
      key: "setColorTextures",
      value: function setColorTextures(layer, textures) {
        if (Array.isArray(textures)) {
          textures = textures[0];
        }
        if (layer === this.colorLayer) {
          this.uniforms.overlayTexture.value = textures.texture;
          this.uniforms.offsetScale.value.copy(textures.pitch);
        }
        return Promise.resolve();
      }
      // eslint-disable-next-line class-methods-use-this
    }, {
      key: "setSequence",
      value: function setSequence() {
      }
      // eslint-disable-next-line class-methods-use-this
    }, {
      key: "setLayerVisibility",
      value: function setLayerVisibility() {
      }
      // eslint-disable-next-line class-methods-use-this
    }, {
      key: "setLayerOpacity",
      value: function setLayerOpacity() {
      }
    }, {
      key: "enableTransfo",
      value: function enableTransfo(v) {
        if (v) {
          this.defines.DEFORMATION_SUPPORT = 1;
          this.defines.NUM_TRANSFO = NUM_TRANSFO;
        } else {
          delete this.defines.DEFORMATION_SUPPORT;
          delete this.defines.NUM_TRANSFO;
        }
        this.needsUpdate = true;
      }
    }]);
    return PointsMaterial3;
  }(_three2.RawShaderMaterial);
  var _default2 = PointsMaterial$12;
  PointsMaterial2.default = _default2;
  return PointsMaterial2;
}
var hasRequiredPoints;
function requirePoints() {
  if (hasRequiredPoints)
    return Points2;
  hasRequiredPoints = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Points2, "__esModule", {
    value: true
  });
  Points2.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _inherits22 = _interopRequireDefault2(requireInherits());
  var _possibleConstructorReturn22 = _interopRequireDefault2(requirePossibleConstructorReturn());
  var _getPrototypeOf22 = _interopRequireDefault2(requireGetPrototypeOf());
  var _three2 = require$$8$1;
  var _PointsMaterial = _interopRequireDefault2(requirePointsMaterial());
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function() {
      var Super = (0, _getPrototypeOf22.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf22.default)(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn22.default)(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Points$12 = /* @__PURE__ */ function(_ThreePoints) {
    (0, _inherits22.default)(Points3, _ThreePoints);
    var _super = _createSuper2(Points3);
    function Points3(layer, geometry) {
      var _this;
      var material = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new _PointsMaterial.default();
      (0, _classCallCheck22.default)(this, Points3);
      _this = _super.call(this, geometry, material);
      _this._layer = layer;
      _this.extent = void 0;
      _this.layerUpdateState = {};
      _this.wmtsCoords = {};
      return _this;
    }
    (0, _createClass22.default)(Points3, [{
      key: "getExtentForLayer",
      value: function getExtentForLayer(layer) {
        if (layer.extent.crs() !== this._layer.extent.crs()) {
          throw new Error("Unsupported reprojection");
        }
        return this.extent;
      }
    }]);
    return Points3;
  }(_three2.Points);
  var _default2 = Points$12;
  Points2.default = _default2;
  return Points2;
}
var Tiles3D$1 = {};
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(Tiles3D$1, "__esModule", {
  value: true
});
Tiles3D$1.calculateCameraDistance = calculateCameraDistance;
var default_1$2 = Tiles3D$1.default = void 0;
Tiles3D$1.init3dTilesEntity = init3dTilesEntity;
var _toConsumableArray2 = _interopRequireDefault$2(requireToConsumableArray());
var _classCallCheck2$2 = _interopRequireDefault$2(requireClassCallCheck());
var _createClass2$2 = _interopRequireDefault$2(requireCreateClass());
var _inherits2$1 = _interopRequireDefault$2(requireInherits());
var _possibleConstructorReturn2$1 = _interopRequireDefault$2(requirePossibleConstructorReturn());
var _getPrototypeOf2$1 = _interopRequireDefault$2(requireGetPrototypeOf());
var _three$1 = require$$8$1;
var _Extent = _interopRequireDefault$2(requireExtent());
var _ScreenSpaceError = _interopRequireDefault$2(requireScreenSpaceError());
var _Entity3D2 = _interopRequireDefault$2(requireEntity3D());
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function() {
    var Super = (0, _getPrototypeOf2$1.default)(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = (0, _getPrototypeOf2$1.default)(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return (0, _possibleConstructorReturn2$1.default)(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Tiles3D = /* @__PURE__ */ function(_Entity3D3) {
  (0, _inherits2$1.default)(Tiles3D2, _Entity3D3);
  var _super = _createSuper$1(Tiles3D2);
  function Tiles3D2(id, source) {
    var _this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    (0, _classCallCheck2$2.default)(this, Tiles3D2);
    _this = _super.call(this, id, options.object3d || new _three$1.Group());
    if (!source) {
      throw new Error("missing source");
    }
    if (!source.url) {
      throw new Error("missing source.url");
    }
    _this.protocol = "3d-tiles";
    _this.url = source.url;
    _this.networkOptions = source.networkOptions;
    _this.sseThreshold = options.sseThreshold || 16;
    _this.cleanupDelay = options.cleanupDelay || 1e3;
    _this.material = options.material || void 0;
    _this._cleanableTiles = [];
    return _this;
  }
  (0, _createClass2$2.default)(Tiles3D2, [{
    key: "preUpdate",
    value: function preUpdate() {
      if (!this.visible) {
        return [];
      }
      var now2 = Date.now();
      if (this._cleanableTiles.length && now2 - this._cleanableTiles[0].cleanableSince > this.cleanupDelay) {
        while (this._cleanableTiles.length) {
          var elt = this._cleanableTiles[0];
          if (now2 - elt.cleanableSince > this.cleanupDelay) {
            cleanup3dTileset(this, elt);
          } else {
            break;
          }
        }
      }
      return [this.root];
    }
  }, {
    key: "update",
    value: function update(context, node) {
      var _this2 = this;
      node.remove.apply(node, (0, _toConsumableArray2.default)(node.children.filter(function(c) {
        return c.deleted;
      })));
      if (node.parent.pendingSubdivision && !node.parent.additiveRefinement) {
        node.visible = false;
        return void 0;
      }
      var returnValue;
      var isVisible = !cullingTest(context.camera, node, node.matrixWorld);
      node.visible = isVisible;
      if (isVisible) {
        unmarkForDeletion(this, node);
        calculateCameraDistance(context.camera.camera3D, node);
        if (node.pendingSubdivision || subdivisionTest(context, this, node)) {
          subdivideNode(context, this, node, cullingTest);
          if (node.additiveRefinement || node.pendingSubdivision) {
            setDisplayed(node, true);
          } else {
            var subtilesets = this.tileIndex.index[node.tileId].children.filter(function(tile) {
              return tile.isTileset;
            });
            if (subtilesets.length) {
              var allReady = true;
              var _iterator = _createForOfIteratorHelper$1(subtilesets), _step;
              try {
                var _loop = function _loop2() {
                  var tileset = _step.value;
                  var subTilesetNode = node.children.filter(function(n2) {
                    return n2.tileId === tileset.tileId;
                  })[0];
                  if (!isTilesetContentReady(tileset, subTilesetNode)) {
                    allReady = false;
                    return "break";
                  }
                };
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var _ret = _loop();
                  if (_ret === "break")
                    break;
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              setDisplayed(node, allReady);
            } else {
              setDisplayed(node, true);
            }
          }
          returnValue = getChildTiles(node);
        } else {
          setDisplayed(node, true);
          var _iterator2 = _createForOfIteratorHelper$1(getChildTiles(node)), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var n = _step2.value;
              n.visible = false;
              markForDeletion(this, n);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        if (node.content && node.content.visible) {
          if (node.boundingVolume.region) {
            throw new Error("boundingVolume.region is not yet supported");
          } else if (node.boundingVolume.box) {
            this._distance.min = Math.min(this._distance.min, node.distance.min);
            this._distance.max = Math.max(this._distance.max, node.distance.max);
          } else if (node.boundingVolume.sphere) {
            this._distance.min = Math.min(this._distance.min, node.distance.min);
            this._distance.max = Math.max(this._distance.max, node.distance.max);
          }
          node.content.traverse(function(o) {
            if (o.layer === _this2 && o.material) {
              o.material.wireframe = _this2.wireframe;
              if (o.isPoints) {
                if (o.material.update) {
                  o.material.update(_this2.material);
                } else {
                  o.material.copy(_this2.material);
                }
              }
            }
          });
        }
      } else if (node !== this.root) {
        if (node.parent && node.parent.additiveRefinement) {
          markForDeletion(this, node);
        }
      }
      return returnValue;
    }
  }]);
  return Tiles3D2;
}(_Entity3D2.default);
var tmp = {
  v: new _three$1.Vector3(),
  b: new _three$1.Box3(),
  s: new _three$1.Sphere()
};
function requestNewTile(view, scheduler, layer, metadata, parent, redraw) {
  if (metadata.obj) {
    unmarkForDeletion(layer, metadata.obj);
    view.notifyChange(parent);
    return Promise.resolve(metadata.obj);
  }
  var priority;
  if (!parent || parent.additiveRefinement) {
    var size = metadata.boundingVolume.box.clone().applyMatrix4(metadata._worldFromLocalTransform).getSize(tmp.v);
    priority = size.x * size.y;
  } else {
    var _size = parent.boundingVolume.box.clone().applyMatrix4(parent.matrixWorld).getSize(tmp.v);
    priority = _size.x * _size.y;
  }
  var command = {
    /* mandatory */
    view,
    requester: parent,
    layer,
    priority,
    /* specific params */
    metadata,
    redraw,
    earlyDropFunction: function earlyDropFunction(cmd) {
      return cmd.requester && // requester cleaned
      (!cmd.requester.parent || !cmd.requester.visible || cmd.requester.sse < cmd.layer.sseThreshold);
    }
  };
  if (metadata.content) {
    var path = metadata.content.url || metadata.content.uri;
    var url = path.startsWith("http") ? path : metadata.baseURL + path;
    command.toDownload = {
      url
    };
  }
  return scheduler.execute(command).then(function(node) {
    metadata.obj = node;
    return node;
  });
}
function getChildTiles(tile) {
  return tile.children.filter(function(n) {
    return n.layer === tile.layer && n.tileId;
  });
}
function subdivideNode(context, layer, node, cullingTestFn) {
  if (node.additiveRefinement) {
    _subdivideNodeAdditive(context, layer, node, cullingTestFn);
  } else {
    _subdivideNodeSubstractive(context, layer, node);
  }
}
function boundingVolumeToExtent(crs, volume, transform2) {
  if (volume.region) {
    return new _Extent.default("EPSG:4326", _three$1.MathUtils.radToDeg(volume.region[0]), _three$1.MathUtils.radToDeg(volume.region[2]), _three$1.MathUtils.radToDeg(volume.region[1]), _three$1.MathUtils.radToDeg(volume.region[3]));
  }
  if (volume.box) {
    var box = tmp.b.copy(volume.box).applyMatrix4(transform2);
    return _Extent.default.fromBox3(crs, box);
  }
  var sphere2 = tmp.s.copy(volume.sphere).applyMatrix4(transform2);
  return new _Extent.default(crs, {
    west: sphere2.center.x - sphere2.radius,
    east: sphere2.center.x + sphere2.radius,
    south: sphere2.center.y - sphere2.radius,
    north: sphere2.center.y + sphere2.radius
  });
}
var tmpMatrix = new _three$1.Matrix4();
function _subdivideNodeAdditive(ctx, layer, node, cullingTestFn) {
  var _iterator3 = _createForOfIteratorHelper$1(layer.tileIndex.index[node.tileId].children), _step3;
  try {
    var _loop2 = function _loop22() {
      var child = _step3.value;
      if (child.promise || node.children.filter(function(n) {
        return n.tileId === child.tileId;
      }).length > 0) {
        return "continue";
      }
      var overrideMatrixWorld = node.matrixWorld;
      if (child.transform) {
        overrideMatrixWorld = tmpMatrix.multiplyMatrices(node.matrixWorld, child.transform);
      }
      var isVisible = cullingTestFn ? !cullingTestFn(ctx.camera, child, overrideMatrixWorld) : true;
      if (!isVisible) {
        return "continue";
      }
      child.promise = requestNewTile(ctx.instance, ctx.scheduler, layer, child, node, true).then(function(tile) {
        if (!(!tile || !node.parent)) {
          node.add(tile);
          tile.updateMatrixWorld();
          var extent2 = boundingVolumeToExtent(layer.extent.crs(), tile.boundingVolume, tile.matrixWorld);
          tile.traverse(function(obj) {
            obj.extent = extent2;
          });
          ctx.instance.notifyChange(child);
        }
        delete child.promise;
      }, function() {
        delete child.promise;
      });
    };
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var _ret2 = _loop2();
      if (_ret2 === "continue")
        continue;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}
function _subdivideNodeSubstractive(context, layer, node) {
  if (node.pendingSubdivision) {
    return;
  }
  if (getChildTiles(node).length > 0) {
    return;
  }
  var childrenTiles = layer.tileIndex.index[node.tileId].children;
  if (childrenTiles === void 0 || childrenTiles.length === 0) {
    return;
  }
  node.pendingSubdivision = true;
  var promises = [];
  var _iterator4 = _createForOfIteratorHelper$1(layer.tileIndex.index[node.tileId].children), _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
      var child = _step4.value;
      var p = requestNewTile(context.instance, context.scheduler, layer, child, node, false).then(function(tile) {
        node.add(tile);
        tile.updateMatrixWorld();
        var extent2 = boundingVolumeToExtent(layer.extent.crs(), tile.boundingVolume, tile.matrixWorld);
        tile.traverse(function(obj) {
          obj.extent = extent2;
        });
      });
      promises.push(p);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  Promise.all(promises).then(function() {
    node.pendingSubdivision = false;
    context.instance.notifyChange(node);
  }, function() {
    node.pendingSubdivision = false;
    var _iterator5 = _createForOfIteratorHelper$1(getChildTiles(node)), _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var n = _step5.value;
        n.visible = false;
        markForDeletion(layer, n);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
  });
}
function cullingTest(camera, node, tileMatrixWorld) {
  if (node.viewerRequestVolume) {
    var nodeViewer = node.viewerRequestVolume;
    if (nodeViewer.region) {
      return true;
    }
    if (nodeViewer.box) {
      return true;
    }
    if (nodeViewer.sphere) {
      tmp.s.copy(nodeViewer.sphere);
      tmp.s.applyMatrix4(node.matrixWorld);
      if (!(camera.camera3D.position.distanceTo(tmp.s.center) <= tmp.s.radius)) {
        return true;
      }
    }
  }
  if (node.boundingVolume) {
    var boundingVolume = node.boundingVolume;
    if (boundingVolume.region) {
      return !camera.isBox3Visible(boundingVolume.region.box3D, tileMatrixWorld.clone().multiply(boundingVolume.region.matrix));
    }
    if (boundingVolume.box) {
      return !camera.isBox3Visible(boundingVolume.box, tileMatrixWorld);
    }
    if (boundingVolume.sphere) {
      return !camera.isSphereVisible(boundingVolume.sphere, tileMatrixWorld);
    }
  }
  return false;
}
function cleanup3dTileset(layer, n) {
  var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  unmarkForDeletion(layer, n);
  if (layer.tileIndex.index[n.tileId].obj) {
    layer.tileIndex.index[n.tileId].obj.deleted = Date.now();
    layer.tileIndex.index[n.tileId].obj = void 0;
  }
  var _iterator6 = _createForOfIteratorHelper$1(getChildTiles(n)), _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
      var child = _step6.value;
      cleanup3dTileset(layer, child, depth + 1);
      n.remove(child);
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  if (n.content) {
    n.content.traverse(_cleanupObject3D);
    n.remove(n.content);
    delete n.content;
  }
  if (n.dispose) {
    n.dispose();
  }
}
function _cleanupObject3D(n) {
  var _iterator7 = _createForOfIteratorHelper$1(n.children), _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
      var child = _step7.value;
      _cleanupObject3D(child);
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  if (n.material) {
    n.material.dispose();
  }
  if (n.geometry) {
    n.geometry.dispose();
  }
  n.remove.apply(n, (0, _toConsumableArray2.default)(n.children));
}
function computeNodeSSE(context, node) {
  if (node.boundingVolume.region) {
    throw new Error("boundingVolume.region is unsupported");
  } else if (node.boundingVolume.box) {
    var sse = _ScreenSpaceError.default.computeFromBox3(context.camera, node.boundingVolume.box, node.matrixWorld, node.geometricError, _ScreenSpaceError.default.MODE_3D);
    if (!sse) {
      return Infinity;
    }
    return Math.max(sse.lengths.x, sse.lengths.y);
  } else if (node.boundingVolume.sphere) {
    if (node.distance === 0) {
      return Infinity;
    }
    return context.camera._preSSE * (node.geometricError / node.distance);
  } else {
    return Infinity;
  }
}
function init3dTilesEntity(view, scheduler, layer) {
  return requestNewTile(view, scheduler, layer, layer.tileset.root, void 0, true).then(function(tile) {
    delete layer.tileset;
    layer.object3d.add(tile);
    tile.updateMatrixWorld();
    layer.tileIndex.index[tile.tileId].obj = tile;
    layer.root = tile;
    layer.extent = boundingVolumeToExtent(layer.projection || view.referenceCrs, tile.boundingVolume, tile.matrixWorld);
  });
}
function setDisplayed(node, display) {
  if (node.content) {
    node.content.visible = display;
  }
}
function markForDeletion(layer, elt) {
  if (!elt.cleanableSince) {
    elt.cleanableSince = Date.now();
    layer._cleanableTiles.push(elt);
  }
}
function unmarkForDeletion(layer, elt) {
  if (elt.cleanableSince) {
    layer._cleanableTiles.splice(layer._cleanableTiles.indexOf(elt), 1);
    elt.cleanableSince = void 0;
  }
}
function isTilesetContentReady(tileset, node) {
  return tileset && node && node.children.length === 1 && node.children[0].children.length > 0;
}
function calculateCameraDistance(camera, node) {
  node.distance.min = 0;
  node.distance.max = 0;
  if (node.boundingVolume.region) {
    throw new Error("boundingVolume.region is unsupported");
  } else if (node.boundingVolume.box) {
    tmp.b.copy(node.boundingVolume.box);
    tmp.b.applyMatrix4(node.matrixWorld);
    node.distance.min = tmp.b.distanceToPoint(camera.position);
    node.distance.max = node.distance.min + tmp.b.getSize(tmp.v).length();
  } else if (node.boundingVolume.sphere) {
    tmp.s.copy(node.boundingVolume.sphere);
    tmp.s.applyMatrix4(node.matrixWorld);
    node.distance.min = Math.max(0, tmp.s.distanceToPoint(camera.position));
    node.distance.max = node.distance.min + 2 * tmp.s.radius;
  }
}
function subdivisionTest(context, layer, node) {
  if (layer.tileIndex.index[node.tileId].children === void 0) {
    return false;
  }
  if (layer.tileIndex.index[node.tileId].isTileset) {
    return true;
  }
  var sse = computeNodeSSE(context, node);
  node.sse = sse;
  return sse > layer.sseThreshold;
}
var _default$2 = Tiles3D;
default_1$2 = Tiles3D$1.default = _default$2;
var hasRequired_3dTilesProvider;
function require_3dTilesProvider() {
  if (hasRequired_3dTilesProvider)
    return _3dTilesProvider;
  hasRequired_3dTilesProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(_3dTilesProvider, "__esModule", {
    value: true
  });
  _3dTilesProvider.$3dTilesIndex = void 0;
  _3dTilesProvider.configureTile = configureTile;
  _3dTilesProvider.default = void 0;
  _3dTilesProvider.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;
  var _classCallCheck22 = _interopRequireDefault2(requireClassCallCheck());
  var _createClass22 = _interopRequireDefault2(requireCreateClass());
  var _three2 = require$$8$1;
  var _B3dmParser = _interopRequireDefault2(requireB3dmParser());
  var _PntsParser = _interopRequireDefault2(requirePntsParser());
  var _Fetcher = _interopRequireDefault2(requireFetcher());
  var _Utf8Decoder = _interopRequireDefault2(requireUtf8Decoder());
  var _Picking2 = _interopRequireDefault2(requirePicking());
  var _Points = _interopRequireDefault2(requirePoints());
  var _PointsMaterial = _interopRequireDefault2(requirePointsMaterial());
  var _Cache = _interopRequireDefault2(requireCache());
  var _Tiles3D = Tiles3D$1;
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var identity2 = new _three2.Matrix4();
  var $3dTilesIndex = /* @__PURE__ */ function() {
    function $3dTilesIndex2(tileset, baseURL) {
      (0, _classCallCheck22.default)(this, $3dTilesIndex2);
      this._counter = 1;
      this.index = {};
      this._inverseTileTransform = new _three2.Matrix4();
      this._recurse(tileset.root, baseURL);
    }
    (0, _createClass22.default)($3dTilesIndex2, [{
      key: "_recurse",
      value: function _recurse(node, baseURL, parent) {
        node.transform = node.transform ? new _three2.Matrix4().fromArray(node.transform) : identity2;
        node._worldFromLocalTransform = node.transform;
        if (parent && parent._worldFromLocalTransform) {
          if (node.transform) {
            node._worldFromLocalTransform = new _three2.Matrix4().multiplyMatrices(parent._worldFromLocalTransform, node.transform);
          } else {
            node._worldFromLocalTransform = parent._worldFromLocalTransform;
          }
        }
        if (node._worldFromLocalTransform) {
          this._inverseTileTransform.copy(node._worldFromLocalTransform).invert();
        } else {
          this._inverseTileTransform.identity();
        }
        node.viewerRequestVolume = node.viewerRequestVolume ? getBox(node.viewerRequestVolume, this._inverseTileTransform) : void 0;
        node.boundingVolume = getBox(node.boundingVolume, this._inverseTileTransform);
        node.refine = node.refine || (parent ? parent.refine : "ADD");
        this.index[this._counter] = node;
        node.tileId = this._counter;
        node.baseURL = baseURL;
        this._counter++;
        if (node.children) {
          var _iterator = _createForOfIteratorHelper2(node.children), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var child = _step.value;
              try {
                this._recurse(child, baseURL, node);
              } catch (error) {
                node.children[node.children.indexOf(child)] = void 0;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          var count = node.children.length;
          node.children = node.children.filter(function(n) {
            return n !== void 0;
          });
          if (node.children.length !== count)
            ;
        }
      }
    }, {
      key: "extendTileset",
      value: function extendTileset(tileset, nodeId, baseURL) {
        this._recurse(tileset.root, baseURL, this.index[nodeId]);
        this.index[nodeId].children = [tileset.root];
        this.index[nodeId].isTileset = true;
      }
    }]);
    return $3dTilesIndex2;
  }();
  _3dTilesProvider.$3dTilesIndex = $3dTilesIndex;
  function getObjectToUpdateForAttachedLayers(meta) {
    if (!meta.content) {
      return null;
    }
    var result = [];
    meta.content.traverse(function(obj) {
      if (obj.isObject3D && obj.material && obj.layer === meta.layer) {
        result.push(obj);
      }
    });
    var p = meta.parent;
    if (p && p.content) {
      return {
        elements: result,
        parent: p.content
      };
    }
    return {
      elements: result
    };
  }
  function preprocessDataLayer(entity, instance, scheduler) {
    entity.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;
    if (entity.material && entity.material.enablePicking) {
      entity.pickObjectsAt = function(instance2, mouse, radius) {
        return _Picking2.default.pickPointsAt(instance2, mouse, radius, entity);
      };
    }
    var url = entity.url;
    return _Fetcher.default.json(url, entity.networkOptions).then(function(tileset) {
      if (!tileset.root.refine) {
        tileset.root.refine = tileset.refine;
      }
      var fakeroot = {
        boundingVolume: tileset.root.boundingVolume,
        geometricError: tileset.geometricError * 10,
        refine: tileset.root.refine,
        transform: tileset.root.transform,
        children: [tileset.root]
      };
      tileset.root.transform = void 0;
      tileset.root = fakeroot;
      entity.tileset = tileset;
      var urlPrefix = url.slice(0, url.lastIndexOf("/") + 1);
      entity.tileIndex = new $3dTilesIndex(tileset, urlPrefix);
      entity.asset = tileset.asset;
      return (0, _Tiles3D.init3dTilesEntity)(instance, scheduler, entity, tileset.root);
    });
  }
  function getBox(volume) {
    if (volume.region) {
      throw new Error("volume.region is unsupported");
    } else if (volume.box) {
      var bbox = volume.box;
      var center = new _three2.Vector3(bbox[0], bbox[1], bbox[2]);
      var halfXVector = new _three2.Vector3(bbox[3], bbox[4], bbox[5]);
      var halfYVector = new _three2.Vector3(bbox[6], bbox[7], bbox[8]);
      var halfZVector = new _three2.Vector3(bbox[9], bbox[10], bbox[11]);
      var point1 = center.clone().sub(halfXVector).sub(halfYVector).sub(halfZVector);
      var point2 = center.clone().add(halfXVector).add(halfYVector).add(halfZVector);
      var w = Math.min(point1.x, point2.x);
      var e = Math.max(point1.x, point2.x);
      var s = Math.min(point1.y, point2.y);
      var n = Math.max(point1.y, point2.y);
      var b = Math.min(point1.z, point2.z);
      var t = Math.max(point1.z, point2.z);
      var box = new _three2.Box3(new _three2.Vector3(w, s, b), new _three2.Vector3(e, n, t));
      if (box.getSize(new _three2.Vector3()).length() === 0) {
        throw new Error("Invalid boundingVolume (0 sized box)");
      }
      return {
        box
      };
    } else if (volume.sphere) {
      var sphere2 = new _three2.Sphere(new _three2.Vector3(volume.sphere[0], volume.sphere[1], volume.sphere[2]), volume.sphere[3]);
      return {
        sphere: sphere2
      };
    } else {
      return null;
    }
  }
  function b3dmToMesh(data, layer, url) {
    var urlBase = _three2.LoaderUtils.extractUrlBase(url);
    var options = {
      gltfUpAxis: layer.asset.gltfUpAxis,
      urlBase,
      overrideMaterials: layer.overrideMaterials,
      doNotPatchMaterial: layer.doNotPatchMaterial,
      opacity: layer.opacity
    };
    return _B3dmParser.default.parse(data, options).then(function(result) {
      var batchTable = result.batchTable;
      var object3d = result.gltf.scene;
      return {
        batchTable,
        object3d
      };
    });
  }
  function pntsParse(data, layer) {
    return _PntsParser.default.parse(data).then(function(result) {
      var material = layer.material ? layer.material.clone() : new _PointsMaterial.default();
      if (material.enablePicking) {
        _Picking2.default.preparePointGeometryForPicking(result.point.geometry);
      }
      var points = new _Points.default(layer, result.point.geometry, material);
      if (result.point.offset) {
        points.position.copy(result.point.offset);
      }
      return {
        object3d: points
      };
    });
  }
  function configureTile(tile, layer, metadata, parent) {
    tile.frustumCulled = false;
    tile.layer = layer;
    if (metadata.transform) {
      tile.applyMatrix4(metadata.transform);
    }
    tile.geometricError = metadata.geometricError;
    tile.tileId = metadata.tileId;
    if (metadata.refine) {
      tile.additiveRefinement = metadata.refine.toUpperCase() === "ADD";
    } else {
      tile.additiveRefinement = parent ? parent.additiveRefinement : false;
    }
    tile.viewerRequestVolume = metadata.viewerRequestVolume;
    tile.boundingVolume = metadata.boundingVolume;
    if (tile.boundingVolume.region) {
      tile.add(tile.boundingVolume.region);
    }
    tile.distance = {};
    tile.updateMatrixWorld();
  }
  function executeCommand(command) {
    var layer = command.layer;
    var metadata = command.metadata;
    var tile = new _three2.Object3D();
    configureTile(tile, layer, metadata, command.requester);
    var path;
    if (metadata.content) {
      if (metadata.content.url) {
        path = metadata.content.url;
      } else {
        path = metadata.content.uri;
      }
    }
    var setLayer = function(obj) {
      obj.layers.set(layer.threejsLayer);
      obj.userData.metadata = metadata;
      obj.layer = layer;
    };
    if (path) {
      var url = path.startsWith("http") ? path : metadata.baseURL + path;
      var supportedFormats = {
        b3dm: b3dmToMesh,
        pnts: pntsParse
      };
      var dl = _Cache.default.get(url) || _Cache.default.set(url, _Fetcher.default.arrayBuffer(url, layer.networkOptions), _Cache.default.TEXTURE);
      return dl.then(function(result) {
        if (result !== void 0) {
          var func;
          var magic = _Utf8Decoder.default.decode(new Uint8Array(result, 0, 4));
          metadata.magic = magic;
          if (magic[0] === "{") {
            result = JSON.parse(_Utf8Decoder.default.decode(new Uint8Array(result)));
            var newPrefix = url.slice(0, url.lastIndexOf("/") + 1);
            layer.tileIndex.extendTileset(result, metadata.tileId, newPrefix);
          } else if (magic === "b3dm") {
            func = supportedFormats.b3dm;
          } else if (magic === "pnts") {
            func = supportedFormats.pnts;
          } else {
            return Promise.reject(new Error("Unsupported magic code ".concat(magic)));
          }
          if (func) {
            return func(result, layer, url).then(function(content) {
              tile.content = content.object3d;
              if (content.batchTable) {
                tile.batchTable = content.batchTable;
              }
              tile.add(content.object3d);
              tile.traverse(setLayer);
              return tile;
            });
          }
        }
        tile.traverse(setLayer);
        return tile;
      });
    }
    tile.traverse(setLayer);
    return Promise.resolve(tile);
  }
  var _default2 = {
    preprocessDataLayer,
    executeCommand
  };
  _3dTilesProvider.default = _default2;
  return _3dTilesProvider;
}
var TMSProvider = {};
var URLBuilder = {};
var hasRequiredURLBuilder;
function requireURLBuilder() {
  if (hasRequiredURLBuilder)
    return URLBuilder;
  hasRequiredURLBuilder = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(URLBuilder, "__esModule", {
    value: true
  });
  URLBuilder.default = void 0;
  _interopRequireDefault2(requireExtent());
  _interopRequireDefault2(requireLayer());
  var _default2 = {
    /**
     * Builds an URL knowing the coordinates and the layer to query.
     * <br><br>
     * The layer object needs to have an url property, which should have some
     * specific strings that will be replaced by coordinates.
     * <ul>
     * <li><code>${x}</code> or <code>%COL</code> will be replaced by
     * <code>coords.col</code></li>
     * <li><code>${y}</code> or <code>%ROW</code> will be replaced by
     * <code>coords.row</code></li>
     * <li><code>${z}</code> or <code>%TILEMATRIX</code> will be replaced by
     * <code>coords.zoom</code></li>
     * </ul>
     *
     * @example
     * coords = new Coordinates('WMTS:WGS84', 12, 1410, 2072);
     * layer.url = 'http://server.geo/wmts/SERVICE=WMTS&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL';
     * url = URLBuilder.xyz(coords, layer);
     *
     * // The resulting url is:
     * // http://server.geo/wmts/SERVICE=WMTS&TILEMATRIX=12&TILEROW=1410&TILECOL=2072;
     * @example
     * coords = new Extent('TMS', 15, 2142, 3412);
     * layer.url = 'http://server.geo/tms/${z}/${y}/${x}.jpg';
     * url = URLBuilder.xyz(coords, layer);
     *
     * // The resulting url is:
     * // http://server.geo/tms/15/2142/3412.jpg;
     * @param {Extent} coords the coordinates
     * @param {Layer} layer the layer to query
     * @returns {string} the formed url
     * @api
     */
    xyz: function(coords, layer) {
      return layer.url.replace(/(\$\{z\}|%TILEMATRIX)/, coords.zoom).replace(/(\$\{y\}|%ROW)/, coords.row).replace(/(\$\{x\}|%COL)/, coords.col);
    },
    /**
     * Builds an URL knowing the bounding box and the layer to query.
     * <br><br>
     * The layer object needs to have an url property, which should have the
     * string <code>%bbox</code> in it. This string will be replaced by the four
     * cardinal points composing the bounding box.
     * <br><br>
     * Order of the points can be specified in the <code>axisOrder</code>
     * property in layer, using the letters <code>w, s, e, n</code> respectively
     * for <code>WEST, SOUTH, EAST, NORTH</code>. The default order is
     * <code>wsen</code>.
     *
     * @example
     * extent = new Extent('EPSG:4326', 12, 14, 35, 46);
     * layer.projection = 'EPSG:4326';
     * layer.url = 'http://server.geo/wms/BBOX=%bbox&FORMAT=jpg&SERVICE=WMS';
     * url = URLBuilder.bbox(extent, layer);
     *
     * // The resulting url is:
     * // http://server.geo/wms/BBOX=12,35,14,46&FORMAT=jpg&SERVICE=WMS
     * @param {Extent} boundingBox the bounding box
     * @param {Layer} layer the layer to query
     * @returns {string} the formed url
     */
    bbox: function(boundingBox, layer) {
      var precision = layer.projection === "EPSG:4326" ? 9 : 2;
      var box = boundingBox.crs() === layer.projection ? boundingBox : boundingBox.as(layer.projection);
      var w = box.west().toFixed(precision);
      var s = box.south().toFixed(precision);
      var e = box.east().toFixed(precision);
      var n = box.north().toFixed(precision);
      var bboxInUnit = layer.axisOrder || "wsen";
      bboxInUnit = bboxInUnit.replace("w", "".concat(w, ",")).replace("s", "".concat(s, ",")).replace("e", "".concat(e, ",")).replace("n", "".concat(n, ",")).slice(0, -1);
      return layer.url.replace("%bbox", bboxInUnit);
    }
  };
  URLBuilder.default = _default2;
  return URLBuilder;
}
var VectorTileHelper = {};
var VectorTileParser = {};
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754)
    return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s * 128;
  };
  return ieee754;
}
var pbf;
var hasRequiredPbf;
function requirePbf() {
  if (hasRequiredPbf)
    return pbf;
  hasRequiredPbf = 1;
  pbf = Pbf;
  var ieee7542 = requireIeee754();
  function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
  }
  Pbf.Varint = 0;
  Pbf.Fixed64 = 1;
  Pbf.Bytes = 2;
  Pbf.Fixed32 = 5;
  var SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
  var TEXT_DECODER_MIN_LENGTH = 12;
  var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
  Pbf.prototype = {
    destroy: function() {
      this.buf = null;
    },
    // === READING =================================================================
    readFields: function(readField, result, end) {
      end = end || this.length;
      while (this.pos < end) {
        var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
        this.type = val & 7;
        readField(tag, result, this);
        if (this.pos === startPos)
          this.skip(val);
      }
      return result;
    },
    readMessage: function(readField, result) {
      return this.readFields(readField, result, this.readVarint() + this.pos);
    },
    readFixed32: function() {
      var val = readUInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    },
    readSFixed32: function() {
      var val = readInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
      var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    },
    readSFixed64: function() {
      var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    },
    readFloat: function() {
      var val = ieee7542.read(this.buf, this.pos, true, 23, 4);
      this.pos += 4;
      return val;
    },
    readDouble: function() {
      var val = ieee7542.read(this.buf, this.pos, true, 52, 8);
      this.pos += 8;
      return val;
    },
    readVarint: function(isSigned) {
      var buf = this.buf, val, b;
      b = buf[this.pos++];
      val = b & 127;
      if (b < 128)
        return val;
      b = buf[this.pos++];
      val |= (b & 127) << 7;
      if (b < 128)
        return val;
      b = buf[this.pos++];
      val |= (b & 127) << 14;
      if (b < 128)
        return val;
      b = buf[this.pos++];
      val |= (b & 127) << 21;
      if (b < 128)
        return val;
      b = buf[this.pos];
      val |= (b & 15) << 28;
      return readVarintRemainder(val, isSigned, this);
    },
    readVarint64: function() {
      return this.readVarint(true);
    },
    readSVarint: function() {
      var num = this.readVarint();
      return num % 2 === 1 ? (num + 1) / -2 : num / 2;
    },
    readBoolean: function() {
      return Boolean(this.readVarint());
    },
    readString: function() {
      var end = this.readVarint() + this.pos;
      var pos = this.pos;
      this.pos = end;
      if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
        return readUtf8TextDecoder(this.buf, pos, end);
      }
      return readUtf8(this.buf, pos, end);
    },
    readBytes: function() {
      var end = this.readVarint() + this.pos, buffer2 = this.buf.subarray(this.pos, end);
      this.pos = end;
      return buffer2;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(arr, isSigned) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readVarint(isSigned));
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readVarint(isSigned));
      return arr;
    },
    readPackedSVarint: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readSVarint());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readSVarint());
      return arr;
    },
    readPackedBoolean: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readBoolean());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readBoolean());
      return arr;
    },
    readPackedFloat: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readFloat());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readFloat());
      return arr;
    },
    readPackedDouble: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readDouble());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readDouble());
      return arr;
    },
    readPackedFixed32: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readFixed32());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readFixed32());
      return arr;
    },
    readPackedSFixed32: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readSFixed32());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readSFixed32());
      return arr;
    },
    readPackedFixed64: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readFixed64());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readFixed64());
      return arr;
    },
    readPackedSFixed64: function(arr) {
      if (this.type !== Pbf.Bytes)
        return arr.push(this.readSFixed64());
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end)
        arr.push(this.readSFixed64());
      return arr;
    },
    skip: function(val) {
      var type = val & 7;
      if (type === Pbf.Varint)
        while (this.buf[this.pos++] > 127) {
        }
      else if (type === Pbf.Bytes)
        this.pos = this.readVarint() + this.pos;
      else if (type === Pbf.Fixed32)
        this.pos += 4;
      else if (type === Pbf.Fixed64)
        this.pos += 8;
      else
        throw new Error("Unimplemented type: " + type);
    },
    // === WRITING =================================================================
    writeTag: function(tag, type) {
      this.writeVarint(tag << 3 | type);
    },
    realloc: function(min) {
      var length = this.length || 16;
      while (length < this.pos + min)
        length *= 2;
      if (length !== this.length) {
        var buf = new Uint8Array(length);
        buf.set(this.buf);
        this.buf = buf;
        this.length = length;
      }
    },
    finish: function() {
      this.length = this.pos;
      this.pos = 0;
      return this.buf.subarray(0, this.length);
    },
    writeFixed32: function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    },
    writeSFixed32: function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    },
    writeFixed64: function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    },
    writeSFixed64: function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    },
    writeVarint: function(val) {
      val = +val || 0;
      if (val > 268435455 || val < 0) {
        writeBigVarint(val, this);
        return;
      }
      this.realloc(4);
      this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
      if (val <= 127)
        return;
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127)
        return;
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127)
        return;
      this.buf[this.pos++] = val >>> 7 & 127;
    },
    writeSVarint: function(val) {
      this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },
    writeBoolean: function(val) {
      this.writeVarint(Boolean(val));
    },
    writeString: function(str) {
      str = String(str);
      this.realloc(str.length * 4);
      this.pos++;
      var startPos = this.pos;
      this.pos = writeUtf8(this.buf, str, this.pos);
      var len = this.pos - startPos;
      if (len >= 128)
        makeRoomForExtraLength(startPos, len, this);
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    },
    writeFloat: function(val) {
      this.realloc(4);
      ieee7542.write(this.buf, val, this.pos, true, 23, 4);
      this.pos += 4;
    },
    writeDouble: function(val) {
      this.realloc(8);
      ieee7542.write(this.buf, val, this.pos, true, 52, 8);
      this.pos += 8;
    },
    writeBytes: function(buffer2) {
      var len = buffer2.length;
      this.writeVarint(len);
      this.realloc(len);
      for (var i = 0; i < len; i++)
        this.buf[this.pos++] = buffer2[i];
    },
    writeRawMessage: function(fn, obj) {
      this.pos++;
      var startPos = this.pos;
      fn(obj, this);
      var len = this.pos - startPos;
      if (len >= 128)
        makeRoomForExtraLength(startPos, len, this);
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    },
    writeMessage: function(tag, fn, obj) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeRawMessage(fn, obj);
    },
    writePackedVarint: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedVarint, arr);
    },
    writePackedSVarint: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedSVarint, arr);
    },
    writePackedBoolean: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedBoolean, arr);
    },
    writePackedFloat: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedFloat, arr);
    },
    writePackedDouble: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedDouble, arr);
    },
    writePackedFixed32: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedFixed32, arr);
    },
    writePackedSFixed32: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedSFixed32, arr);
    },
    writePackedFixed64: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedFixed64, arr);
    },
    writePackedSFixed64: function(tag, arr) {
      if (arr.length)
        this.writeMessage(tag, writePackedSFixed64, arr);
    },
    writeBytesField: function(tag, buffer2) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeBytes(buffer2);
    },
    writeFixed32Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeString(str);
    },
    writeFloatField: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
      this.writeVarintField(tag, Boolean(val));
    }
  };
  function readVarintRemainder(l, s, p) {
    var buf = p.buf, h, b;
    b = buf[p.pos++];
    h = (b & 112) >> 4;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 3;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 10;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 17;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 127) << 24;
    if (b < 128)
      return toNum(l, h, s);
    b = buf[p.pos++];
    h |= (b & 1) << 31;
    if (b < 128)
      return toNum(l, h, s);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function readPackedEnd(pbf2) {
    return pbf2.type === Pbf.Bytes ? pbf2.readVarint() + pbf2.pos : pbf2.pos + 1;
  }
  function toNum(low, high, isSigned) {
    if (isSigned) {
      return high * 4294967296 + (low >>> 0);
    }
    return (high >>> 0) * 4294967296 + (low >>> 0);
  }
  function writeBigVarint(val, pbf2) {
    var low, high;
    if (val >= 0) {
      low = val % 4294967296 | 0;
      high = val / 4294967296 | 0;
    } else {
      low = ~(-val % 4294967296);
      high = ~(-val / 4294967296);
      if (low ^ 4294967295) {
        low = low + 1 | 0;
      } else {
        low = 0;
        high = high + 1 | 0;
      }
    }
    if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
      throw new Error("Given varint doesn't fit into 10 bytes");
    }
    pbf2.realloc(10);
    writeBigVarintLow(low, high, pbf2);
    writeBigVarintHigh(high, pbf2);
  }
  function writeBigVarintLow(low, high, pbf2) {
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf2.buf[pbf2.pos] = low & 127;
  }
  function writeBigVarintHigh(high, pbf2) {
    var lsb = (high & 7) << 4;
    pbf2.buf[pbf2.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high)
      return;
    pbf2.buf[pbf2.pos++] = high & 127;
  }
  function makeRoomForExtraLength(startPos, len, pbf2) {
    var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
    pbf2.realloc(extraLen);
    for (var i = pbf2.pos - 1; i >= startPos; i--)
      pbf2.buf[i + extraLen] = pbf2.buf[i];
  }
  function writePackedVarint(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeVarint(arr[i]);
  }
  function writePackedSVarint(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeSVarint(arr[i]);
  }
  function writePackedFloat(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeFloat(arr[i]);
  }
  function writePackedDouble(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeDouble(arr[i]);
  }
  function writePackedBoolean(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeBoolean(arr[i]);
  }
  function writePackedFixed32(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeFixed32(arr[i]);
  }
  function writePackedSFixed32(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeSFixed32(arr[i]);
  }
  function writePackedFixed64(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeFixed64(arr[i]);
  }
  function writePackedSFixed64(arr, pbf2) {
    for (var i = 0; i < arr.length; i++)
      pbf2.writeSFixed64(arr[i]);
  }
  function readUInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
  }
  function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = val >>> 8;
    buf[pos + 2] = val >>> 16;
    buf[pos + 3] = val >>> 24;
  }
  function readInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
  }
  function readUtf8(buf, pos, end) {
    var str = "";
    var i = pos;
    while (i < end) {
      var b0 = buf[i];
      var c = null;
      var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
      if (i + bytesPerSequence > end)
        break;
      var b1, b2, b3;
      if (bytesPerSequence === 1) {
        if (b0 < 128) {
          c = b0;
        }
      } else if (bytesPerSequence === 2) {
        b1 = buf[i + 1];
        if ((b1 & 192) === 128) {
          c = (b0 & 31) << 6 | b1 & 63;
          if (c <= 127) {
            c = null;
          }
        }
      } else if (bytesPerSequence === 3) {
        b1 = buf[i + 1];
        b2 = buf[i + 2];
        if ((b1 & 192) === 128 && (b2 & 192) === 128) {
          c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
          if (c <= 2047 || c >= 55296 && c <= 57343) {
            c = null;
          }
        }
      } else if (bytesPerSequence === 4) {
        b1 = buf[i + 1];
        b2 = buf[i + 2];
        b3 = buf[i + 3];
        if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
          c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
          if (c <= 65535 || c >= 1114112) {
            c = null;
          }
        }
      }
      if (c === null) {
        c = 65533;
        bytesPerSequence = 1;
      } else if (c > 65535) {
        c -= 65536;
        str += String.fromCharCode(c >>> 10 & 1023 | 55296);
        c = 56320 | c & 1023;
      }
      str += String.fromCharCode(c);
      i += bytesPerSequence;
    }
    return str;
  }
  function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
  }
  function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
      c = str.charCodeAt(i);
      if (c > 55295 && c < 57344) {
        if (lead) {
          if (c < 56320) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = c;
            continue;
          } else {
            c = lead - 55296 << 10 | c - 56320 | 65536;
            lead = null;
          }
        } else {
          if (c > 56319 || i + 1 === str.length) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
          } else {
            lead = c;
          }
          continue;
        }
      } else if (lead) {
        buf[pos++] = 239;
        buf[pos++] = 191;
        buf[pos++] = 189;
        lead = null;
      }
      if (c < 128) {
        buf[pos++] = c;
      } else {
        if (c < 2048) {
          buf[pos++] = c >> 6 | 192;
        } else {
          if (c < 65536) {
            buf[pos++] = c >> 12 | 224;
          } else {
            buf[pos++] = c >> 18 | 240;
            buf[pos++] = c >> 12 & 63 | 128;
          }
          buf[pos++] = c >> 6 & 63 | 128;
        }
        buf[pos++] = c & 63 | 128;
      }
    }
    return pos;
  }
  return pbf;
}
var vectorTile = {};
var pointGeometry;
var hasRequiredPointGeometry;
function requirePointGeometry() {
  if (hasRequiredPointGeometry)
    return pointGeometry;
  hasRequiredPointGeometry = 1;
  pointGeometry = Point2;
  function Point2(x, y) {
    this.x = x;
    this.y = y;
  }
  Point2.prototype = {
    /**
     * Clone this point, returning a new point that can be modified
     * without affecting the old one.
     * @return {Point} the clone
     */
    clone: function() {
      return new Point2(this.x, this.y);
    },
    /**
     * Add this point's x & y coordinates to another point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    add: function(p) {
      return this.clone()._add(p);
    },
    /**
     * Subtract this point's x & y coordinates to from point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    sub: function(p) {
      return this.clone()._sub(p);
    },
    /**
     * Multiply this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    multByPoint: function(p) {
      return this.clone()._multByPoint(p);
    },
    /**
     * Divide this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    divByPoint: function(p) {
      return this.clone()._divByPoint(p);
    },
    /**
     * Multiply this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    mult: function(k) {
      return this.clone()._mult(k);
    },
    /**
     * Divide this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    div: function(k) {
      return this.clone()._div(k);
    },
    /**
     * Rotate this point around the 0, 0 origin by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @return {Point} output point
     */
    rotate: function(a) {
      return this.clone()._rotate(a);
    },
    /**
     * Rotate this point around p point by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @param {Point} p Point to rotate around
     * @return {Point} output point
     */
    rotateAround: function(a, p) {
      return this.clone()._rotateAround(a, p);
    },
    /**
     * Multiply this point by a 4x1 transformation matrix
     * @param {Array<Number>} m transformation matrix
     * @return {Point} output point
     */
    matMult: function(m) {
      return this.clone()._matMult(m);
    },
    /**
     * Calculate this point but as a unit vector from 0, 0, meaning
     * that the distance from the resulting point to the 0, 0
     * coordinate will be equal to 1 and the angle from the resulting
     * point to the 0, 0 coordinate will be the same as before.
     * @return {Point} unit vector point
     */
    unit: function() {
      return this.clone()._unit();
    },
    /**
     * Compute a perpendicular point, where the new y coordinate
     * is the old x coordinate and the new x coordinate is the old y
     * coordinate multiplied by -1
     * @return {Point} perpendicular point
     */
    perp: function() {
      return this.clone()._perp();
    },
    /**
     * Return a version of this point with the x & y coordinates
     * rounded to integers.
     * @return {Point} rounded point
     */
    round: function() {
      return this.clone()._round();
    },
    /**
     * Return the magitude of this point: this is the Euclidean
     * distance from the 0, 0 coordinate to this point's x and y
     * coordinates.
     * @return {Number} magnitude
     */
    mag: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    /**
     * Judge whether this point is equal to another point, returning
     * true or false.
     * @param {Point} other the other point
     * @return {boolean} whether the points are equal
     */
    equals: function(other) {
      return this.x === other.x && this.y === other.y;
    },
    /**
     * Calculate the distance from this point to another point
     * @param {Point} p the other point
     * @return {Number} distance
     */
    dist: function(p) {
      return Math.sqrt(this.distSqr(p));
    },
    /**
     * Calculate the distance from this point to another point,
     * without the square root step. Useful if you're comparing
     * relative distances.
     * @param {Point} p the other point
     * @return {Number} distance
     */
    distSqr: function(p) {
      var dx = p.x - this.x, dy = p.y - this.y;
      return dx * dx + dy * dy;
    },
    /**
     * Get the angle from the 0, 0 coordinate to this point, in radians
     * coordinates.
     * @return {Number} angle
     */
    angle: function() {
      return Math.atan2(this.y, this.x);
    },
    /**
     * Get the angle from this point to another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleTo: function(b) {
      return Math.atan2(this.y - b.y, this.x - b.x);
    },
    /**
     * Get the angle between this point and another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleWith: function(b) {
      return this.angleWithSep(b.x, b.y);
    },
    /*
     * Find the angle of the two vectors, solving the formula for
     * the cross product a x b = |a||b|sin() for .
     * @param {Number} x the x-coordinate
     * @param {Number} y the y-coordinate
     * @return {Number} the angle in radians
     */
    angleWithSep: function(x, y) {
      return Math.atan2(
        this.x * y - this.y * x,
        this.x * x + this.y * y
      );
    },
    _matMult: function(m) {
      var x = m[0] * this.x + m[1] * this.y, y = m[2] * this.x + m[3] * this.y;
      this.x = x;
      this.y = y;
      return this;
    },
    _add: function(p) {
      this.x += p.x;
      this.y += p.y;
      return this;
    },
    _sub: function(p) {
      this.x -= p.x;
      this.y -= p.y;
      return this;
    },
    _mult: function(k) {
      this.x *= k;
      this.y *= k;
      return this;
    },
    _div: function(k) {
      this.x /= k;
      this.y /= k;
      return this;
    },
    _multByPoint: function(p) {
      this.x *= p.x;
      this.y *= p.y;
      return this;
    },
    _divByPoint: function(p) {
      this.x /= p.x;
      this.y /= p.y;
      return this;
    },
    _unit: function() {
      this._div(this.mag());
      return this;
    },
    _perp: function() {
      var y = this.y;
      this.y = this.x;
      this.x = -y;
      return this;
    },
    _rotate: function(angle) {
      var cos = Math.cos(angle), sin = Math.sin(angle), x = cos * this.x - sin * this.y, y = sin * this.x + cos * this.y;
      this.x = x;
      this.y = y;
      return this;
    },
    _rotateAround: function(angle, p) {
      var cos = Math.cos(angle), sin = Math.sin(angle), x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y), y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
      this.x = x;
      this.y = y;
      return this;
    },
    _round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
  };
  Point2.convert = function(a) {
    if (a instanceof Point2) {
      return a;
    }
    if (Array.isArray(a)) {
      return new Point2(a[0], a[1]);
    }
    return a;
  };
  return pointGeometry;
}
var vectortilefeature;
var hasRequiredVectortilefeature;
function requireVectortilefeature() {
  if (hasRequiredVectortilefeature)
    return vectortilefeature;
  hasRequiredVectortilefeature = 1;
  var Point2 = requirePointGeometry();
  vectortilefeature = VectorTileFeature;
  function VectorTileFeature(pbf2, end, extent2, keys, values) {
    this.properties = {};
    this.extent = extent2;
    this.type = 0;
    this._pbf = pbf2;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    pbf2.readFields(readFeature, this, end);
  }
  function readFeature(tag, feature, pbf2) {
    if (tag == 1)
      feature.id = pbf2.readVarint();
    else if (tag == 2)
      readTag(pbf2, feature);
    else if (tag == 3)
      feature.type = pbf2.readVarint();
    else if (tag == 4)
      feature._geometry = pbf2.pos;
  }
  function readTag(pbf2, feature) {
    var end = pbf2.readVarint() + pbf2.pos;
    while (pbf2.pos < end) {
      var key = feature._keys[pbf2.readVarint()], value = feature._values[pbf2.readVarint()];
      feature.properties[key] = value;
    }
  }
  VectorTileFeature.types = ["Unknown", "Point", "LineString", "Polygon"];
  VectorTileFeature.prototype.loadGeometry = function() {
    var pbf2 = this._pbf;
    pbf2.pos = this._geometry;
    var end = pbf2.readVarint() + pbf2.pos, cmd = 1, length = 0, x = 0, y = 0, lines = [], line;
    while (pbf2.pos < end) {
      if (length <= 0) {
        var cmdLen = pbf2.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x += pbf2.readSVarint();
        y += pbf2.readSVarint();
        if (cmd === 1) {
          if (line)
            lines.push(line);
          line = [];
        }
        line.push(new Point2(x, y));
      } else if (cmd === 7) {
        if (line) {
          line.push(line[0].clone());
        }
      } else {
        throw new Error("unknown command " + cmd);
      }
    }
    if (line)
      lines.push(line);
    return lines;
  };
  VectorTileFeature.prototype.bbox = function() {
    var pbf2 = this._pbf;
    pbf2.pos = this._geometry;
    var end = pbf2.readVarint() + pbf2.pos, cmd = 1, length = 0, x = 0, y = 0, x1 = Infinity, x2 = -Infinity, y1 = Infinity, y2 = -Infinity;
    while (pbf2.pos < end) {
      if (length <= 0) {
        var cmdLen = pbf2.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x += pbf2.readSVarint();
        y += pbf2.readSVarint();
        if (x < x1)
          x1 = x;
        if (x > x2)
          x2 = x;
        if (y < y1)
          y1 = y;
        if (y > y2)
          y2 = y;
      } else if (cmd !== 7) {
        throw new Error("unknown command " + cmd);
      }
    }
    return [x1, y1, x2, y2];
  };
  VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z), x0 = this.extent * x, y0 = this.extent * y, coords = this.loadGeometry(), type = VectorTileFeature.types[this.type], i, j;
    function project(line) {
      for (var j2 = 0; j2 < line.length; j2++) {
        var p = line[j2], y2 = 180 - (p.y + y0) * 360 / size;
        line[j2] = [
          (p.x + x0) * 360 / size - 180,
          360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
        ];
      }
    }
    switch (this.type) {
      case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
          points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;
      case 2:
        for (i = 0; i < coords.length; i++) {
          project(coords[i]);
        }
        break;
      case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
          for (j = 0; j < coords[i].length; j++) {
            project(coords[i][j]);
          }
        }
        break;
    }
    if (coords.length === 1) {
      coords = coords[0];
    } else {
      type = "Multi" + type;
    }
    var result = {
      type: "Feature",
      geometry: {
        type,
        coordinates: coords
      },
      properties: this.properties
    };
    if ("id" in this) {
      result.id = this.id;
    }
    return result;
  };
  function classifyRings(rings) {
    var len = rings.length;
    if (len <= 1)
      return [rings];
    var polygons = [], polygon, ccw;
    for (var i = 0; i < len; i++) {
      var area2 = signedArea2(rings[i]);
      if (area2 === 0)
        continue;
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon)
          polygons.push(polygon);
        polygon = [rings[i]];
      } else {
        polygon.push(rings[i]);
      }
    }
    if (polygon)
      polygons.push(polygon);
    return polygons;
  }
  function signedArea2(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p12, p22; i < len; j = i++) {
      p12 = ring[i];
      p22 = ring[j];
      sum += (p22.x - p12.x) * (p12.y + p22.y);
    }
    return sum;
  }
  return vectortilefeature;
}
var vectortilelayer;
var hasRequiredVectortilelayer;
function requireVectortilelayer() {
  if (hasRequiredVectortilelayer)
    return vectortilelayer;
  hasRequiredVectortilelayer = 1;
  var VectorTileFeature = requireVectortilefeature();
  vectortilelayer = VectorTileLayer;
  function VectorTileLayer(pbf2, end) {
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf2;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf2.readFields(readLayer, this, end);
    this.length = this._features.length;
  }
  function readLayer(tag, layer, pbf2) {
    if (tag === 15)
      layer.version = pbf2.readVarint();
    else if (tag === 1)
      layer.name = pbf2.readString();
    else if (tag === 5)
      layer.extent = pbf2.readVarint();
    else if (tag === 2)
      layer._features.push(pbf2.pos);
    else if (tag === 3)
      layer._keys.push(pbf2.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage(pbf2));
  }
  function readValueMessage(pbf2) {
    var value = null, end = pbf2.readVarint() + pbf2.pos;
    while (pbf2.pos < end) {
      var tag = pbf2.readVarint() >> 3;
      value = tag === 1 ? pbf2.readString() : tag === 2 ? pbf2.readFloat() : tag === 3 ? pbf2.readDouble() : tag === 4 ? pbf2.readVarint64() : tag === 5 ? pbf2.readVarint() : tag === 6 ? pbf2.readSVarint() : tag === 7 ? pbf2.readBoolean() : null;
    }
    return value;
  }
  VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length)
      throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[i];
    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
  };
  return vectortilelayer;
}
var vectortile;
var hasRequiredVectortile;
function requireVectortile() {
  if (hasRequiredVectortile)
    return vectortile;
  hasRequiredVectortile = 1;
  var VectorTileLayer = requireVectortilelayer();
  vectortile = VectorTile2;
  function VectorTile2(pbf2, end) {
    this.layers = pbf2.readFields(readTile, {}, end);
  }
  function readTile(tag, layers, pbf2) {
    if (tag === 3) {
      var layer = new VectorTileLayer(pbf2, pbf2.readVarint() + pbf2.pos);
      if (layer.length)
        layers[layer.name] = layer;
    }
  }
  return vectortile;
}
var hasRequiredVectorTile;
function requireVectorTile() {
  if (hasRequiredVectorTile)
    return vectorTile;
  hasRequiredVectorTile = 1;
  vectorTile.VectorTile = requireVectortile();
  vectorTile.VectorTileFeature = requireVectortilefeature();
  vectorTile.VectorTileLayer = requireVectortilelayer();
  return vectorTile;
}
var GeoJsonParser = {};
var hasRequiredGeoJsonParser;
function requireGeoJsonParser() {
  if (hasRequiredGeoJsonParser)
    return GeoJsonParser;
  hasRequiredGeoJsonParser = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(GeoJsonParser, "__esModule", {
    value: true
  });
  GeoJsonParser.default = void 0;
  var _Coordinates = _interopRequireDefault2(requireCoordinates());
  var _Extent2 = _interopRequireDefault2(requireExtent());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function applyOffset(indices, offset) {
    var _iterator = _createForOfIteratorHelper2(indices), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var indice = _step.value;
        indice.offset += offset;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return indices;
  }
  function readCRS(json) {
    if (json.crs) {
      if (json.crs.type.toLowerCase() === "epsg") {
        return "EPSG:".concat(json.crs.properties.code);
      }
      if (json.crs.type.toLowerCase() === "name") {
        var epsgIdx = json.crs.properties.name.toLowerCase().indexOf("epsg:");
        if (epsgIdx >= 0) {
          var codeStart = json.crs.properties.name.indexOf(":", epsgIdx + 5);
          if (codeStart > 0) {
            return "EPSG:".concat(json.crs.properties.name.substr(codeStart + 1));
          }
        }
      }
      throw new Error("Unsupported CRS type '".concat(json.crs, "'"));
    }
    return "EPSG:4326";
  }
  var tmpCoords = new _Coordinates.default("EPSG:4978", 0, 0, 0);
  function readCoordinates(crsIn, crsOut, coordinates, extent2, target) {
    var offset = 0;
    if (target) {
      offset = target.length;
      target.length += coordinates.length;
    }
    var out = target || new Array(coordinates.length);
    var i = 0;
    var z = 1;
    var _iterator2 = _createForOfIteratorHelper2(coordinates), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var pair = _step2.value;
        if (typeof pair[2] === "number") {
          z = pair[2];
        }
        if (crsIn === crsOut) {
          out[offset + i] = new _Coordinates.default(crsIn, pair[0], pair[1], z);
        } else {
          tmpCoords.set(crsIn, pair[0], pair[1], z);
          out[offset + i] = tmpCoords.as(crsOut);
        }
        if (extent2) {
          extent2.expandByPoint(out[offset + i]);
        }
        ++i;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return out;
  }
  var GeometryToCoordinates = {
    point: function point(feature, crsIn, crsOut, coordsIn, filteringExtent, options) {
      var extent2 = options.buildExtent ? new _Extent2.default(crsOut, Infinity, -Infinity, Infinity, -Infinity) : void 0;
      var coordinates = readCoordinates(crsIn, crsOut, coordsIn, extent2);
      if (filteringExtent) {
        coordinates = coordinates.filter(function(c) {
          return filteringExtent.isPointInside(c);
        });
      }
      feature.vertices = feature.vertices.concat(coordinates);
      feature.geometry.push({
        extent: extent2
      });
      return feature;
    },
    polygon: function polygon(feature, crsIn, crsOut, coordsIn, filteringExtent, options) {
      var extent2 = options.buildExtent ? new _Extent2.default(crsOut, Infinity, -Infinity, Infinity, -Infinity) : void 0;
      var coordinates = readCoordinates(crsIn, crsOut, coordsIn[0], extent2);
      if (filteringExtent && !filteringExtent.isPointInside(coordinates[0])) {
        return null;
      }
      var indices = [{
        offset: 0,
        count: coordinates.length
      }];
      var offset = coordinates.length;
      for (var i = 1; i < coordsIn.length; i++) {
        readCoordinates(crsIn, crsOut, coordsIn[i], extent2, coordinates);
        var count = coordinates.length - offset;
        indices.push({
          offset,
          count
        });
        offset += count;
      }
      feature.vertices = feature.vertices.concat(coordinates);
      feature.geometry.push({
        extent: extent2,
        indices
      });
      return feature;
    },
    lineString: function lineString(feature, crsIn, crsOut, coordsIn, filteringExtent, options) {
      var extent2 = options.buildExtent ? new _Extent2.default(crsOut, Infinity, -Infinity, Infinity, -Infinity) : void 0;
      var coordinates = readCoordinates(crsIn, crsOut, coordsIn, extent2);
      if (filteringExtent && !filteringExtent.isPointInside(coordinates[0])) {
        return null;
      }
      var indices = [{
        offset: 0,
        count: coordinates.length
      }];
      feature.vertices = feature.vertices.concat(coordinates);
      feature.geometry.push({
        extent: extent2,
        indices
      });
      return feature;
    },
    multi: function multi(type, feature, crsIn, crsOut, coordsIn, filteringExtent, options) {
      if (coordsIn.length === 1) {
        return this[type](feature, crsIn, crsOut, coordsIn[0], filteringExtent, options);
      }
      var globalOffset = 0;
      var indices;
      var _iterator3 = _createForOfIteratorHelper2(coordsIn), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var coords = _step3.value;
          if (this[type](feature, crsIn, crsOut, coords, filteringExtent, options)) {
            indices = feature.geometry[feature.geometry.length - 1].indices;
            applyOffset(indices, globalOffset);
            var lastIndice = indices[indices.length - 1];
            globalOffset = lastIndice.offset + lastIndice.count;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return feature;
    }
  };
  function readGeometry(feature, crsIn, crsOut, geometry, filteringExtent, options) {
    if (geometry.length === 0) {
      return null;
    }
    switch (feature.type) {
      case "point":
        return GeometryToCoordinates.point(feature, crsIn, crsOut, [geometry], filteringExtent, options);
      case "multipoint":
        return GeometryToCoordinates.multi("point", feature, crsIn, crsOut, geometry, filteringExtent, options);
      case "linestring":
        return GeometryToCoordinates.lineString(feature, crsIn, crsOut, geometry, filteringExtent, options);
      case "multilinestring":
        return GeometryToCoordinates.multi("lineString", feature, crsIn, crsOut, geometry, filteringExtent, options);
      case "polygon":
        return GeometryToCoordinates.polygon(feature, crsIn, crsOut, geometry, filteringExtent, options);
      case "multipolygon":
        return GeometryToCoordinates.multi("polygon", feature, crsIn, crsOut, geometry, filteringExtent, options);
      case "geometrycollection":
      default:
        throw new Error("Unhandled geometry type ".concat(feature.type));
    }
  }
  function readFeature(crsIn, crsOut, json, filteringExtent, options) {
    if (options.filter && !options.filter(json.properties, json.geometry)) {
      return null;
    }
    var feature = {
      type: json.geometry.type.toLowerCase(),
      geometry: [],
      vertices: []
    };
    readGeometry(feature, crsIn, crsOut, json.geometry.coordinates, filteringExtent, options);
    if (feature.geometry.length === 0) {
      return null;
    }
    if (options.buildExtent) {
      var _iterator4 = _createForOfIteratorHelper2(feature.geometry), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var g = _step4.value;
          feature.extent = feature.extent || g.extent;
          feature.extent.union(g.extent);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
    feature.properties = json.properties || {};
    for (var _i = 0, _Object$keys = Object.keys(json); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (["type", "geometry", "properties"].indexOf(key.toLowerCase()) < 0) {
        feature.properties[key] = json[key];
      }
    }
    if (options.featureCb instanceof Function) {
      options.featureCb(feature);
    }
    return feature;
  }
  function readFeatures(crsIn, crsOut, features, filteringExtent, options) {
    var res = {
      features: []
    };
    var _iterator5 = _createForOfIteratorHelper2(features), _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var feature = _step5.value;
        var f = readFeature(crsIn, crsOut, feature, filteringExtent, options);
        if (f) {
          if (options.buildExtent) {
            if (res.extent) {
              res.extent.union(f.extent);
            } else {
              res.extent = f.extent.clone();
            }
          }
          res.features.push(f);
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    return res;
  }
  var _default2 = {
    /**
     * Similar to the geometry of a feature in a GeoJSON, but adapted to giro3d.
     * The difference is that coordinates are stored as {@link Coordinates}
     * instead of raw values. If needed, more information is provided.
     *
     * @typedef FeatureGeometry
     * @type {object}
     * @property {Extent} extent - The 2D extent containing all the points
     * composing the geometry.
     * @property {?object[]} indices - If this geometry is a
     * <code>linestring</code> or a <code>polygon</code>, contains the indices
     * that define the geometry. Objects stored in this array have two
     * properties, an <code>offset</code> and a <code>count</code>. The offset
     * is related to the overall number of vertices in the Feature.
     */
    /**
     * Similar to a feature in a GeoJSON, but adapted to giro3d.
     *
     * @typedef Feature
     * @type {object}
     * @property {string} type - Geometry type, can be <code>point</code>,
     * <code>multipoint</code>, <code>linestring</code>,
     * <code>multilinestring</code>, <code>polygon</code> or
     * <code>multipolygon</code>.
     * @property {Coordinates[]} vertices - All the vertices of the geometry.
     * @property {FeatureGeometry[]} geometry - The feature's geometry, as an
     * array of [FeatureGeometry]{@link module:GeoJsonParser~FeatureGeometry}.
     * @property {object} properties - Properties of the features. It can be
     * anything specified in the GeoJSON under the <code>properties</code>
     * property.
     * @property {Extent?} extent - The 2D extent containing all the geometries
     * composing the feature.
     */
    /**
     * An object regrouping a list of [features]{@link
     * module:GeoJsonParser~Feature} and the extent of this collection.
     *
     * @typedef FeatureCollection
     * @type {object}
     * @property {Feature[]} features - The array of features composing the
     * collection.
     * @property {Extent?} extent - The 2D extent containing all the features
     * composing the collection.
     */
    /**
     * Parse a GeoJSON file content and return a [FeatureCollection]{@link
     * module:GeoJsonParser~FeatureCollection}.
     *
     * @param {string} json The GeoJSON file content to parse.
     * @param {object} options Options controlling the parsing.
     * @param {string} options.crsOut The CRS to convert the input coordinates
     * to.
     * @param {string} options.crsIn Override the data CRS.
     * @param {Extent} [options.filteringExtent] Optional filter to reject
     * features outside of this extent.
     * @param {boolean} [options.buildExtent=false] If true the geometry will
     * have an extent property containing the area covered by the geom
     * @param {Function} [options.filter] Filter function to remove features
     * @returns {Promise} A promise resolving with a [FeatureCollection]{@link
     * module:GeoJsonParser~FeatureCollection}.
     */
    parse: function parse2(json) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var crsOut = options.crsOut;
      var filteringExtent = options.filteringExtent;
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      options.crsIn = options.crsIn || readCRS(json);
      switch (json.type.toLowerCase()) {
        case "featurecollection":
          return Promise.resolve(readFeatures(options.crsIn, crsOut, json.features, filteringExtent, options));
        case "feature":
          return Promise.resolve(readFeatures(options.crsIn, crsOut, [json], filteringExtent, options));
        default:
          throw new Error("Unsupported GeoJSON type: '".concat(json.type));
      }
    }
  };
  GeoJsonParser.default = _default2;
  return GeoJsonParser;
}
var hasRequiredVectorTileParser;
function requireVectorTileParser() {
  if (hasRequiredVectorTileParser)
    return VectorTileParser;
  hasRequiredVectorTileParser = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(VectorTileParser, "__esModule", {
    value: true
  });
  VectorTileParser.default = void 0;
  var _pbf = _interopRequireDefault2(requirePbf());
  var _vectorTile = requireVectorTile();
  var _GeoJsonParser = _interopRequireDefault2(requireGeoJsonParser());
  _interopRequireDefault2(requireExtent());
  function readPBF(file2, options) {
    var vectorTile2 = new _vectorTile.VectorTile(new _pbf.default(file2));
    var layers = Object.keys(vectorTile2.layers);
    if (layers.length < 1)
      return null;
    var geojson = {
      type: "FeatureCollection",
      features: [],
      crs: {
        type: "EPSG",
        properties: {
          code: 4326
        }
      },
      extent: options.extent
    };
    layers.forEach(function(layerId) {
      var l = vectorTile2.layers[layerId];
      for (var i = 0; i < l.length; i++) {
        var feature = void 0;
        if (options.origin === "top") {
          feature = l.feature(i).toGeoJSON(options.coords.col, options.coords.row, options.coords.zoom);
        } else {
          var y = 1 << options.coords.zoom;
          feature = l.feature(i).toGeoJSON(options.coords.col, y - options.coords.row - 1, options.coords.zoom);
        }
        if (layers.length > 1) {
          feature.properties.vt_layer = layerId;
        }
        geojson.features.push(feature);
      }
    });
    var crsOut;
    switch (options.coords.crs()) {
      case "WMTS:PM":
        crsOut = "EPSG:3857";
        break;
      default:
        crsOut = options.extent.crs();
    }
    return _GeoJsonParser.default.parse(geojson, {
      crsOut,
      filteringExtent: options.filteringExtent,
      filter: options.filter,
      buildExtent: true
    });
  }
  var _default2 = {
    /**
     * Parse a vector tile file and return a [Feature]{@link module:GeoJsonParser.Feature}
     * or an array of Features. While multiple formats of vector tile are
     * available, the only one supported for the moment is the
     * [Mapbox Vector Tile]{@link https://www.mapbox.com/vector-tiles/specification/}.
     *
     * @param {ArrayBuffer} file The vector tile file to parse.
     * @param {object} options Options controlling the parsing.
     * @param {Extent} options.extent The Extent to convert the input coordinates to.
     * @param {Extent} options.coords Coordinates of the layer.
     * @param {Extent=} options.filteringExtent Optional filter to reject features
     * outside of this extent.
     * @param {Function=} options.filter Filter function to remove features.
     * @param {string=} options.origin This option is to be set to the correct
     * value, bottom or top (default being bottom), if the computation of the
     * coordinates needs to be inverted to same scheme as OSM, Google Maps or
     * other system. See [this link]{@link https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates} for more informations.
     * @returns {Promise} A Promise resolving with a Feature or an array a
     * Features.
     */
    parse: function parse2(file2, options) {
      return Promise.resolve(readPBF(file2, options));
    }
  };
  VectorTileParser.default = _default2;
  return VectorTileParser;
}
var Feature2Texture = {};
var hasRequiredFeature2Texture;
function requireFeature2Texture() {
  if (hasRequiredFeature2Texture)
    return Feature2Texture;
  hasRequiredFeature2Texture = 1;
  Object.defineProperty(Feature2Texture, "__esModule", {
    value: true
  });
  Feature2Texture.default = void 0;
  var _three2 = require$$8$1;
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var pt = new _three2.Vector2();
  function _moveTo(ctx, coord, scale2, origin) {
    pt.x = coord._values[0] - origin.x;
    pt.y = origin.y - coord._values[1];
    pt.multiply(scale2);
    ctx.moveTo(pt.x, pt.y);
  }
  function _lineTo(ctx, coord, scale2, origin) {
    pt.x = coord._values[0] - origin.x;
    pt.y = origin.y - coord._values[1];
    pt.multiply(scale2);
    ctx.lineTo(pt.x, pt.y);
  }
  function drawPolygon(ctx, vertices, indices, origin, scale2, properties) {
    var style2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {};
    if (vertices.length === 0) {
      return;
    }
    if (style2.length) {
      var _iterator = _createForOfIteratorHelper2(style2), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var s = _step.value;
          _drawPolygon(ctx, vertices, indices, origin, scale2, properties, s);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      _drawPolygon(ctx, vertices, indices, origin, scale2, properties, style2);
    }
  }
  function _drawPolygon(ctx, vertices, indices, origin, scale2, properties, style2) {
    ctx.beginPath();
    var _iterator2 = _createForOfIteratorHelper2(indices), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var indice = _step2.value;
        _moveTo(ctx, vertices[indice.offset], scale2, origin);
        for (var j = 1; j < indice.count; j++) {
          _lineTo(ctx, vertices[indice.offset + j], scale2, origin);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (style2.stroke || properties.stroke) {
      ctx.strokeStyle = style2.stroke || properties.stroke;
      ctx.lineWidth = style2.strokeWidth || properties["stroke-width"] || 2;
      ctx.globalAlpha = style2.strokeOpacity || properties["stroke-opacity"] || 1;
      ctx.lineCap = style2.strokeCap || properties["stroke-cap"] || "butt";
      ctx.stroke();
    }
    if (indices && (style2.fill || properties.fill)) {
      ctx.fillStyle = style2.fill || properties.fill;
      ctx.globalAlpha = style2.fillOpacity || properties["fill-opacity"] || 1;
      ctx.fill();
    }
  }
  function drawPoint(ctx, vertice, origin, scale2) {
    var style2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    pt.x = vertice._values[0] - origin.x;
    pt.y = origin.y - vertice._values[1];
    pt.multiply(scale2);
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, style2.radius || 3, 0, 2 * Math.PI, false);
    ctx.fillStyle = style2.fill || "white";
    ctx.fill();
    ctx.lineWidth = style2.lineWidth || 1;
    ctx.strokeStyle = style2.stroke || "red";
    ctx.stroke();
  }
  function drawFeature(ctx, feature, origin, scale2, extent2) {
    var style2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    var properties = feature.properties;
    if (typeof style2 === "function") {
      style2 = style2(properties, feature);
    }
    var _iterator3 = _createForOfIteratorHelper2(feature.geometry), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var geometry = _step3.value;
        if (feature.type === "point") {
          drawPoint(ctx, feature.vertices[0], origin, scale2, style2);
        } else if (geometry.extent.intersectsExtent(extent2)) {
          drawPolygon(ctx, feature.vertices, geometry.indices, origin, scale2, properties, style2);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  var _default2 = {
    // backgroundColor is a Color to specify a color to fill the texture
    // with, given there is no feature passed in parameter
    createTextureFromFeature: function createTextureFromFeature(collection, extent2, sizeTexture, style2, backgroundColor) {
      var texture;
      if (collection) {
        var origin = new _three2.Vector2(extent2.west(), extent2.north());
        var dimension = extent2.dimensions();
        var c = document.createElement("canvas");
        c.width = sizeTexture;
        c.height = sizeTexture;
        var ctx = c.getContext("2d");
        if (backgroundColor) {
          ctx.fillStyle = backgroundColor.getStyle();
          ctx.fillRect(0, 0, sizeTexture, sizeTexture);
        }
        ctx.globalCompositeOperation = style2.globalCompositeOperation || "source-over";
        var scale2 = new _three2.Vector2(ctx.canvas.width / dimension.x, ctx.canvas.width / dimension.y);
        var _iterator4 = _createForOfIteratorHelper2(collection.features), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var feature = _step4.value;
            drawFeature(ctx, feature, origin, scale2, extent2, style2);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        texture = new _three2.Texture(c);
        texture.flipY = false;
        texture.generateMipmaps = false;
        texture.magFilter = _three2.LinearFilter;
        texture.minFilter = _three2.LinearFilter;
        texture.needsUpdate = true;
      } else if (backgroundColor) {
        var data = new Uint8Array(3);
        data[0] = backgroundColor.r * 255;
        data[1] = backgroundColor.g * 255;
        data[2] = backgroundColor.b * 255;
        texture = new _three2.DataTexture(data, 1, 1, _three2.RGBFormat);
        texture.needsUpdate = true;
      } else {
        texture = new _three2.Texture();
      }
      return texture;
    },
    featuresAtPoint: function featuresAtPoint(collection, extent2, sizeTexture, style2, point, radius) {
      if (!collection) {
        return [];
      }
      var results = [];
      var dimension = extent2.dimensions();
      var scale2 = new _three2.Vector2(sizeTexture / dimension.x, sizeTexture / dimension.y);
      var origin = new _three2.Vector2(point.x - radius / scale2.x, point.y + radius / scale2.y);
      var c = document.createElement("canvas");
      c.width = 1 + radius * 2;
      c.height = 1 + radius * 2;
      var ctx = c.getContext("2d");
      ctx.globalCompositeOperation = "source-over";
      var _iterator5 = _createForOfIteratorHelper2(collection.features), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var feature = _step5.value;
          ctx.clearRect(0, 0, c.width, c.height);
          drawFeature(ctx, feature, origin, scale2, extent2, style2);
          var imgd = ctx.getImageData(0, 0, c.width, c.height);
          var pix = imgd.data;
          var found = false;
          for (var i = 0; i < imgd.data.length; i += 4) {
            found = found || pix[i + 3] > 0;
            if (found)
              break;
          }
          if (found) {
            results.push(feature);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return results;
    }
  };
  Feature2Texture.default = _default2;
  return Feature2Texture;
}
var hasRequiredVectorTileHelper;
function requireVectorTileHelper() {
  if (hasRequiredVectorTileHelper)
    return VectorTileHelper;
  hasRequiredVectorTileHelper = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(VectorTileHelper, "__esModule", {
    value: true
  });
  VectorTileHelper.default = void 0;
  var _three2 = require$$8$1;
  var _Fetcher = _interopRequireDefault2(requireFetcher());
  var _Cache = _interopRequireDefault2(requireCache());
  var _VectorTileParser = _interopRequireDefault2(requireVectorTileParser());
  var _Feature2Texture = _interopRequireDefault2(requireFeature2Texture());
  _interopRequireDefault2(requireExtent());
  _interopRequireDefault2(requireTileMesh());
  _interopRequireDefault2(requireLayer());
  var _ColorLayer = _interopRequireDefault2(requireColorLayer());
  var getVectorTileByUrl = function(url, tile, layer, coords) {
    return _Fetcher.default.arrayBuffer(url, layer.networkOptions).then(function(buffer2) {
      return _VectorTileParser.default.parse(buffer2, {
        extent: tile.extent,
        filteringExtent: layer.extent,
        filter: layer.filter,
        origin: layer.origin,
        coords
      });
    });
  };
  var _default2 = {
    /**
     * Get a vector tile file, parse it and return a [FeatureCollection]{@link
     * module:GeoJsonParser.FeatureCollection}. See [VectorTileParser]{@link
     * module:VectorTileParser.parse} for more details on the parsing.
     *
     * @param {string} url The URL of the tile to fetch, NOT the template: use a
     * Provider instead if needed.
     * @param {TileMesh} tile
     * @param {Layer|object} layer A Layer to associate to the tile or an
     * object containing the necessary properties from the layer.
     * @param {Extent} layer.extent The Extent to convert the input coordinates to.
     * outside of this extent.
     * @param {Function=} layer.filter Filter function to remove features.
     * @param {string=} layer.origin This option is to be set to the correct
     * value, bottom or top (default being bottom), if the computation of the
     * coordinates needs to be inverted to same scheme as OSM, Google Maps or
     * other system. See [this link]{@link https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates} for more informations.
     * @param {Extent} coords
     * @returns {Promise} A Promise resolving with a Feature Collection.
     * @function
     */
    getVectorTileByUrl,
    /**
     * Get a vector tile, parse it and return a [Texture]{@link https://threejs.org/docs/#api/textures/Texture}.
     *
     * @param {string} url The URL of the tile to fetch, NOT the template: use a
     * Provider instead if needed.
     * @param {TileMesh} tile the tile to fetch
     * @param {Layer} layer the layer of the vector tile
     * @param {Extent} coords the extent of the tile
     * @returns {object} Contains a <code>texture</code> property that is the
     * resulting texture of the vector tile.
     */
    getVectorTileTextureByUrl: function getVectorTileTextureByUrl(url, tile, layer, coords) {
      if (layer instanceof _ColorLayer.default)
        return null;
      return _Cache.default.get(url) || _Cache.default.set(url, getVectorTileByUrl(url, tile, layer, coords).then(function(features) {
        var backgroundColor = layer.backgroundLayer && layer.backgroundLayer.paint ? new _three2.Color(layer.backgroundLayer.paint["background-color"]) : void 0;
        var extentTexture;
        switch (coords.crs()) {
          case "TMS":
            extentTexture = tile.extent;
            break;
          case "WMTS:PM":
            extentTexture = coords.as("EPSG:3857");
            break;
          default:
            extentTexture = coords.as(tile.extent.crs());
        }
        var texture = _Feature2Texture.default.createTextureFromFeature(features, extentTexture, 256, layer.style, backgroundColor);
        texture.extent = tile.extent;
        texture.coords = coords;
        return texture;
      }));
    }
  };
  VectorTileHelper.default = _default2;
  return VectorTileHelper;
}
var hasRequiredTMSProvider;
function requireTMSProvider() {
  if (hasRequiredTMSProvider)
    return TMSProvider;
  hasRequiredTMSProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(TMSProvider, "__esModule", {
    value: true
  });
  TMSProvider.default = void 0;
  var _construct2 = _interopRequireDefault2(requireConstruct());
  var _toConsumableArray22 = _interopRequireDefault2(requireToConsumableArray());
  var _three2 = require$$8$1;
  var _OGCWebServiceHelper = _interopRequireDefault2(requireOGCWebServiceHelper());
  var _URLBuilder = _interopRequireDefault2(requireURLBuilder());
  var _Extent2 = _interopRequireDefault2(requireExtent());
  var _VectorTileHelper = _interopRequireDefault2(requireVectorTileHelper());
  var _LayerUpdateStrategy2 = requireLayerUpdateStrategy();
  function preprocessDataLayer(layer) {
    if (!layer.extent) {
      layer.extent = new _Extent2.default("EPSG:3857", -20037508342789244e-9, 20037508342789244e-9, -20037508342789244e-9, 20037508342789244e-9);
    }
    if (!(layer.extent instanceof _Extent2.default)) {
      if (!layer.projection) {
        throw new Error("Missing projection property for layer '".concat(layer.id, "'"));
      }
      layer.extent = (0, _construct2.default)(_Extent2.default, [layer.projection].concat((0, _toConsumableArray22.default)(layer.extent)));
    }
    layer.origin = layer.origin || (layer.protocol === "xyz" ? "top" : "bottom");
    if (!layer.options.zoom) {
      layer.options.zoom = {
        min: 0,
        max: 18
      };
    }
    layer.fx = layer.fx || 0;
  }
  function _group(nodeLevel, currentLevel, options) {
    var f = options.groups.filter(function(val) {
      return val <= nodeLevel;
    });
    return f.length ? f[f.length - 1] : options.groups[0];
  }
  function chooseExtentToDownload(extent2, currentExtent, layer, pitch, previousError) {
    if (layer.updateStrategy.type === _LayerUpdateStrategy2.STRATEGY_MIN_NETWORK_TRAFFIC) {
      return extent2;
    }
    var nextZoom = 0;
    if (currentExtent) {
      if (extent2.zoom <= currentExtent.zoom + 1) {
        return extent2;
      }
      switch (layer.updateStrategy.type) {
        case _LayerUpdateStrategy2.STRATEGY_PROGRESSIVE:
          nextZoom += 1;
          break;
        case _LayerUpdateStrategy2.STRATEGY_GROUP:
          nextZoom = _group(extent2.zoom, currentExtent.zoom, layer.updateStrategy.options);
          break;
        default:
        case _LayerUpdateStrategy2.STRATEGY_DICHOTOMY:
          nextZoom = Math.ceil((currentExtent.zoom + extent2.zoom) / 2);
          break;
      }
    }
    if (previousError && previousError.extent && previousError.extent.zoom === nextZoom) {
      nextZoom = Math.ceil((currentExtent.zoom + nextZoom) / 2);
    }
    nextZoom = Math.min(Math.max(nextZoom, layer.options.zoom.min), layer.options.zoom.max);
    if (extent2.zoom <= nextZoom) {
      return extent2;
    }
    return _OGCWebServiceHelper.default.WMTS_WGS84Parent(extent2, nextZoom, pitch);
  }
  function getPossibleTextureImprovements(layer, extent2, texture, previousError) {
    if (!extentInsideLimit(extent2, layer)) {
      return null;
    }
    if (extent2.zoom > layer.options.zoom.max) {
      return null;
    }
    if (!texture) {
      return selectAllExtentsToDownload(layer, extent2, texture, previousError);
    }
    if (!texture.extent || texture.extent.zoom < extent2.zoom) {
      return selectAllExtentsToDownload(layer, extent2, texture, previousError);
    }
    return false;
  }
  function selectAllExtentsToDownload(layer, extent_, texture, previousError) {
    var pitch = new _three2.Vector4(0, 0, 1, 1);
    var extent2 = chooseExtentToDownload(extent_, texture && texture.extent ? texture.extent : null, layer, pitch, previousError);
    if (texture && texture.extent && texture.extent.zoom === extent2.zoom) {
      return null;
    }
    return {
      extent: extent2,
      pitch,
      url: _URLBuilder.default.xyz(extent2, layer)
    };
  }
  function executeCommand(command) {
    var layer = command.layer;
    var promise;
    if (layer.format === "application/x-protobuf;type=mapbox-vector") {
      promise = _VectorTileHelper.default.getVectorTileTextureByUrl(
        command.toDownload,
        command.requester,
        layer
        /* , todo.extent */
      );
    } else {
      promise = _OGCWebServiceHelper.default.getColorTextureByUrl(command.toDownload, layer.networkOptions);
    }
    return promise.then(function(texture) {
      var result = {};
      result.texture = texture;
      if (layer.transparent) {
        texture.premultiplyAlpha = true;
      }
      return result;
    });
  }
  function tileTextureCount(tile, layer) {
    return tileInsideLimit(tile, layer) ? 1 : 0;
  }
  function tileInsideLimit(tile, layer) {
    return extentInsideLimit(tile.getExtentForLayer(layer), layer);
  }
  function extentInsideLimit(extent2, layer) {
    return layer.options.zoom.min <= extent2.zoom && extent2.zoom <= layer.options.zoom.max;
  }
  var _default2 = {
    preprocessDataLayer,
    executeCommand,
    tileTextureCount,
    tileInsideLimit,
    getPossibleTextureImprovements
  };
  TMSProvider.default = _default2;
  return TMSProvider;
}
var PointCloudProvider = {};
var PointCloudProcessing = {};
var hasRequiredPointCloudProcessing;
function requirePointCloudProcessing() {
  if (hasRequiredPointCloudProcessing)
    return PointCloudProcessing;
  hasRequiredPointCloudProcessing = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(PointCloudProcessing, "__esModule", {
    value: true
  });
  PointCloudProcessing.default = void 0;
  var _three2 = require$$8$1;
  var _CancelledCommandException = _interopRequireDefault2(requireCancelledCommandException());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var tmp2 = {
    v: new _three2.Vector3()
  };
  function computeScreenSpaceError(context, layer, elt, distance) {
    if (distance <= 0) {
      return Infinity;
    }
    var pointSpacing = layer.metadata.spacing / Math.pow(2, elt.name.length);
    var onScreenSpacing = context.camera.preSSE * pointSpacing / distance;
    return Math.max(0, onScreenSpacing - layer.pointSize);
  }
  function markForDeletion2(elt) {
    if (elt.obj) {
      elt.obj.material.visible = false;
    }
    if (!elt.notVisibleSince) {
      elt.notVisibleSince = Date.now();
      elt.sse = -1;
    }
    var _iterator = _createForOfIteratorHelper2(elt.children), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var child = _step.value;
        markForDeletion2(child);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  function updateMinMaxDistance(context, layer, bbox) {
    var distance = context.distance.plane.distanceToPoint(bbox.getCenter());
    var radius = bbox.getSize(tmp2.v).length() * 0.5;
    layer._distance.min = Math.min(layer._distance.min, distance - radius);
    layer._distance.max = Math.max(layer._distance.max, distance + radius);
    return distance;
  }
  var _default2 = {
    preUpdate: function preUpdate(layer) {
      return function(context, changeSources) {
        if (!layer.root) {
          return [];
        }
        context.camera.preSSE = context.camera.height / (2 * Math.tan(_three2.MathUtils.degToRad(context.camera.camera3D.fov) * 0.5));
        if (layer.material) {
          layer.material.visible = layer.visible;
          layer.material.opacity = layer.opacity;
          layer.material.transparent = layer.opacity < 1;
          layer.material.size = layer.pointSize;
        }
        var commonAncestorName;
        var _iterator2 = _createForOfIteratorHelper2(changeSources.values()), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var source = _step2.value;
            if (source.isCamera || source === layer) {
              return [layer.root];
            }
            if (source.obj === void 0) {
              continue;
            }
            if (source.obj.isPoints && source.obj.layer === layer) {
              if (!commonAncestorName) {
                commonAncestorName = source.name;
              } else {
                var nameLength = Math.min(source.name.length, commonAncestorName.length);
                var i = void 0;
                for (i = 0; i < nameLength; i++) {
                  if (source.name[i] !== commonAncestorName[i]) {
                    break;
                  }
                }
                commonAncestorName = commonAncestorName.substr(0, i);
                if (commonAncestorName.length === 0) {
                  break;
                }
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (commonAncestorName) {
          context.fastUpdateHint = commonAncestorName;
        }
        return [layer.root];
      };
    },
    update: function update(layer) {
      return function(context, elt) {
        if (layer.octreeDepthLimit >= 0 && layer.octreeDepthLimit < elt.name.length) {
          markForDeletion2(elt);
          return null;
        }
        var bbox = elt.tightbbox ? elt.tightbbox : elt.bbox;
        if (context.fastUpdateHint && !elt.name.startsWith(context.fastUpdateHint)) {
          if (!elt.visible) {
            return null;
          }
          updateMinMaxDistance(context, layer, bbox);
        } else {
          elt.visible = context.camera.isBox3Visible(bbox, layer.object3d.matrixWorld);
          if (!elt.visible) {
            markForDeletion2(elt);
            return null;
          }
          var distance = updateMinMaxDistance(context, layer, bbox);
          elt.notVisibleSince = void 0;
          if (elt.numPoints > 0) {
            if (elt.obj) {
              if (elt.obj.material.update) {
                elt.obj.material.update(layer.material);
              } else {
                elt.obj.material.copy(layer.material);
              }
            } else if (!elt.promise) {
              var priority = computeScreenSpaceError(context, layer, elt, distance) / Math.max(1e-3, distance);
              elt.promise = context.scheduler.execute({
                layer,
                requester: elt,
                view: context.instance,
                priority,
                redraw: true,
                isLeaf: elt.childrenBitField === 0,
                earlyDropFunction: function earlyDropFunction(cmd) {
                  return !cmd.requester.visible || !layer.visible;
                }
              }).then(function(pts) {
                if (layer.onPointsCreated) {
                  layer.onPointsCreated(layer, pts);
                }
                elt.obj = pts;
                elt.tightbbox = pts.tightbbox;
                layer.group.add(elt.obj);
                elt.obj.updateMatrixWorld(true);
                elt.promise = null;
              }, function(err) {
                if (err instanceof _CancelledCommandException.default) {
                  elt.promise = null;
                }
              });
            }
          }
          if (elt.children && elt.children.length) {
            elt.sse = computeScreenSpaceError(context, layer, elt, distance) / layer.sseThreshold;
          }
        }
        if (elt.children && elt.children.length) {
          if (elt.sse >= 1) {
            return elt.children;
          }
          var _iterator3 = _createForOfIteratorHelper2(elt.children), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var child = _step3.value;
              markForDeletion2(child);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
        return null;
      };
    },
    postUpdate: function postUpdate(layer) {
      return function() {
        if (!layer.group) {
          return;
        }
        layer.displayedCount = 0;
        var _iterator4 = _createForOfIteratorHelper2(layer.group.children), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _pts2 = _step4.value;
            if (_pts2.material.visible) {
              var _count2 = _pts2.geometry.attributes.position.count;
              _pts2.geometry.setDrawRange(0, _count2);
              layer.displayedCount += _count2;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        if (layer.displayedCount > layer.pointBudget) {
          if (layer.supportsProgressiveDisplay) {
            var reduction = layer.pointBudget / layer.displayedCount;
            var _iterator5 = _createForOfIteratorHelper2(layer.group.children), _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var pts = _step5.value;
                if (pts.material.visible) {
                  var count = Math.floor(pts.geometry.drawRange.count * reduction);
                  if (count > 0) {
                    pts.geometry.setDrawRange(0, count);
                  } else {
                    pts.material.visible = false;
                  }
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
            layer.displayedCount *= reduction;
          } else {
            layer.group.children.sort(function(p12, p22) {
              return p22.userData.metadata.sse - p12.userData.metadata.sse;
            });
            var limitHit = false;
            layer.displayedCount = 0;
            var _iterator6 = _createForOfIteratorHelper2(layer.group.children), _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                var _pts = _step6.value;
                var _count = _pts.geometry.attributes.position.count;
                if (limitHit || layer.displayedCount + _count > layer.pointBudget) {
                  _pts.material.visible = false;
                  limitHit = true;
                } else {
                  layer.displayedCount += _count;
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        }
        var now2 = Date.now();
        for (var i = layer.group.children.length - 1; i >= 0; i--) {
          var obj = layer.group.children[i];
          var notVisibleSince = obj.userData.metadata.notVisibleSince;
          if (!obj.material.visible && now2 - notVisibleSince > 1e4) {
            layer.group.children.splice(i, 1);
            obj.material.dispose();
            obj.geometry.dispose();
            obj.material = null;
            obj.geometry = null;
            obj.userData.metadata.obj = null;
          }
        }
      };
    }
  };
  PointCloudProcessing.default = _default2;
  return PointCloudProcessing;
}
var PotreeBinParser = {};
var hasRequiredPotreeBinParser;
function requirePotreeBinParser() {
  if (hasRequiredPotreeBinParser)
    return PotreeBinParser;
  hasRequiredPotreeBinParser = 1;
  Object.defineProperty(PotreeBinParser, "__esModule", {
    value: true
  });
  PotreeBinParser.default = void 0;
  var _three2 = require$$8$1;
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var POINT_ATTTRIBUTES = {
    POSITION_CARTESIAN: {
      numElements: 3,
      ArrayType: Float32Array,
      attributeName: "position"
    },
    COLOR_PACKED: {
      numElements: 4,
      ArrayType: Uint8Array,
      attributeName: "color",
      normalized: true
    },
    INTENSITY: {
      numElements: 1,
      numByte: 2,
      // using Float32Array because Float16Array doesn't exist
      ArrayType: Float32Array,
      attributeName: "intensity",
      normalized: true
    },
    CLASSIFICATION: {
      numElements: 1,
      ArrayType: Uint8Array,
      attributeName: "classification"
    },
    // Note: at the time of writing, PotreeConverter will only generate normals in Oct16 format
    // see PotreeConverter.cpp:121
    // we keep all the historical value to still supports old conversion
    NORMAL_SPHEREMAPPED: {
      numElements: 2,
      ArrayType: Uint8Array,
      attributeName: "sphereMappedNormal"
    },
    // see https://web.archive.org/web/20150303053317/http://lgdv.cs.fau.de/get/1602
    NORMAL_OCT16: {
      numElements: 2,
      ArrayType: Uint8Array,
      attributeName: "oct16Normal"
    },
    NORMAL: {
      numElements: 3,
      ArrayType: Float32Array,
      attributeName: "normal"
    }
  };
  var _loop = function() {
    var potreeName = _Object$keys[_i];
    var attr = POINT_ATTTRIBUTES[potreeName];
    attr.potreeName = potreeName;
    attr.numByte = attr.numByte || attr.ArrayType.BYTES_PER_ELEMENT;
    attr.byteSize = attr.numElements * attr.numByte;
    attr.normalized = attr.normalized || false;
    var fnName = "getUint".concat(attr.numByte * 8);
    attr.getValue = attr.numByte === 1 ? function(view, offset) {
      return view[fnName](offset);
    } : function(view, offset) {
      return view[fnName](offset, true);
    };
  };
  for (var _i = 0, _Object$keys = Object.keys(POINT_ATTTRIBUTES); _i < _Object$keys.length; _i++) {
    _loop();
  }
  var _default2 = {
    /** @module PotreeBinParser */
    /**
     * Parse .bin PotreeConverter format and convert to a BufferGeometry
     *
     * @param {ArrayBuffer} buffer the bin buffer.
     * @param {object} pointAttributes the point attributes information contained in
     * layer.metadata coming from cloud.js
     * @returns {Promise} - a promise that resolves with a BufferGeometry.
     */
    parse: function(buffer2, pointAttributes) {
      if (!buffer2) {
        throw new Error("No array buffer provided.");
      }
      var view = new DataView(buffer2);
      var pointByteSize = 0;
      var _iterator = _createForOfIteratorHelper2(pointAttributes), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var potreeName = _step.value;
          pointByteSize += POINT_ATTTRIBUTES[potreeName].byteSize;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var numPoints = Math.floor(buffer2.byteLength / pointByteSize);
      var geometry = new _three2.BufferGeometry();
      var elemOffset = 0;
      var attrOffset = 0;
      var _iterator2 = _createForOfIteratorHelper2(pointAttributes), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _potreeName = _step2.value;
          var attr = POINT_ATTTRIBUTES[_potreeName];
          var arrayLength = attr.numElements * numPoints;
          var array = new attr.ArrayType(arrayLength);
          for (var arrayOffset = 0; arrayOffset < arrayLength; arrayOffset += attr.numElements) {
            for (var elemIdx = 0; elemIdx < attr.numElements; elemIdx++) {
              array[arrayOffset + elemIdx] = attr.getValue(view, attrOffset + elemIdx * attr.numByte);
            }
            attrOffset += pointByteSize;
          }
          elemOffset += attr.byteSize;
          attrOffset = elemOffset;
          geometry.setAttribute(attr.attributeName, new _three2.BufferAttribute(array, attr.numElements, attr.normalized));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      geometry.computeBoundingBox();
      return Promise.resolve(geometry);
    }
  };
  PotreeBinParser.default = _default2;
  return PotreeBinParser;
}
var PotreeCinParser = {};
var hasRequiredPotreeCinParser;
function requirePotreeCinParser() {
  if (hasRequiredPotreeCinParser)
    return PotreeCinParser;
  hasRequiredPotreeCinParser = 1;
  Object.defineProperty(PotreeCinParser, "__esModule", {
    value: true
  });
  PotreeCinParser.default = void 0;
  var _three2 = require$$8$1;
  var _default2 = {
    /** @module PotreeCinParser */
    /**
     * Parse .cin PotreeConverter format (see {@link https://github.com/peppsac/PotreeConverter/tree/custom_bin}) and convert to a BufferGeometry
     *
     * @param {ArrayBuffer} buffer the cin buffer.
     * @returns {Promise} a promise that resolves with a BufferGeometry.
     */
    parse: function(buffer2) {
      if (!buffer2) {
        throw new Error("No array buffer provided.");
      }
      var view = new DataView(buffer2, 0, 6 * 4);
      var min = new _three2.Vector3(view.getFloat32(0, true), view.getFloat32(4, true), view.getFloat32(8, true));
      var max = new _three2.Vector3(view.getFloat32(12, true), view.getFloat32(16, true), view.getFloat32(20, true));
      var box = new _three2.Box3(min, max);
      var numPoints = Math.floor((buffer2.byteLength - 24) / 16);
      var positions = new Float32Array(buffer2, 24, 3 * numPoints);
      var colors = new Uint8Array(buffer2, 24 + 3 * 4 * numPoints, 4 * numPoints);
      var geometry = new _three2.BufferGeometry();
      geometry.setAttribute("position", new _three2.BufferAttribute(positions, 3));
      geometry.setAttribute("color", new _three2.BufferAttribute(colors, 4, true));
      geometry.boundingBox = box;
      return Promise.resolve(geometry);
    }
  };
  PotreeCinParser.default = _default2;
  return PotreeCinParser;
}
var hasRequiredPointCloudProvider;
function requirePointCloudProvider() {
  if (hasRequiredPointCloudProvider)
    return PointCloudProvider;
  hasRequiredPointCloudProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  var _typeof2 = _typeofExports;
  Object.defineProperty(PointCloudProvider, "__esModule", {
    value: true
  });
  PointCloudProvider.default = PointCloudProvider._testing = void 0;
  PointCloudProvider.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;
  var _three2 = require$$8$1;
  var _Fetcher = _interopRequireDefault2(requireFetcher());
  var _PointCloudProcessing = _interopRequireDefault2(requirePointCloudProcessing());
  var _PotreeBinParser = _interopRequireDefault2(requirePotreeBinParser());
  var _PotreeCinParser = _interopRequireDefault2(requirePotreeCinParser());
  var _PointsMaterial = _interopRequireWildcard2(requirePointsMaterial());
  var _Picking2 = _interopRequireDefault2(requirePicking());
  var _Extent2 = _interopRequireDefault2(requireExtent());
  var _Points = _interopRequireDefault2(requirePoints());
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache2 = function _getRequireWildcardCache3(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache2(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function createChildAABB(aabb, childIndex) {
    var min = aabb.min;
    var max = aabb.max;
    var dHalfLength = new _three2.Vector3().copy(max).sub(min).multiplyScalar(0.5);
    var xHalfLength = new _three2.Vector3(dHalfLength.x, 0, 0);
    var yHalfLength = new _three2.Vector3(0, dHalfLength.y, 0);
    var zHalfLength = new _three2.Vector3(0, 0, dHalfLength.z);
    var cmin = min;
    var cmax = new _three2.Vector3().add(min).add(dHalfLength);
    if (childIndex === 1) {
      min = new _three2.Vector3().copy(cmin).add(zHalfLength);
      max = new _three2.Vector3().copy(cmax).add(zHalfLength);
    } else if (childIndex === 3) {
      min = new _three2.Vector3().copy(cmin).add(zHalfLength).add(yHalfLength);
      max = new _three2.Vector3().copy(cmax).add(zHalfLength).add(yHalfLength);
    } else if (childIndex === 0) {
      min = cmin;
      max = cmax;
    } else if (childIndex === 2) {
      min = new _three2.Vector3().copy(cmin).add(yHalfLength);
      max = new _three2.Vector3().copy(cmax).add(yHalfLength);
    } else if (childIndex === 5) {
      min = new _three2.Vector3().copy(cmin).add(zHalfLength).add(xHalfLength);
      max = new _three2.Vector3().copy(cmax).add(zHalfLength).add(xHalfLength);
    } else if (childIndex === 7) {
      min = new _three2.Vector3().copy(cmin).add(dHalfLength);
      max = new _three2.Vector3().copy(cmax).add(dHalfLength);
    } else if (childIndex === 4) {
      min = new _three2.Vector3().copy(cmin).add(xHalfLength);
      max = new _three2.Vector3().copy(cmax).add(xHalfLength);
    } else if (childIndex === 6) {
      min = new _three2.Vector3().copy(cmin).add(xHalfLength).add(yHalfLength);
      max = new _three2.Vector3().copy(cmax).add(xHalfLength).add(yHalfLength);
    }
    return new _three2.Box3(min, max);
  }
  function parseOctree(layer, hierarchyStepSize, root) {
    return _Fetcher.default.arrayBuffer("".concat(root.baseurl, "/r").concat(root.name, ".hrc"), layer.networkOptions).then(function(blob) {
      var view = new DataView(blob);
      var stack = [];
      var offset = 0;
      root.childrenBitField = view.getUint8(0);
      offset += 1;
      root.numPoints = view.getUint32(1, true);
      offset += 4;
      root.children = [];
      stack.push(root);
      while (stack.length && offset < blob.byteLength) {
        var snode = stack.shift();
        for (var i = 0; i < 8; i++) {
          if (snode.childrenBitField & 1 << i && offset + 5 <= blob.byteLength) {
            var c = view.getUint8(offset);
            offset += 1;
            var n = view.getUint32(offset, true);
            offset += 4;
            if (n === 0) {
              n = root.numPoints;
            }
            var childname = snode.name + i;
            var bounds = createChildAABB(snode.bbox, i);
            var url = root.baseurl;
            if (childname.length % hierarchyStepSize === 0) {
              var myname = childname.substr(root.name.length);
              url = "".concat(root.baseurl, "/").concat(myname);
            }
            var item = {
              numPoints: n,
              childrenBitField: c,
              children: [],
              name: childname,
              baseurl: url,
              bbox: bounds,
              layer,
              parent: snode
            };
            snode.children.push(item);
            stack.push(item);
          }
        }
      }
      return root;
    });
  }
  function findChildrenByName(node, name) {
    if (node.name === name) {
      return node;
    }
    var charIndex = node.name.length;
    for (var i = 0; i < node.children.length; i++) {
      if (node.children[i].name[charIndex] === name[charIndex]) {
        return findChildrenByName(node.children[i], name);
      }
    }
    throw new Error("Cannot find node with name '".concat(name, "'"));
  }
  function computeBbox(layer) {
    var bbox;
    if (layer.isFromPotreeConverter) {
      var layerBbox = layer.metadata.boundingBox;
      bbox = new _three2.Box3(new _three2.Vector3(layerBbox.lx, layerBbox.ly, layerBbox.lz), new _three2.Vector3(layerBbox.ux, layerBbox.uy, layerBbox.uz));
    } else {
      var idx = 0;
      var _iterator = _createForOfIteratorHelper2(layer.metadata), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var entry = _step.value;
          if (entry.table === layer.table) {
            break;
          }
          idx++;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _layerBbox = layer.metadata[idx].bbox;
      bbox = new _three2.Box3(new _three2.Vector3(_layerBbox.xmin, _layerBbox.ymin, _layerBbox.zmin), new _three2.Vector3(_layerBbox.xmax, _layerBbox.ymax, _layerBbox.zmax));
    }
    return bbox;
  }
  function parseMetadata(metadata, layer) {
    layer.metadata = metadata;
    var customBinFormat = true;
    if (layer.metadata.scale !== void 0) {
      layer.isFromPotreeConverter = true;
      customBinFormat = layer.metadata.pointAttributes === "CIN";
      var normal = Array.isArray(layer.metadata.pointAttributes) && layer.metadata.pointAttributes.find(function(elem) {
        return elem.startsWith("NORMAL");
      });
      if (normal) {
        layer.material.defines[normal] = 1;
      }
    } else {
      layer.metadata.scale = 1;
      layer.metadata.octreeDir = "giro3d/".concat(layer.table, ".points");
      layer.metadata.hierarchyStepSize = 1e6;
      customBinFormat = true;
    }
    layer.parse = customBinFormat ? _PotreeCinParser.default.parse : _PotreeBinParser.default.parse;
    layer.extension = customBinFormat ? "cin" : "bin";
    layer.supportsProgressiveDisplay = customBinFormat;
  }
  function getObjectToUpdateForAttachedLayers(meta) {
    if (!meta.obj) {
      return null;
    }
    var p = meta.parent;
    if (p && p.obj) {
      return {
        element: meta.obj,
        parent: p.obj
      };
    }
    return {
      element: meta.obj
    };
  }
  var _default2 = {
    preprocessDataLayer: function preprocessDataLayer(layer, view) {
      if (!layer.file) {
        layer.file = "cloud.js";
      }
      if (!layer.group) {
        layer.group = new _three2.Group();
        layer.object3d.add(layer.group);
        layer.group.updateMatrixWorld();
      }
      if (!layer.bboxes) {
        layer.bboxes = new _three2.Group();
        layer.object3d.add(layer.bboxes);
        layer.bboxes.updateMatrixWorld();
        layer.bboxes.visible = false;
      }
      layer.networkOptions = layer.networkOptions || {};
      layer.octreeDepthLimit = layer.octreeDepthLimit || -1;
      layer.pointBudget = layer.pointBudget || 2e6;
      layer.pointSize = layer.pointSize === 0 || !Number.isNaN(layer.pointSize) ? layer.pointSize : 4;
      layer.sseThreshold = layer.sseThreshold || 2;
      layer.material = layer.material || {};
      layer.material = layer.material.isMaterial ? layer.material : new _PointsMaterial.default(layer.material);
      layer.material.defines = layer.material.defines || {};
      layer.mode = _PointsMaterial.MODE.COLOR;
      layer.preUpdate = _PointCloudProcessing.default.preUpdate;
      layer.update = _PointCloudProcessing.default.update;
      layer.postUpdate = _PointCloudProcessing.default.postUpdate;
      layer.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;
      layer.pickObjectsAt = function(view2, mouse, radius, filter) {
        return _Picking2.default.pickPointsAt(view2, mouse, radius, layer, filter);
      };
      return _Fetcher.default.json("".concat(layer.url, "/").concat(layer.file), layer.networkOptions).then(function(metadata) {
        parseMetadata(metadata, layer);
        var bbox = computeBbox(layer);
        return parseOctree(layer, layer.metadata.hierarchyStepSize, {
          baseurl: "".concat(layer.url, "/").concat(layer.metadata.octreeDir, "/r"),
          name: "",
          bbox
        });
      }).then(function(root) {
        console.log("LAYER metadata:", root);
        layer.root = root;
        root.findChildrenByName = findChildrenByName.bind(root, root);
        layer.extent = _Extent2.default.fromBox3(view.referenceCrs, root.bbox);
        return layer;
      });
    },
    executeCommand: function executeCommand(command) {
      var layer = command.layer;
      var metadata = command.requester;
      if (metadata.childrenBitField && metadata.children.length === 0) {
        parseOctree(layer, layer.metadata.hierarchyStepSize, metadata).then(function() {
          return command.view.notifyChange(layer, false);
        });
      }
      var url = "".concat(metadata.baseurl, "/r").concat(metadata.name, ".").concat(layer.extension, "?isleaf=").concat(command.isLeaf ? 1 : 0);
      return _Fetcher.default.arrayBuffer(url, layer.networkOptions).then(function(buffer2) {
        return layer.parse(buffer2, layer.metadata.pointAttributes);
      }).then(function(geometry) {
        var points = new _Points.default(layer, geometry, layer.material.clone());
        if (points.material.enablePicking) {
          _Picking2.default.preparePointGeometryForPicking(points.geometry);
        }
        points.frustumCulled = false;
        points.matrixAutoUpdate = false;
        points.position.copy(metadata.bbox.min);
        points.scale.set(layer.metadata.scale, layer.metadata.scale, layer.metadata.scale);
        points.updateMatrix();
        points.tightbbox = geometry.boundingBox.applyMatrix4(points.matrix);
        points.layers.set(layer.threejsLayer);
        points.layer = layer;
        points.extent = _Extent2.default.fromBox3(command.view.referenceCrs, metadata.bbox);
        points.userData.metadata = metadata;
        return points;
      });
    }
  };
  PointCloudProvider.default = _default2;
  var _testing = {
    parseMetadata
  };
  PointCloudProvider._testing = _testing;
  return PointCloudProvider;
}
var CustomTiledImageProvider = {};
class FlatQueue {
  constructor() {
    this.ids = [];
    this.values = [];
    this.length = 0;
  }
  clear() {
    this.length = 0;
  }
  push(id, value) {
    let pos = this.length++;
    this.ids[pos] = id;
    this.values[pos] = value;
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const parentValue = this.values[parent];
      if (value >= parentValue)
        break;
      this.ids[pos] = this.ids[parent];
      this.values[pos] = parentValue;
      pos = parent;
    }
    this.ids[pos] = id;
    this.values[pos] = value;
  }
  pop() {
    if (this.length === 0)
      return void 0;
    const top = this.ids[0];
    this.length--;
    if (this.length > 0) {
      const id = this.ids[0] = this.ids[this.length];
      const value = this.values[0] = this.values[this.length];
      const halfLength = this.length >> 1;
      let pos = 0;
      while (pos < halfLength) {
        let left = (pos << 1) + 1;
        const right = left + 1;
        let bestIndex = this.ids[left];
        let bestValue = this.values[left];
        const rightValue = this.values[right];
        if (right < this.length && rightValue < bestValue) {
          left = right;
          bestIndex = this.ids[right];
          bestValue = rightValue;
        }
        if (bestValue >= value)
          break;
        this.ids[pos] = bestIndex;
        this.values[pos] = bestValue;
        pos = left;
      }
      this.ids[pos] = id;
      this.values[pos] = value;
    }
    return top;
  }
  peek() {
    if (this.length === 0)
      return void 0;
    return this.ids[0];
  }
  peekValue() {
    if (this.length === 0)
      return void 0;
    return this.values[0];
  }
}
const ARRAY_TYPES = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
const VERSION = 3;
class Flatbush {
  static from(data) {
    if (!(data instanceof ArrayBuffer)) {
      throw new Error("Data must be an instance of ArrayBuffer.");
    }
    const [magic, versionAndType] = new Uint8Array(data, 0, 2);
    if (magic !== 251) {
      throw new Error("Data does not appear to be in a Flatbush format.");
    }
    if (versionAndType >> 4 !== VERSION) {
      throw new Error(`Got v${versionAndType >> 4} data when expected v${VERSION}.`);
    }
    const [nodeSize] = new Uint16Array(data, 2, 1);
    const [numItems] = new Uint32Array(data, 4, 1);
    return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 15], data);
  }
  constructor(numItems, nodeSize = 16, ArrayType = Float64Array, data) {
    if (numItems === void 0)
      throw new Error("Missing required argument: numItems.");
    if (isNaN(numItems) || numItems <= 0)
      throw new Error(`Unpexpected numItems value: ${numItems}.`);
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    let n = numItems;
    let numNodes = n;
    this._levelBounds = [n * 4];
    do {
      n = Math.ceil(n / this.nodeSize);
      numNodes += n;
      this._levelBounds.push(numNodes * 4);
    } while (n !== 1);
    this.ArrayType = ArrayType || Float64Array;
    this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;
    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;
    if (arrayTypeIndex < 0) {
      throw new Error(`Unexpected typed array class: ${ArrayType}.`);
    }
    if (data && data instanceof ArrayBuffer) {
      this.data = data;
      this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
      this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
      this._pos = numNodes * 4;
      this.minX = this._boxes[this._pos - 4];
      this.minY = this._boxes[this._pos - 3];
      this.maxX = this._boxes[this._pos - 2];
      this.maxY = this._boxes[this._pos - 1];
    } else {
      this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
      this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
      this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
      this._pos = 0;
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      new Uint8Array(this.data, 0, 2).set([251, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
    this._queue = new FlatQueue();
  }
  add(minX, minY, maxX, maxY) {
    const index = this._pos >> 2;
    this._indices[index] = index;
    this._boxes[this._pos++] = minX;
    this._boxes[this._pos++] = minY;
    this._boxes[this._pos++] = maxX;
    this._boxes[this._pos++] = maxY;
    if (minX < this.minX)
      this.minX = minX;
    if (minY < this.minY)
      this.minY = minY;
    if (maxX > this.maxX)
      this.maxX = maxX;
    if (maxY > this.maxY)
      this.maxY = maxY;
    return index;
  }
  finish() {
    if (this._pos >> 2 !== this.numItems) {
      throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);
    }
    if (this.numItems <= this.nodeSize) {
      this._boxes[this._pos++] = this.minX;
      this._boxes[this._pos++] = this.minY;
      this._boxes[this._pos++] = this.maxX;
      this._boxes[this._pos++] = this.maxY;
      return;
    }
    const width = this.maxX - this.minX || 1;
    const height = this.maxY - this.minY || 1;
    const hilbertValues = new Uint32Array(this.numItems);
    const hilbertMax = (1 << 16) - 1;
    for (let i = 0; i < this.numItems; i++) {
      let pos = 4 * i;
      const minX = this._boxes[pos++];
      const minY = this._boxes[pos++];
      const maxX = this._boxes[pos++];
      const maxY = this._boxes[pos++];
      const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);
      const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);
      hilbertValues[i] = hilbert(x, y);
    }
    sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1, this.nodeSize);
    for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {
      const end = this._levelBounds[i];
      while (pos < end) {
        const nodeIndex = pos;
        let nodeMinX = Infinity;
        let nodeMinY = Infinity;
        let nodeMaxX = -Infinity;
        let nodeMaxY = -Infinity;
        for (let i2 = 0; i2 < this.nodeSize && pos < end; i2++) {
          nodeMinX = Math.min(nodeMinX, this._boxes[pos++]);
          nodeMinY = Math.min(nodeMinY, this._boxes[pos++]);
          nodeMaxX = Math.max(nodeMaxX, this._boxes[pos++]);
          nodeMaxY = Math.max(nodeMaxY, this._boxes[pos++]);
        }
        this._indices[this._pos >> 2] = nodeIndex;
        this._boxes[this._pos++] = nodeMinX;
        this._boxes[this._pos++] = nodeMinY;
        this._boxes[this._pos++] = nodeMaxX;
        this._boxes[this._pos++] = nodeMaxY;
      }
    }
  }
  search(minX, minY, maxX, maxY, filterFn) {
    if (this._pos !== this._boxes.length) {
      throw new Error("Data not yet indexed - call index.finish().");
    }
    let nodeIndex = this._boxes.length - 4;
    const queue = [];
    const results = [];
    while (nodeIndex !== void 0) {
      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
      for (let pos = nodeIndex; pos < end; pos += 4) {
        const index = this._indices[pos >> 2] | 0;
        if (maxX < this._boxes[pos])
          continue;
        if (maxY < this._boxes[pos + 1])
          continue;
        if (minX > this._boxes[pos + 2])
          continue;
        if (minY > this._boxes[pos + 3])
          continue;
        if (nodeIndex < this.numItems * 4) {
          if (filterFn === void 0 || filterFn(index)) {
            results.push(index);
          }
        } else {
          queue.push(index);
        }
      }
      nodeIndex = queue.pop();
    }
    return results;
  }
  neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {
    if (this._pos !== this._boxes.length) {
      throw new Error("Data not yet indexed - call index.finish().");
    }
    let nodeIndex = this._boxes.length - 4;
    const q = this._queue;
    const results = [];
    const maxDistSquared = maxDistance * maxDistance;
    while (nodeIndex !== void 0) {
      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
      for (let pos = nodeIndex; pos < end; pos += 4) {
        const index = this._indices[pos >> 2] | 0;
        const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);
        const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);
        const dist = dx * dx + dy * dy;
        if (nodeIndex < this.numItems * 4) {
          if (filterFn === void 0 || filterFn(index)) {
            q.push((index << 1) + 1, dist);
          }
        } else {
          q.push(index << 1, dist);
        }
      }
      while (q.length && q.peek() & 1) {
        const dist = q.peekValue();
        if (dist > maxDistSquared) {
          q.clear();
          return results;
        }
        results.push(q.pop() >> 1);
        if (results.length === maxResults) {
          q.clear();
          return results;
        }
      }
      nodeIndex = q.pop() >> 1;
    }
    q.clear();
    return results;
  }
}
function axisDist(k, min, max) {
  return k < min ? min - k : k <= max ? 0 : k - max;
}
function upperBound(value, arr) {
  let i = 0;
  let j = arr.length - 1;
  while (i < j) {
    const m = i + j >> 1;
    if (arr[m] > value) {
      j = m;
    } else {
      i = m + 1;
    }
  }
  return arr[i];
}
function sort(values, boxes, indices, left, right, nodeSize) {
  if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize))
    return;
  const pivot = values[left + right >> 1];
  let i = left - 1;
  let j = right + 1;
  while (true) {
    do
      i++;
    while (values[i] < pivot);
    do
      j--;
    while (values[j] > pivot);
    if (i >= j)
      break;
    swap(values, boxes, indices, i, j);
  }
  sort(values, boxes, indices, left, j, nodeSize);
  sort(values, boxes, indices, j + 1, right, nodeSize);
}
function swap(values, boxes, indices, i, j) {
  const temp = values[i];
  values[i] = values[j];
  values[j] = temp;
  const k = 4 * i;
  const m = 4 * j;
  const a = boxes[k];
  const b = boxes[k + 1];
  const c = boxes[k + 2];
  const d = boxes[k + 3];
  boxes[k] = boxes[m];
  boxes[k + 1] = boxes[m + 1];
  boxes[k + 2] = boxes[m + 2];
  boxes[k + 3] = boxes[m + 3];
  boxes[m] = a;
  boxes[m + 1] = b;
  boxes[m + 2] = c;
  boxes[m + 3] = d;
  const e = indices[i];
  indices[i] = indices[j];
  indices[j] = e;
}
function hilbert(x, y) {
  let a = x ^ y;
  let b = 65535 ^ a;
  let c = 65535 ^ (x | y);
  let d = x & (y ^ 65535);
  let A2 = a | b >> 1;
  let B = a >> 1 ^ a;
  let C = c >> 1 ^ b & d >> 1 ^ c;
  let D = a & c >> 1 ^ d >> 1 ^ d;
  a = A2;
  b = B;
  c = C;
  d = D;
  A2 = a & a >> 2 ^ b & b >> 2;
  B = a & b >> 2 ^ b & (a ^ b) >> 2;
  C ^= a & c >> 2 ^ b & d >> 2;
  D ^= b & c >> 2 ^ (a ^ b) & d >> 2;
  a = A2;
  b = B;
  c = C;
  d = D;
  A2 = a & a >> 4 ^ b & b >> 4;
  B = a & b >> 4 ^ b & (a ^ b) >> 4;
  C ^= a & c >> 4 ^ b & d >> 4;
  D ^= b & c >> 4 ^ (a ^ b) & d >> 4;
  a = A2;
  b = B;
  c = C;
  d = D;
  C ^= a & c >> 8 ^ b & d >> 8;
  D ^= b & c >> 8 ^ (a ^ b) & d >> 8;
  a = C ^ C >> 1;
  b = D ^ D >> 1;
  let i0 = x ^ y;
  let i1 = b | 65535 ^ (i0 | a);
  i0 = (i0 | i0 << 8) & 16711935;
  i0 = (i0 | i0 << 4) & 252645135;
  i0 = (i0 | i0 << 2) & 858993459;
  i0 = (i0 | i0 << 1) & 1431655765;
  i1 = (i1 | i1 << 8) & 16711935;
  i1 = (i1 | i1 << 4) & 252645135;
  i1 = (i1 | i1 << 2) & 858993459;
  i1 = (i1 | i1 << 1) & 1431655765;
  return (i1 << 1 | i0) >>> 0;
}
const flatbush = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Flatbush
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$2 = /* @__PURE__ */ getAugmentedNamespace(flatbush);
var hasRequiredCustomTiledImageProvider;
function requireCustomTiledImageProvider() {
  if (hasRequiredCustomTiledImageProvider)
    return CustomTiledImageProvider;
  hasRequiredCustomTiledImageProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(CustomTiledImageProvider, "__esModule", {
    value: true
  });
  CustomTiledImageProvider.default = void 0;
  var _construct2 = _interopRequireDefault2(requireConstruct());
  var _toConsumableArray22 = _interopRequireDefault2(requireToConsumableArray());
  var _flatbush = _interopRequireDefault2(require$$3$2);
  var _three2 = require$$8$1;
  var _Extent2 = _interopRequireDefault2(requireExtent());
  var _OGCWebServiceHelper = _interopRequireDefault2(requireOGCWebServiceHelper());
  var _DEMUtils = requireDEMUtils();
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _selectImagesFromSpatialIndex(index, images, extent2) {
    return index.search(extent2.west(), extent2.south(), extent2.east(), extent2.north()).map(function(i) {
      return images[i];
    });
  }
  var inter = new _Extent2.default("dummy", 0, 0, 0, 0);
  function selectBestImageForExtent(layer, extent2) {
    var candidates = _selectImagesFromSpatialIndex(layer._spatialIndex, layer.images, extent2);
    var selection;
    var _iterator = _createForOfIteratorHelper2(candidates), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var entry = _step.value;
        if (extent2.isInside(entry.extent)) {
          if (!selection) {
            selection = entry;
          } else {
            var d = selection.extent.dimensions();
            var e = entry.extent.dimensions();
            if (e.x <= d.x && e.y <= d.y) {
              selection = entry;
            }
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (selection) {
      return selection;
    }
    if (candidates.length === 0) {
      return null;
    }
    var coverage = 0;
    var _iterator2 = _createForOfIteratorHelper2(candidates), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var _entry = _step2.value;
        inter.copy(_entry.extent);
        inter = inter.intersect(extent2);
        var dim = inter.dimensions();
        var cov = Math.floor(dim.x * dim.y);
        if (cov >= coverage) {
          if (!selection) {
            selection = _entry;
            coverage = cov;
          } else if (cov === coverage) {
            var d1 = _entry.extent.dimensions();
            var d2 = selection.extent.dimensions();
            if (d1.x < d2.x && d1.y < d2.y) {
              selection = _entry;
              coverage = cov;
            }
          } else {
            selection = _entry;
            coverage = cov;
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    layer.discardOutsideUV = true;
    return selection;
  }
  function getTexture(toDownload, layer) {
    var textureP;
    if (layer.elevationFormat === _DEMUtils.ELEVATION_FORMAT.XBIL) {
      textureP = _OGCWebServiceHelper.default.getXBilTextureByUrl(toDownload.url, layer.source.networkOptions);
    } else {
      textureP = _OGCWebServiceHelper.default.getColorTextureByUrl(toDownload.url, layer.source.networkOptions);
    }
    return textureP.then(function(texture) {
      var result = {
        texture,
        pitch: toDownload.pitch || new _three2.Vector4(0, 0, 1, 1)
      };
      result.texture.extent = toDownload.selection.extent;
      result.texture.file = toDownload.selection.image;
      if (layer.transparent) {
        texture.premultiplyAlpha = true;
      }
      return result;
    });
  }
  var _default2 = {
    preprocessDataLayer: function preprocessDataLayer(layer) {
      if (layer.extent) {
        console.warn("Ignoring given layer.extent, and rebuilding it from sources images instead");
      }
      layer.canTileTextureBeImproved = this.canTileTextureBeImproved;
      return layer.source.fetchMetadata().then(function(metadata) {
        layer.images = [];
        for (var _i = 0, _Object$keys = Object.keys(metadata); _i < _Object$keys.length; _i++) {
          var image = _Object$keys[_i];
          var extent2 = (0, _construct2.default)(_Extent2.default, [layer.projection].concat((0, _toConsumableArray22.default)(metadata[image])));
          layer.images.push({
            image,
            extent: extent2
          });
          if (!layer.extent) {
            layer.extent = extent2.clone();
          } else {
            layer.extent.union(extent2);
          }
        }
        layer._spatialIndex = new _flatbush.default(layer.images.length);
        var _iterator3 = _createForOfIteratorHelper2(layer.images), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _image = _step3.value;
            layer._spatialIndex.add(_image.extent.west(), _image.extent.south(), _image.extent.east(), _image.extent.north());
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        layer._spatialIndex.finish();
        var s = selectBestImageForExtent(layer, layer.extent);
        return getTexture({
          url: layer.source.buildUrl(s.image),
          selection: s
        }, layer).then(function(result) {
          layer.imageSize = {
            w: result.texture.image.width,
            h: result.texture.image.height
          };
        });
      });
    },
    tileInsideLimit: function tileInsideLimit(tile, layer) {
      if (!layer.images) {
        return false;
      }
      return selectBestImageForExtent(layer, tile.extent);
    },
    getPossibleTextureImprovements: function getPossibleTextureImprovements(layer, extent2, currentTexture) {
      if (!layer.images) {
        return null;
      }
      var s = selectBestImageForExtent(layer, extent2);
      if (!s) {
        return null;
      }
      if (currentTexture && currentTexture.file === s.image) {
        return null;
      }
      return {
        selection: s,
        pitch: extent2.offsetToParent(s.extent),
        url: layer.source.buildUrl(s.image)
      };
    },
    executeCommand: function executeCommand(command) {
      var layer = command.layer;
      return getTexture(command.toDownload, layer);
    }
  };
  CustomTiledImageProvider.default = _default2;
  return CustomTiledImageProvider;
}
var OLTileProvider = {};
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(events);
var hasRequiredOLTileProvider;
function requireOLTileProvider() {
  if (hasRequiredOLTileProvider)
    return OLTileProvider;
  hasRequiredOLTileProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(OLTileProvider, "__esModule", {
    value: true
  });
  OLTileProvider.default = void 0;
  var _three2 = require$$8$1;
  var _TileState = _interopRequireDefault2(require$$2$1);
  var _events = require$$3$1;
  var _Extent2 = _interopRequireDefault2(requireExtent());
  function preprocessDataLayer(layer) {
    var source = layer.source;
    var projection = source.getProjection();
    var tileGrid = source.getTileGridForProjection(projection);
    var sizePixel = source.getTilePixelSize(
      0,
      1,
      projection
    );
    layer.imageSize = {
      w: sizePixel[0],
      h: sizePixel[1]
    };
    var extent2 = tileGrid.getExtent();
    layer.extent = fromOLExtent(extent2, projection.getCode());
    layer.fx = 0;
  }
  function fromOLExtent(extent2, projectionCode) {
    return new _Extent2.default(projectionCode, extent2[0], extent2[2], extent2[1], extent2[3]);
  }
  function toOLExtent(extent2) {
    return [Math.ceil(extent2.west()), Math.ceil(extent2.south()), Math.floor(extent2.east()), Math.floor(extent2.north())];
  }
  function getPossibleTextureImprovements(layer, extent2, texture) {
    var ex = extent2.as(layer.extent.crs());
    var tile = selectTile(layer, ex);
    if (texture && texture.extent && texture.extent.isInside(tile.tileExtent)) {
      return null;
    }
    return tile;
  }
  function selectTile(layer, extent2) {
    var source = layer.source;
    var projection = source.getProjection();
    var tileGrid = source.getTileGridForProjection(projection);
    var tileCoord = tileCoordForExtent(tileGrid, extent2);
    if (!tileCoord) {
      return null;
    }
    var tile = source.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, projection);
    var tileExtent = fromOLExtent(tileGrid.getTileCoordExtent(tileCoord), projection.getCode());
    var pitch = extent2.offsetToParent(tileExtent);
    return {
      extent: extent2,
      pitch,
      tile,
      tileExtent
    };
  }
  function tileCoordForExtent(tileGrid, extent2) {
    extent2 = toOLExtent(extent2);
    var minZoom = tileGrid.getMinZoom();
    var maxZoom = tileGrid.getMaxZoom();
    for (var z = maxZoom, tileRange; z >= minZoom; z--) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z, tileRange);
      if (tileRange.getWidth() === 1 && tileRange.getHeight() === 1) {
        return [z, tileRange.minX, tileRange.minY];
      }
    }
    return null;
  }
  function executeCommand(command) {
    return loadTile(command.toDownload, command.layer);
  }
  function loadTile(tile, layer) {
    var promise;
    var imageTile = tile.tile;
    if (imageTile.getState() === _TileState.default.LOADED) {
      promise = Promise.resolve(createTexture(tile, layer));
    } else {
      promise = new Promise(function(resolve, reject) {
        imageTile.load();
        (0, _events.listenOnce)(imageTile, "change", function(evt) {
          var imageTile2 = evt.target;
          var tileState = imageTile2.getState();
          if (tileState === _TileState.default.ERROR) {
            reject();
          } else if (tileState === _TileState.default.LOADED) {
            resolve(createTexture(tile, layer));
          }
        });
      });
    }
    return promise;
  }
  function createTexture(tile, layer) {
    var texture = new _three2.Texture(tile.tile.getImage());
    texture.needsUpdate = true;
    texture.premultiplyAlpha = layer.transparent;
    texture.extent = tile.tileExtent;
    return {
      texture,
      pitch: tile.pitch
    };
  }
  function tileTextureCount() {
    return 1;
  }
  function tileInsideLimit(tile, layer) {
    var extent2 = tile.getExtentForLayer(layer);
    return extent2.isInside(layer.extent);
  }
  var _default2 = {
    preprocessDataLayer,
    executeCommand,
    tileTextureCount,
    tileInsideLimit,
    getPossibleTextureImprovements
  };
  OLTileProvider.default = _default2;
  return OLTileProvider;
}
var OLVectorTileProvider = {};
const require$$4$1 = /* @__PURE__ */ getAugmentedNamespace(extent);
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
var fillInstruction = [Instruction.FILL];
var strokeInstruction = [Instruction.STROKE];
var beginPathInstruction = [Instruction.BEGIN_PATH];
var closePathInstruction = [Instruction.CLOSE_PATH];
const CanvasInstruction = Instruction;
var VectorContext = (
  /** @class */
  function() {
    function VectorContext2() {
    }
    VectorContext2.prototype.drawCustom = function(geometry, feature, renderer, hitDetectionRenderer) {
    };
    VectorContext2.prototype.drawGeometry = function(geometry) {
    };
    VectorContext2.prototype.setStyle = function(style2) {
    };
    VectorContext2.prototype.drawCircle = function(circleGeometry, feature) {
    };
    VectorContext2.prototype.drawFeature = function(feature, style2) {
    };
    VectorContext2.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {
    };
    VectorContext2.prototype.drawLineString = function(lineStringGeometry, feature) {
    };
    VectorContext2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
    };
    VectorContext2.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
    };
    VectorContext2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
    };
    VectorContext2.prototype.drawPoint = function(pointGeometry2, feature) {
    };
    VectorContext2.prototype.drawPolygon = function(polygonGeometry, feature) {
    };
    VectorContext2.prototype.drawText = function(geometry, feature) {
    };
    VectorContext2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
    };
    VectorContext2.prototype.setImageStyle = function(imageStyle, opt_declutterImageWithText) {
    };
    VectorContext2.prototype.setTextStyle = function(textStyle, opt_declutterImageWithText) {
    };
    return VectorContext2;
  }()
);
const VectorContext$1 = VectorContext;
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString(color) {
  if (typeof color === "string") {
    return color;
  } else {
    return toString$1(color);
  }
}
function fromNamed(color) {
  var el = document.createElement("div");
  el.style.color = color;
  if (el.style.color !== "") {
    document.body.appendChild(el);
    var rgb2 = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb2;
  } else {
    return "";
  }
}
var fromString = function() {
  var MAX_CACHE_SIZE = 1024;
  var cache2 = {};
  var cacheSize = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function(s) {
      var color;
      if (cache2.hasOwnProperty(s)) {
        color = cache2[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;
          for (var key in cache2) {
            if ((i++ & 3) === 0) {
              delete cache2[key];
              --cacheSize;
            }
          }
        }
        color = fromStringInternal_(s);
        cache2[s] = color;
        ++cacheSize;
      }
      return color;
    }
  );
}();
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}
function fromStringInternal_(s) {
  var r, g, b, a, color;
  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }
  if (HEX_COLOR_RE_.exec(s)) {
    var n = s.length - 1;
    var d = (
      // number of digits per channel
      void 0
    );
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.indexOf("rgba(") == 0) {
    color = s.slice(5, -1).split(",").map(Number);
    normalize(color);
  } else if (s.indexOf("rgb(") == 0) {
    color = s.slice(4, -1).split(",").map(Number);
    color.push(1);
    normalize(color);
  } else {
    assert(false, 14);
  }
  return color;
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString$1(color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  var a = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}
function asColorLike(color) {
  if (Array.isArray(color)) {
    return toString$1(color);
  } else {
    return color;
  }
}
var fontRegEx = new RegExp([
  "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
  "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
  "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
  "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
  "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
  "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
  `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
].join(""), "i");
var fontRegExMatchIndex = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
];
var getFontParameters = function(fontSpec) {
  var match2 = fontSpec.match(fontRegEx);
  if (!match2) {
    return null;
  }
  var style2 = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    var value = match2[i + 1];
    if (value !== void 0) {
      style2[fontRegExMatchIndex[i]] = value;
    }
  }
  style2.families = style2.family.split(/,\s?/);
  return style2;
};
var defaultFont = "10px sans-serif";
var defaultFillStyle = "#000";
var defaultLineCap = "round";
var defaultLineDash = [];
var defaultLineDashOffset = 0;
var defaultLineJoin = "round";
var defaultMiterLimit = 10;
var defaultStrokeStyle = "#000";
var defaultTextAlign = "center";
var defaultTextBaseline = "middle";
var defaultPadding = [0, 0, 0, 0];
var defaultLineWidth = 1;
var checkedFonts = new BaseObject$1();
var labelCache = new EventTarget();
labelCache.setSize = function() {
  console.warn("labelCache is deprecated.");
};
var measureContext = null;
var measureFont;
var textHeights = {};
var registerFont = function() {
  var retries = 100;
  var size = "32px ";
  var referenceFonts = ["monospace", "serif"];
  var len = referenceFonts.length;
  var text = "wmytzilWMYTZIL@#/&?$%10";
  var interval, referenceWidth;
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    var available = true;
    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(fontStyle + " " + fontWeight + " " + size + referenceFont, text);
      if (fontFamily != referenceFont) {
        var width = measureTextWidth(fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont, text);
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check() {
    var done = true;
    var fonts = checkedFonts.getKeys();
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split("\n"))) {
          clear(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    var font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    var families = font.families;
    for (var i = 0, ii = families.length; i < ii; ++i) {
      var family = families[i];
      var key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
var measureTextHeight = function() {
  var measureElement;
  return function(fontSpec) {
    var height = textHeights[fontSpec];
    if (height == void 0) {
      if (WORKER_OFFSCREEN_CANVAS) {
        var font = getFontParameters(fontSpec);
        var metrics = measureText(fontSpec, "g");
        var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement("div");
          measureElement.innerHTML = "M";
          measureElement.style.minHeight = "0";
          measureElement.style.maxHeight = "none";
          measureElement.style.height = "auto";
          measureElement.style.padding = "0";
          measureElement.style.border = "none";
          measureElement.style.position = "absolute";
          measureElement.style.display = "block";
          measureElement.style.left = "-99999px";
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache2) {
  if (text in cache2) {
    return cache2[text];
  }
  var width = text.split("\n").reduce(function(prev, curr) {
    return Math.max(prev, measureTextWidth(font, curr));
  }, 0);
  cache2[text] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  var widths = [];
  var heights = [];
  var lineWidths = [];
  var width = 0;
  var lineWidth = 0;
  var height = 0;
  var lineHeight = 0;
  for (var i = 0, ii = chunks.length; i <= ii; i += 2) {
    var text = chunks[i];
    if (text === "\n" || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }
    var font = chunks[i + 1] || baseStyle.font;
    var currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    var currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale2) {
  context.save();
  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }
  if (transform2) {
    context.setTransform.apply(context, transform2);
  }
  if (
    /** @type {*} */
    labelOrImage.contextInstructions
  ) {
    context.translate(x, y);
    context.scale(scale2[0], scale2[1]);
    executeLabelInstructions(
      /** @type {Label} */
      labelOrImage,
      context
    );
  } else if (scale2[0] < 0 || scale2[1] < 0) {
    context.translate(x, y);
    context.scale(scale2[0], scale2[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale2[0],
      h * scale2[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;
  for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== void 0 ? opt_coordinates : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== void 0 ? opt_coordinatess : [];
  var i = 0;
  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== void 0 ? opt_coordinatesss : [];
  var i = 0;
  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}
var __extends$8 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasBuilder = (
  /** @class */
  function(_super) {
    __extends$8(CanvasBuilder2, _super);
    function CanvasBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
      var _this = _super.call(this) || this;
      _this.tolerance = tolerance;
      _this.maxExtent = maxExtent;
      _this.pixelRatio = pixelRatio;
      _this.maxLineWidth = 0;
      _this.resolution = resolution;
      _this.beginGeometryInstruction1_ = null;
      _this.beginGeometryInstruction2_ = null;
      _this.bufferedMaxExtent_ = null;
      _this.instructions = [];
      _this.coordinates = [];
      _this.tmpCoordinate_ = [];
      _this.hitDetectionInstructions = [];
      _this.state = /** @type {import("../canvas.js").FillStrokeState} */
      {};
      return _this;
    }
    CanvasBuilder2.prototype.applyPixelRatio = function(dashArray) {
      var pixelRatio = this.pixelRatio;
      return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
        return dash * pixelRatio;
      });
    };
    CanvasBuilder2.prototype.appendFlatPointCoordinates = function(flatCoordinates, stride) {
      var extent2 = this.getBufferedMaxExtent();
      var tmpCoord = this.tmpCoordinate_;
      var coordinates = this.coordinates;
      var myEnd = coordinates.length;
      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        tmpCoord[0] = flatCoordinates[i];
        tmpCoord[1] = flatCoordinates[i + 1];
        if (containsCoordinate(extent2, tmpCoord)) {
          coordinates[myEnd++] = tmpCoord[0];
          coordinates[myEnd++] = tmpCoord[1];
        }
      }
      return myEnd;
    };
    CanvasBuilder2.prototype.appendFlatLineCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {
      var coordinates = this.coordinates;
      var myEnd = coordinates.length;
      var extent2 = this.getBufferedMaxExtent();
      if (skipFirst) {
        offset += stride;
      }
      var lastXCoord = flatCoordinates[offset];
      var lastYCoord = flatCoordinates[offset + 1];
      var nextCoord = this.tmpCoordinate_;
      var skipped = true;
      var i, lastRel, nextRel;
      for (i = offset + stride; i < end; i += stride) {
        nextCoord[0] = flatCoordinates[i];
        nextCoord[1] = flatCoordinates[i + 1];
        nextRel = coordinateRelationship(extent2, nextCoord);
        if (nextRel !== lastRel) {
          if (skipped) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
            skipped = false;
          }
          coordinates[myEnd++] = nextCoord[0];
          coordinates[myEnd++] = nextCoord[1];
        } else if (nextRel === Relationship.INTERSECTING) {
          coordinates[myEnd++] = nextCoord[0];
          coordinates[myEnd++] = nextCoord[1];
          skipped = false;
        } else {
          skipped = true;
        }
        lastXCoord = nextCoord[0];
        lastYCoord = nextCoord[1];
        lastRel = nextRel;
      }
      if (closed && skipped || i === offset + stride) {
        coordinates[myEnd++] = lastXCoord;
        coordinates[myEnd++] = lastYCoord;
      }
      return myEnd;
    };
    CanvasBuilder2.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, builderEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        builderEnds.push(builderEnd);
        offset = end;
      }
      return offset;
    };
    CanvasBuilder2.prototype.drawCustom = function(geometry, feature, renderer, hitDetectionRenderer) {
      this.beginGeometry(geometry, feature);
      var type = geometry.getType();
      var stride = geometry.getStride();
      var builderBegin = this.coordinates.length;
      var flatCoordinates, builderEnd, builderEnds, builderEndss;
      var offset;
      switch (type) {
        case "MultiPolygon":
          flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getOrientedFlatCoordinates();
          builderEndss = [];
          var endss = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getEndss()
          );
          offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var myEnds = [];
            offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
            builderEndss.push(myEnds);
          }
          this.instructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEndss,
            geometry,
            renderer,
            inflateMultiCoordinatesArray
          ]);
          this.hitDetectionInstructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEndss,
            geometry,
            hitDetectionRenderer || renderer,
            inflateMultiCoordinatesArray
          ]);
          break;
        case "Polygon":
        case "MultiLineString":
          builderEnds = [];
          flatCoordinates = type == "Polygon" ? (
            /** @type {import("../../geom/Polygon.js").default} */
            geometry.getOrientedFlatCoordinates()
          ) : geometry.getFlatCoordinates();
          offset = this.drawCustomCoordinates_(
            flatCoordinates,
            0,
            /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
            geometry.getEnds(),
            stride,
            builderEnds
          );
          this.instructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnds,
            geometry,
            renderer,
            inflateCoordinatesArray
          ]);
          this.hitDetectionInstructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnds,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinatesArray
          ]);
          break;
        case "LineString":
        case "Circle":
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
          this.instructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            inflateCoordinates
          ]);
          this.hitDetectionInstructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinates
          ]);
          break;
        case "MultiPoint":
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (builderEnd > builderBegin) {
            this.instructions.push([
              CanvasInstruction.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              inflateCoordinates
            ]);
            this.hitDetectionInstructions.push([
              CanvasInstruction.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinates
            ]);
          }
          break;
        case "Point":
          flatCoordinates = geometry.getFlatCoordinates();
          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
          builderEnd = this.coordinates.length;
          this.instructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer
          ]);
          this.hitDetectionInstructions.push([
            CanvasInstruction.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer
          ]);
          break;
      }
      this.endGeometry(feature);
    };
    CanvasBuilder2.prototype.beginGeometry = function(geometry, feature) {
      this.beginGeometryInstruction1_ = [
        CanvasInstruction.BEGIN_GEOMETRY,
        feature,
        0,
        geometry
      ];
      this.instructions.push(this.beginGeometryInstruction1_);
      this.beginGeometryInstruction2_ = [
        CanvasInstruction.BEGIN_GEOMETRY,
        feature,
        0,
        geometry
      ];
      this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    };
    CanvasBuilder2.prototype.finish = function() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates
      };
    };
    CanvasBuilder2.prototype.reverseHitDetectionInstructions = function() {
      var hitDetectionInstructions = this.hitDetectionInstructions;
      hitDetectionInstructions.reverse();
      var i;
      var n = hitDetectionInstructions.length;
      var instruction;
      var type;
      var begin = -1;
      for (i = 0; i < n; ++i) {
        instruction = hitDetectionInstructions[i];
        type = /** @type {import("./Instruction.js").default} */
        instruction[0];
        if (type == CanvasInstruction.END_GEOMETRY) {
          begin = i;
        } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {
          instruction[2] = i;
          reverseSubArray(this.hitDetectionInstructions, begin, i);
          begin = -1;
        }
      }
    };
    CanvasBuilder2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
      var state = this.state;
      if (fillStyle) {
        var fillStyleColor = fillStyle.getColor();
        state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
      } else {
        state.fillStyle = void 0;
      }
      if (strokeStyle) {
        var strokeStyleColor = strokeStyle.getColor();
        state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
        var strokeStyleLineCap = strokeStyle.getLineCap();
        state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
        var strokeStyleLineDash = strokeStyle.getLineDash();
        state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
        state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
        var strokeStyleLineJoin = strokeStyle.getLineJoin();
        state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
        var strokeStyleWidth = strokeStyle.getWidth();
        state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
        if (state.lineWidth > this.maxLineWidth) {
          this.maxLineWidth = state.lineWidth;
          this.bufferedMaxExtent_ = null;
        }
      } else {
        state.strokeStyle = void 0;
        state.lineCap = void 0;
        state.lineDash = null;
        state.lineDashOffset = void 0;
        state.lineJoin = void 0;
        state.lineWidth = void 0;
        state.miterLimit = void 0;
      }
    };
    CanvasBuilder2.prototype.createFill = function(state) {
      var fillStyle = state.fillStyle;
      var fillInstruction2 = [CanvasInstruction.SET_FILL_STYLE, fillStyle];
      if (typeof fillStyle !== "string") {
        fillInstruction2.push(true);
      }
      return fillInstruction2;
    };
    CanvasBuilder2.prototype.applyStroke = function(state) {
      this.instructions.push(this.createStroke(state));
    };
    CanvasBuilder2.prototype.createStroke = function(state) {
      return [
        CanvasInstruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth * this.pixelRatio,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        this.applyPixelRatio(state.lineDash),
        state.lineDashOffset * this.pixelRatio
      ];
    };
    CanvasBuilder2.prototype.updateFillStyle = function(state, createFill) {
      var fillStyle = state.fillStyle;
      if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
        if (fillStyle !== void 0) {
          this.instructions.push(createFill.call(this, state));
        }
        state.currentFillStyle = fillStyle;
      }
    };
    CanvasBuilder2.prototype.updateStrokeStyle = function(state, applyStroke) {
      var strokeStyle = state.strokeStyle;
      var lineCap = state.lineCap;
      var lineDash = state.lineDash;
      var lineDashOffset = state.lineDashOffset;
      var lineJoin = state.lineJoin;
      var lineWidth = state.lineWidth;
      var miterLimit = state.miterLimit;
      if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
        if (strokeStyle !== void 0) {
          applyStroke.call(this, state);
        }
        state.currentStrokeStyle = strokeStyle;
        state.currentLineCap = lineCap;
        state.currentLineDash = lineDash;
        state.currentLineDashOffset = lineDashOffset;
        state.currentLineJoin = lineJoin;
        state.currentLineWidth = lineWidth;
        state.currentMiterLimit = miterLimit;
      }
    };
    CanvasBuilder2.prototype.endGeometry = function(feature) {
      this.beginGeometryInstruction1_[2] = this.instructions.length;
      this.beginGeometryInstruction1_ = null;
      this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
      this.beginGeometryInstruction2_ = null;
      var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];
      this.instructions.push(endGeometryInstruction);
      this.hitDetectionInstructions.push(endGeometryInstruction);
    };
    CanvasBuilder2.prototype.getBufferedMaxExtent = function() {
      if (!this.bufferedMaxExtent_) {
        this.bufferedMaxExtent_ = clone(this.maxExtent);
        if (this.maxLineWidth > 0) {
          var width = this.resolution * (this.maxLineWidth + 1) / 2;
          buffer$1(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
        }
      }
      return this.bufferedMaxExtent_;
    };
    return CanvasBuilder2;
  }(VectorContext$1)
);
const Builder = CanvasBuilder;
var __extends$7 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasImageBuilder = (
  /** @class */
  function(_super) {
    __extends$7(CanvasImageBuilder2, _super);
    function CanvasImageBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
      var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      _this.hitDetectionImage_ = null;
      _this.image_ = null;
      _this.imagePixelRatio_ = void 0;
      _this.anchorX_ = void 0;
      _this.anchorY_ = void 0;
      _this.height_ = void 0;
      _this.opacity_ = void 0;
      _this.originX_ = void 0;
      _this.originY_ = void 0;
      _this.rotateWithView_ = void 0;
      _this.rotation_ = void 0;
      _this.scale_ = void 0;
      _this.width_ = void 0;
      _this.declutterMode_ = void 0;
      _this.declutterImageWithText_ = void 0;
      return _this;
    }
    CanvasImageBuilder2.prototype.drawPoint = function(pointGeometry2, feature) {
      if (!this.image_) {
        return;
      }
      this.beginGeometry(pointGeometry2, feature);
      var flatCoordinates = pointGeometry2.getFlatCoordinates();
      var stride = pointGeometry2.getStride();
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([
        CanvasInstruction.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.hitDetectionInstructions.push([
        CanvasInstruction.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        this.opacity_,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.endGeometry(feature);
    };
    CanvasImageBuilder2.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
      if (!this.image_) {
        return;
      }
      this.beginGeometry(multiPointGeometry, feature);
      var flatCoordinates = multiPointGeometry.getFlatCoordinates();
      var stride = multiPointGeometry.getStride();
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([
        CanvasInstruction.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.hitDetectionInstructions.push([
        CanvasInstruction.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        this.opacity_,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.endGeometry(feature);
    };
    CanvasImageBuilder2.prototype.finish = function() {
      this.reverseHitDetectionInstructions();
      this.anchorX_ = void 0;
      this.anchorY_ = void 0;
      this.hitDetectionImage_ = null;
      this.image_ = null;
      this.imagePixelRatio_ = void 0;
      this.height_ = void 0;
      this.scale_ = void 0;
      this.opacity_ = void 0;
      this.originX_ = void 0;
      this.originY_ = void 0;
      this.rotateWithView_ = void 0;
      this.rotation_ = void 0;
      this.width_ = void 0;
      return _super.prototype.finish.call(this);
    };
    CanvasImageBuilder2.prototype.setImageStyle = function(imageStyle, opt_sharedData) {
      var anchor = imageStyle.getAnchor();
      var size = imageStyle.getSize();
      var origin = imageStyle.getOrigin();
      this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
      this.anchorX_ = anchor[0];
      this.anchorY_ = anchor[1];
      this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
      this.image_ = imageStyle.getImage(this.pixelRatio);
      this.height_ = size[1];
      this.opacity_ = imageStyle.getOpacity();
      this.originX_ = origin[0];
      this.originY_ = origin[1];
      this.rotateWithView_ = imageStyle.getRotateWithView();
      this.rotation_ = imageStyle.getRotation();
      this.scale_ = imageStyle.getScaleArray();
      this.width_ = size[0];
      this.declutterMode_ = imageStyle.getDeclutterMode();
      this.declutterImageWithText_ = opt_sharedData;
    };
    return CanvasImageBuilder2;
  }(Builder)
);
const ImageBuilder = CanvasImageBuilder;
var __extends$6 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasLineStringBuilder = (
  /** @class */
  function(_super) {
    __extends$6(CanvasLineStringBuilder2, _super);
    function CanvasLineStringBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
      return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    }
    CanvasLineStringBuilder2.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
      var moveToLineToInstruction = [
        CanvasInstruction.MOVE_TO_LINE_TO,
        myBegin,
        myEnd
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      return end;
    };
    CanvasLineStringBuilder2.prototype.drawLineString = function(lineStringGeometry, feature) {
      var state = this.state;
      var strokeStyle = state.strokeStyle;
      var lineWidth = state.lineWidth;
      if (strokeStyle === void 0 || lineWidth === void 0) {
        return;
      }
      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(lineStringGeometry, feature);
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ], beginPathInstruction);
      var flatCoordinates = lineStringGeometry.getFlatCoordinates();
      var stride = lineStringGeometry.getStride();
      this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
      this.hitDetectionInstructions.push(strokeInstruction);
      this.endGeometry(feature);
    };
    CanvasLineStringBuilder2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
      var state = this.state;
      var strokeStyle = state.strokeStyle;
      var lineWidth = state.lineWidth;
      if (strokeStyle === void 0 || lineWidth === void 0) {
        return;
      }
      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(multiLineStringGeometry, feature);
      this.hitDetectionInstructions.push([
        CanvasInstruction.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        state.lineDash,
        state.lineDashOffset
      ], beginPathInstruction);
      var ends = multiLineStringGeometry.getEnds();
      var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
      var stride = multiLineStringGeometry.getStride();
      var offset = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.drawFlatCoordinates_(
          flatCoordinates,
          offset,
          /** @type {number} */
          ends[i],
          stride
        );
      }
      this.hitDetectionInstructions.push(strokeInstruction);
      this.endGeometry(feature);
    };
    CanvasLineStringBuilder2.prototype.finish = function() {
      var state = this.state;
      if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
        this.instructions.push(strokeInstruction);
      }
      this.reverseHitDetectionInstructions();
      this.state = null;
      return _super.prototype.finish.call(this);
    };
    CanvasLineStringBuilder2.prototype.applyStroke = function(state) {
      if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
        this.instructions.push(strokeInstruction);
        state.lastStroke = this.coordinates.length;
      }
      state.lastStroke = 0;
      _super.prototype.applyStroke.call(this, state);
      this.instructions.push(beginPathInstruction);
    };
    return CanvasLineStringBuilder2;
  }(Builder)
);
const LineStringBuilder = CanvasLineStringBuilder;
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
var __extends$5 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasPolygonBuilder = (
  /** @class */
  function(_super) {
    __extends$5(CanvasPolygonBuilder2, _super);
    function CanvasPolygonBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
      return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    }
    CanvasPolygonBuilder2.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {
      var state = this.state;
      var fill = state.fillStyle !== void 0;
      var stroke = state.strokeStyle !== void 0;
      var numEnds = ends.length;
      this.instructions.push(beginPathInstruction);
      this.hitDetectionInstructions.push(beginPathInstruction);
      for (var i = 0; i < numEnds; ++i) {
        var end = ends[i];
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
        var moveToLineToInstruction = [
          CanvasInstruction.MOVE_TO_LINE_TO,
          myBegin,
          myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        if (stroke) {
          this.instructions.push(closePathInstruction);
          this.hitDetectionInstructions.push(closePathInstruction);
        }
        offset = end;
      }
      if (fill) {
        this.instructions.push(fillInstruction);
        this.hitDetectionInstructions.push(fillInstruction);
      }
      if (stroke) {
        this.instructions.push(strokeInstruction);
        this.hitDetectionInstructions.push(strokeInstruction);
      }
      return offset;
    };
    CanvasPolygonBuilder2.prototype.drawCircle = function(circleGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;
      if (fillStyle === void 0 && strokeStyle === void 0) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(circleGeometry, feature);
      if (state.fillStyle !== void 0) {
        this.hitDetectionInstructions.push([
          CanvasInstruction.SET_FILL_STYLE,
          defaultFillStyle
        ]);
      }
      if (state.strokeStyle !== void 0) {
        this.hitDetectionInstructions.push([
          CanvasInstruction.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          state.lineDash,
          state.lineDashOffset
        ]);
      }
      var flatCoordinates = circleGeometry.getFlatCoordinates();
      var stride = circleGeometry.getStride();
      var myBegin = this.coordinates.length;
      this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];
      this.instructions.push(beginPathInstruction, circleInstruction);
      this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
      if (state.fillStyle !== void 0) {
        this.instructions.push(fillInstruction);
        this.hitDetectionInstructions.push(fillInstruction);
      }
      if (state.strokeStyle !== void 0) {
        this.instructions.push(strokeInstruction);
        this.hitDetectionInstructions.push(strokeInstruction);
      }
      this.endGeometry(feature);
    };
    CanvasPolygonBuilder2.prototype.drawPolygon = function(polygonGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;
      if (fillStyle === void 0 && strokeStyle === void 0) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(polygonGeometry, feature);
      if (state.fillStyle !== void 0) {
        this.hitDetectionInstructions.push([
          CanvasInstruction.SET_FILL_STYLE,
          defaultFillStyle
        ]);
      }
      if (state.strokeStyle !== void 0) {
        this.hitDetectionInstructions.push([
          CanvasInstruction.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          state.lineDash,
          state.lineDashOffset
        ]);
      }
      var ends = polygonGeometry.getEnds();
      var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
      var stride = polygonGeometry.getStride();
      this.drawFlatCoordinatess_(
        flatCoordinates,
        0,
        /** @type {Array<number>} */
        ends,
        stride
      );
      this.endGeometry(feature);
    };
    CanvasPolygonBuilder2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
      var state = this.state;
      var fillStyle = state.fillStyle;
      var strokeStyle = state.strokeStyle;
      if (fillStyle === void 0 && strokeStyle === void 0) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(multiPolygonGeometry, feature);
      if (state.fillStyle !== void 0) {
        this.hitDetectionInstructions.push([
          CanvasInstruction.SET_FILL_STYLE,
          defaultFillStyle
        ]);
      }
      if (state.strokeStyle !== void 0) {
        this.hitDetectionInstructions.push([
          CanvasInstruction.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          state.lineDash,
          state.lineDashOffset
        ]);
      }
      var endss = multiPolygonGeometry.getEndss();
      var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
      var stride = multiPolygonGeometry.getStride();
      var offset = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
      }
      this.endGeometry(feature);
    };
    CanvasPolygonBuilder2.prototype.finish = function() {
      this.reverseHitDetectionInstructions();
      this.state = null;
      var tolerance = this.tolerance;
      if (tolerance !== 0) {
        var coordinates = this.coordinates;
        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          coordinates[i] = snap(coordinates[i], tolerance);
        }
      }
      return _super.prototype.finish.call(this);
    };
    CanvasPolygonBuilder2.prototype.setFillStrokeStyles_ = function() {
      var state = this.state;
      var fillStyle = state.fillStyle;
      if (fillStyle !== void 0) {
        this.updateFillStyle(state, this.createFill);
      }
      if (state.strokeStyle !== void 0) {
        this.updateStrokeStyle(state, this.applyStroke);
      }
    };
    return CanvasPolygonBuilder2;
  }(Builder)
);
const PolygonBuilder = CanvasPolygonBuilder;
const TextPlacement = {
  POINT: "point",
  LINE: "line"
};
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start2 = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start2;
            chunkEnd = i;
          }
          m = 0;
          start2 = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start2, i] : [chunkStart, chunkEnd];
}
var __extends$4 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TEXT_ALIGN = {
  "left": 0,
  "end": 0,
  "center": 0.5,
  "right": 1,
  "start": 1,
  "top": 0,
  "middle": 0.5,
  "hanging": 0.2,
  "alphabetic": 0.8,
  "ideographic": 0.8,
  "bottom": 1
};
var CanvasTextBuilder = (
  /** @class */
  function(_super) {
    __extends$4(CanvasTextBuilder2, _super);
    function CanvasTextBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
      var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      _this.labels_ = null;
      _this.text_ = "";
      _this.textOffsetX_ = 0;
      _this.textOffsetY_ = 0;
      _this.textRotateWithView_ = void 0;
      _this.textRotation_ = 0;
      _this.textFillState_ = null;
      _this.fillStates = {};
      _this.textStrokeState_ = null;
      _this.strokeStates = {};
      _this.textState_ = /** @type {import("../canvas.js").TextState} */
      {};
      _this.textStates = {};
      _this.textKey_ = "";
      _this.fillKey_ = "";
      _this.strokeKey_ = "";
      _this.declutterImageWithText_ = void 0;
      return _this;
    }
    CanvasTextBuilder2.prototype.finish = function() {
      var instructions = _super.prototype.finish.call(this);
      instructions.textStates = this.textStates;
      instructions.fillStates = this.fillStates;
      instructions.strokeStates = this.strokeStates;
      return instructions;
    };
    CanvasTextBuilder2.prototype.drawText = function(geometry, feature) {
      var fillState = this.textFillState_;
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      if (this.text_ === "" || !textState || !fillState && !strokeState) {
        return;
      }
      var coordinates = this.coordinates;
      var begin = coordinates.length;
      var geometryType = geometry.getType();
      var flatCoordinates = null;
      var stride = geometry.getStride();
      if (textState.placement === TextPlacement.LINE && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
        if (!intersects$1(this.getBufferedMaxExtent(), geometry.getExtent())) {
          return;
        }
        var ends = void 0;
        flatCoordinates = geometry.getFlatCoordinates();
        if (geometryType == "LineString") {
          ends = [flatCoordinates.length];
        } else if (geometryType == "MultiLineString") {
          ends = /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.getEnds();
        } else if (geometryType == "Polygon") {
          ends = /** @type {import("../../geom/Polygon.js").default} */
          geometry.getEnds().slice(0, 1);
        } else if (geometryType == "MultiPolygon") {
          var endss = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getEndss()
          );
          ends = [];
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            ends.push(endss[i][0]);
          }
        }
        this.beginGeometry(geometry, feature);
        var textAlign = textState.textAlign;
        var flatOffset = 0;
        var flatEnd = void 0;
        for (var o = 0, oo = ends.length; o < oo; ++o) {
          if (textAlign == void 0) {
            var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
            flatOffset = range[0];
            flatEnd = range[1];
          } else {
            flatEnd = ends[o];
          }
          for (var i = flatOffset; i < flatEnd; i += stride) {
            coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
          }
          var end = coordinates.length;
          flatOffset = ends[o];
          this.drawChars_(begin, end);
          begin = end;
        }
        this.endGeometry(feature);
      } else {
        var geometryWidths = textState.overflow ? null : [];
        switch (geometryType) {
          case "Point":
          case "MultiPoint":
            flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
            geometry.getFlatCoordinates();
            break;
          case "LineString":
            flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
            geometry.getFlatMidpoint();
            break;
          case "Circle":
            flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
            geometry.getCenter();
            break;
          case "MultiLineString":
            flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
            geometry.getFlatMidpoints();
            stride = 2;
            break;
          case "Polygon":
            flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
            geometry.getFlatInteriorPoint();
            if (!textState.overflow) {
              geometryWidths.push(flatCoordinates[2] / this.resolution);
            }
            stride = 3;
            break;
          case "MultiPolygon":
            var interiorPoints = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getFlatInteriorPoints()
            );
            flatCoordinates = [];
            for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
              if (!textState.overflow) {
                geometryWidths.push(interiorPoints[i + 2] / this.resolution);
              }
              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
            }
            if (flatCoordinates.length === 0) {
              return;
            }
            stride = 2;
            break;
        }
        var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
        if (end === begin) {
          return;
        }
        if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
          var beg_1 = begin / 2;
          geometryWidths = geometryWidths.filter(function(w, i2) {
            var keep = coordinates[(beg_1 + i2) * 2] === flatCoordinates[i2 * stride] && coordinates[(beg_1 + i2) * 2 + 1] === flatCoordinates[i2 * stride + 1];
            if (!keep) {
              --beg_1;
            }
            return keep;
          });
        }
        this.saveTextStates_();
        if (textState.backgroundFill || textState.backgroundStroke) {
          this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
          if (textState.backgroundFill) {
            this.updateFillStyle(this.state, this.createFill);
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }
          if (textState.backgroundStroke) {
            this.updateStrokeStyle(this.state, this.applyStroke);
            this.hitDetectionInstructions.push(this.createStroke(this.state));
          }
        }
        this.beginGeometry(geometry, feature);
        var padding = textState.padding;
        if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
          var p0 = textState.padding[0];
          var p12 = textState.padding[1];
          var p22 = textState.padding[2];
          var p32 = textState.padding[3];
          if (textState.scale[0] < 0) {
            p12 = -p12;
            p32 = -p32;
          }
          if (textState.scale[1] < 0) {
            p0 = -p0;
            p22 = -p22;
          }
          padding = [p0, p12, p22, p32];
        }
        var pixelRatio_1 = this.pixelRatio;
        this.instructions.push([
          CanvasInstruction.DRAW_IMAGE,
          begin,
          end,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [1, 1],
          NaN,
          void 0,
          this.declutterImageWithText_,
          padding == defaultPadding ? defaultPadding : padding.map(function(p) {
            return p * pixelRatio_1;
          }),
          !!textState.backgroundFill,
          !!textState.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          geometryWidths
        ]);
        var scale2 = 1 / pixelRatio_1;
        this.hitDetectionInstructions.push([
          CanvasInstruction.DRAW_IMAGE,
          begin,
          end,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [scale2, scale2],
          NaN,
          void 0,
          this.declutterImageWithText_,
          padding,
          !!textState.backgroundFill,
          !!textState.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          geometryWidths
        ]);
        this.endGeometry(feature);
      }
    };
    CanvasTextBuilder2.prototype.saveTextStates_ = function() {
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      var fillState = this.textFillState_;
      var strokeKey = this.strokeKey_;
      if (strokeState) {
        if (!(strokeKey in this.strokeStates)) {
          this.strokeStates[strokeKey] = {
            strokeStyle: strokeState.strokeStyle,
            lineCap: strokeState.lineCap,
            lineDashOffset: strokeState.lineDashOffset,
            lineWidth: strokeState.lineWidth,
            lineJoin: strokeState.lineJoin,
            miterLimit: strokeState.miterLimit,
            lineDash: strokeState.lineDash
          };
        }
      }
      var textKey = this.textKey_;
      if (!(textKey in this.textStates)) {
        this.textStates[textKey] = {
          font: textState.font,
          textAlign: textState.textAlign || defaultTextAlign,
          justify: textState.justify,
          textBaseline: textState.textBaseline || defaultTextBaseline,
          scale: textState.scale
        };
      }
      var fillKey = this.fillKey_;
      if (fillState) {
        if (!(fillKey in this.fillStates)) {
          this.fillStates[fillKey] = {
            fillStyle: fillState.fillStyle
          };
        }
      }
    };
    CanvasTextBuilder2.prototype.drawChars_ = function(begin, end) {
      var strokeState = this.textStrokeState_;
      var textState = this.textState_;
      var strokeKey = this.strokeKey_;
      var textKey = this.textKey_;
      var fillKey = this.fillKey_;
      this.saveTextStates_();
      var pixelRatio = this.pixelRatio;
      var baseline = TEXT_ALIGN[textState.textBaseline];
      var offsetY = this.textOffsetY_ * pixelRatio;
      var text = this.text_;
      var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
      this.instructions.push([
        CanvasInstruction.DRAW_CHARS,
        begin,
        end,
        baseline,
        textState.overflow,
        fillKey,
        textState.maxAngle,
        pixelRatio,
        offsetY,
        strokeKey,
        strokeWidth * pixelRatio,
        text,
        textKey,
        1
      ]);
      this.hitDetectionInstructions.push([
        CanvasInstruction.DRAW_CHARS,
        begin,
        end,
        baseline,
        textState.overflow,
        fillKey,
        textState.maxAngle,
        1,
        offsetY,
        strokeKey,
        strokeWidth,
        text,
        textKey,
        1 / pixelRatio
      ]);
    };
    CanvasTextBuilder2.prototype.setTextStyle = function(textStyle, opt_sharedData) {
      var textState, fillState, strokeState;
      if (!textStyle) {
        this.text_ = "";
      } else {
        var textFillStyle = textStyle.getFill();
        if (!textFillStyle) {
          fillState = null;
          this.textFillState_ = fillState;
        } else {
          fillState = this.textFillState_;
          if (!fillState) {
            fillState = /** @type {import("../canvas.js").FillState} */
            {};
            this.textFillState_ = fillState;
          }
          fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
        }
        var textStrokeStyle = textStyle.getStroke();
        if (!textStrokeStyle) {
          strokeState = null;
          this.textStrokeState_ = strokeState;
        } else {
          strokeState = this.textStrokeState_;
          if (!strokeState) {
            strokeState = /** @type {import("../canvas.js").StrokeState} */
            {};
            this.textStrokeState_ = strokeState;
          }
          var lineDash = textStrokeStyle.getLineDash();
          var lineDashOffset = textStrokeStyle.getLineDashOffset();
          var lineWidth = textStrokeStyle.getWidth();
          var miterLimit = textStrokeStyle.getMiterLimit();
          strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
          strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
          strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
          strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
          strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
          strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
          strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
        }
        textState = this.textState_;
        var font = textStyle.getFont() || defaultFont;
        registerFont(font);
        var textScale = textStyle.getScaleArray();
        textState.overflow = textStyle.getOverflow();
        textState.font = font;
        textState.maxAngle = textStyle.getMaxAngle();
        textState.placement = textStyle.getPlacement();
        textState.textAlign = textStyle.getTextAlign();
        textState.justify = textStyle.getJustify();
        textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
        textState.backgroundFill = textStyle.getBackgroundFill();
        textState.backgroundStroke = textStyle.getBackgroundStroke();
        textState.padding = textStyle.getPadding() || defaultPadding;
        textState.scale = textScale === void 0 ? [1, 1] : textScale;
        var textOffsetX = textStyle.getOffsetX();
        var textOffsetY = textStyle.getOffsetY();
        var textRotateWithView = textStyle.getRotateWithView();
        var textRotation = textStyle.getRotation();
        this.text_ = textStyle.getText() || "";
        this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
        this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
        this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
        this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
        this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
        this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
        this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
      }
      this.declutterImageWithText_ = opt_sharedData;
    };
    return CanvasTextBuilder2;
  }(Builder)
);
const TextBuilder = CanvasTextBuilder;
var BATCH_CONSTRUCTORS = {
  "Circle": PolygonBuilder,
  "Default": Builder,
  "Image": ImageBuilder,
  "LineString": LineStringBuilder,
  "Polygon": PolygonBuilder,
  "Text": TextBuilder
};
var BuilderGroup = (
  /** @class */
  function() {
    function BuilderGroup2(tolerance, maxExtent, resolution, pixelRatio) {
      this.tolerance_ = tolerance;
      this.maxExtent_ = maxExtent;
      this.pixelRatio_ = pixelRatio;
      this.resolution_ = resolution;
      this.buildersByZIndex_ = {};
    }
    BuilderGroup2.prototype.finish = function() {
      var builderInstructions = {};
      for (var zKey in this.buildersByZIndex_) {
        builderInstructions[zKey] = builderInstructions[zKey] || {};
        var builders = this.buildersByZIndex_[zKey];
        for (var builderKey in builders) {
          var builderInstruction = builders[builderKey].finish();
          builderInstructions[zKey][builderKey] = builderInstruction;
        }
      }
      return builderInstructions;
    };
    BuilderGroup2.prototype.getBuilder = function(zIndex, builderType) {
      var zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
      var replays = this.buildersByZIndex_[zIndexKey];
      if (replays === void 0) {
        replays = {};
        this.buildersByZIndex_[zIndexKey] = replays;
      }
      var replay = replays[builderType];
      if (replay === void 0) {
        var Constructor = BATCH_CONSTRUCTORS[builderType];
        replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
        replays[builderType] = replay;
      }
      return replay;
    };
    return BuilderGroup2;
  }()
);
const BuilderGroup$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BuilderGroup
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(BuilderGroup$1);
var tmp_ = new Array(6);
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function reset(transform2) {
  return set(transform2, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
function set(transform2, a, b, c, d, e, f) {
  transform2[0] = a;
  transform2[1] = b;
  transform2[2] = c;
  transform2[3] = d;
  transform2[4] = e;
  transform2[5] = f;
  return transform2;
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply(transform2, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function rotate$1(transform2, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform2, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale(transform2, x, y) {
  return multiply(transform2, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform2, dx, dy) {
  return multiply(transform2, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
  return makeInverse(source, source);
}
function makeInverse(target, source) {
  var det = determinant(source);
  assert(det !== 0, 32);
  var a = source[0];
  var b = source[1];
  var c = source[2];
  var d = source[3];
  var e = source[4];
  var f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
var transformStringDiv;
function toString(mat) {
  var transformString = "matrix(" + mat.join(", ") + ")";
  if (WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  var node = transformStringDiv || (transformStringDiv = document.createElement("div"));
  node.style.transform = transformString;
  return node.style.transform;
}
const transform = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  apply,
  compose,
  composeCssTransform,
  create,
  determinant,
  invert,
  makeInverse,
  makeScale,
  multiply,
  reset,
  rotate: rotate$1,
  scale,
  set,
  setFromArray,
  toString,
  translate
}, Symbol.toStringTag, { value: "Module" }));
function transform2D(flatCoordinates, offset, end, stride, transform2, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale2, measureAndCacheTextWidth2, font, cache2, rotation) {
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var x1 = 0;
  var y1 = 0;
  var segmentLength = 0;
  var segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);
  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  var beginX = lerp(x1, x2, interpolate);
  var beginY = lerp(y1, y2, interpolate);
  var startOffset = offset - stride;
  var startLength = segmentM;
  var endM = startM + scale2 * measureAndCacheTextWidth2(font, text, cache2);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  var endX = lerp(x1, x2, interpolate);
  var endY = lerp(y1, y2, interpolate);
  var reverse;
  if (rotation) {
    var flat = [beginX, beginY, endX, endY];
    rotate(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }
  var PI = Math.PI;
  var result = [];
  var singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];
  var previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    var x = (endX + beginX) / 2;
    var y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }
  text = text.replace(/\n/g, " ");
  for (var i = 0, ii = text.length; i < ii; ) {
    advance();
    var angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      var delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    var iStart = i;
    var charLength = 0;
    for (; i < ii; ++i) {
      var index = reverse ? ii - i - 1 : i;
      var len = scale2 * measureAndCacheTextWidth2(font, text[index], cache2);
      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    var x = lerp(x1, x2, interpolate);
    var y = lerp(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}
var tmpExtent = createEmpty();
var p1 = [];
var p2 = [];
var p3 = [];
var p4 = [];
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
var rtlRegEx = new RegExp(
  /* eslint-disable prettier/prettier */
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
  /* eslint-enable prettier/prettier */
);
function horizontalTextAlign(text, align) {
  if ((align === "start" || align === "end") && !rtlRegEx.test(text)) {
    align = align === "start" ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
var Executor = (
  /** @class */
  function() {
    function Executor2(resolution, pixelRatio, overlaps, instructions) {
      this.overlaps = overlaps;
      this.pixelRatio = pixelRatio;
      this.resolution = resolution;
      this.alignFill_;
      this.instructions = instructions.instructions;
      this.coordinates = instructions.coordinates;
      this.coordinateCache_ = {};
      this.renderedTransform_ = create();
      this.hitDetectionInstructions = instructions.hitDetectionInstructions;
      this.pixelCoordinates_ = null;
      this.viewRotation_ = 0;
      this.fillStates = instructions.fillStates || {};
      this.strokeStates = instructions.strokeStates || {};
      this.textStates = instructions.textStates || {};
      this.widths_ = {};
      this.labels_ = {};
    }
    Executor2.prototype.createLabel = function(text, textKey, fillKey, strokeKey) {
      var key = text + textKey + fillKey + strokeKey;
      if (this.labels_[key]) {
        return this.labels_[key];
      }
      var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
      var fillState = fillKey ? this.fillStates[fillKey] : null;
      var textState = this.textStates[textKey];
      var pixelRatio = this.pixelRatio;
      var scale2 = [
        textState.scale[0] * pixelRatio,
        textState.scale[1] * pixelRatio
      ];
      var textIsArray = Array.isArray(text);
      var align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);
      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
      var chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
      var _a = getTextDimensions(textState, chunks), width = _a.width, height = _a.height, widths = _a.widths, heights = _a.heights, lineWidths = _a.lineWidths;
      var renderWidth = width + strokeWidth;
      var contextInstructions = [];
      var w = (renderWidth + 2) * scale2[0];
      var h = (height + strokeWidth) * scale2[1];
      var label = {
        width: w < 0 ? Math.floor(w) : Math.ceil(w),
        height: h < 0 ? Math.floor(h) : Math.ceil(h),
        contextInstructions
      };
      if (scale2[0] != 1 || scale2[1] != 1) {
        contextInstructions.push("scale", scale2);
      }
      if (strokeKey) {
        contextInstructions.push("strokeStyle", strokeState.strokeStyle);
        contextInstructions.push("lineWidth", strokeWidth);
        contextInstructions.push("lineCap", strokeState.lineCap);
        contextInstructions.push("lineJoin", strokeState.lineJoin);
        contextInstructions.push("miterLimit", strokeState.miterLimit);
        var Context2 = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
        if (Context2.prototype.setLineDash) {
          contextInstructions.push("setLineDash", [strokeState.lineDash]);
          contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
        }
      }
      if (fillKey) {
        contextInstructions.push("fillStyle", fillState.fillStyle);
      }
      contextInstructions.push("textBaseline", "middle");
      contextInstructions.push("textAlign", "center");
      var leftRight = 0.5 - align;
      var x = align * renderWidth + leftRight * strokeWidth;
      var strokeInstructions = [];
      var fillInstructions = [];
      var lineHeight = 0;
      var lineOffset = 0;
      var widthHeightIndex = 0;
      var lineWidthIndex = 0;
      var previousFont;
      for (var i = 0, ii = chunks.length; i < ii; i += 2) {
        var text_1 = chunks[i];
        if (text_1 === "\n") {
          lineOffset += lineHeight;
          lineHeight = 0;
          x = align * renderWidth + leftRight * strokeWidth;
          ++lineWidthIndex;
          continue;
        }
        var font = chunks[i + 1] || textState.font;
        if (font !== previousFont) {
          if (strokeKey) {
            strokeInstructions.push("font", font);
          }
          if (fillKey) {
            fillInstructions.push("font", font);
          }
          previousFont = font;
        }
        lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
        var fillStrokeArgs = [
          text_1,
          x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
          0.5 * (strokeWidth + lineHeight) + lineOffset
        ];
        x += widths[widthHeightIndex];
        if (strokeKey) {
          strokeInstructions.push("strokeText", fillStrokeArgs);
        }
        if (fillKey) {
          fillInstructions.push("fillText", fillStrokeArgs);
        }
        ++widthHeightIndex;
      }
      Array.prototype.push.apply(contextInstructions, strokeInstructions);
      Array.prototype.push.apply(contextInstructions, fillInstructions);
      this.labels_[key] = label;
      return label;
    };
    Executor2.prototype.replayTextBackground_ = function(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
      context.beginPath();
      context.moveTo.apply(context, p12);
      context.lineTo.apply(context, p22);
      context.lineTo.apply(context, p32);
      context.lineTo.apply(context, p42);
      context.lineTo.apply(context, p12);
      if (fillInstruction2) {
        this.alignFill_ = /** @type {boolean} */
        fillInstruction2[2];
        this.fill_(context);
      }
      if (strokeInstruction2) {
        this.setStrokeStyle_(
          context,
          /** @type {Array<*>} */
          strokeInstruction2
        );
        context.stroke();
      }
    };
    Executor2.prototype.calculateImageOrLabelDimensions_ = function(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, fillStroke, feature) {
      anchorX *= scale2[0];
      anchorY *= scale2[1];
      var x = centerX - anchorX;
      var y = centerY - anchorY;
      var w = width + originX > sheetWidth ? sheetWidth - originX : width;
      var h = height + originY > sheetHeight ? sheetHeight - originY : height;
      var boxW = padding[3] + w * scale2[0] + padding[1];
      var boxH = padding[0] + h * scale2[1] + padding[2];
      var boxX = x - padding[3];
      var boxY = y - padding[0];
      if (fillStroke || rotation !== 0) {
        p1[0] = boxX;
        p4[0] = boxX;
        p1[1] = boxY;
        p2[1] = boxY;
        p2[0] = boxX + boxW;
        p3[0] = p2[0];
        p3[1] = boxY + boxH;
        p4[1] = p3[1];
      }
      var transform2;
      if (rotation !== 0) {
        transform2 = compose(create(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
        apply(transform2, p1);
        apply(transform2, p2);
        apply(transform2, p3);
        apply(transform2, p4);
        createOrUpdate$2(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
      } else {
        createOrUpdate$2(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
      }
      if (snapToPixel) {
        x = Math.round(x);
        y = Math.round(y);
      }
      return {
        drawImageX: x,
        drawImageY: y,
        drawImageW: w,
        drawImageH: h,
        originX,
        originY,
        declutterBox: {
          minX: tmpExtent[0],
          minY: tmpExtent[1],
          maxX: tmpExtent[2],
          maxY: tmpExtent[3],
          value: feature
        },
        canvasTransform: transform2,
        scale: scale2
      };
    };
    Executor2.prototype.replayImageOrLabel_ = function(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
      var fillStroke = !!(fillInstruction2 || strokeInstruction2);
      var box = dimensions.declutterBox;
      var canvas = context.canvas;
      var strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
      var intersects2 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
      if (intersects2) {
        if (fillStroke) {
          this.replayTextBackground_(
            context,
            p1,
            p2,
            p3,
            p4,
            /** @type {Array<*>} */
            fillInstruction2,
            /** @type {Array<*>} */
            strokeInstruction2
          );
        }
        drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
      }
      return true;
    };
    Executor2.prototype.fill_ = function(context) {
      if (this.alignFill_) {
        var origin_1 = apply(this.renderedTransform_, [0, 0]);
        var repeatSize = 512 * this.pixelRatio;
        context.save();
        context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
        context.rotate(this.viewRotation_);
      }
      context.fill();
      if (this.alignFill_) {
        context.restore();
      }
    };
    Executor2.prototype.setStrokeStyle_ = function(context, instruction) {
      context["strokeStyle"] = /** @type {import("../../colorlike.js").ColorLike} */
      instruction[1];
      context.lineWidth = /** @type {number} */
      instruction[2];
      context.lineCap = /** @type {CanvasLineCap} */
      instruction[3];
      context.lineJoin = /** @type {CanvasLineJoin} */
      instruction[4];
      context.miterLimit = /** @type {number} */
      instruction[5];
      if (context.setLineDash) {
        context.lineDashOffset = /** @type {number} */
        instruction[7];
        context.setLineDash(
          /** @type {Array<number>} */
          instruction[6]
        );
      }
    };
    Executor2.prototype.drawLabelWithPointPlacement_ = function(text, textKey, strokeKey, fillKey) {
      var textState = this.textStates[textKey];
      var label = this.createLabel(text, textKey, fillKey, strokeKey);
      var strokeState = this.strokeStates[strokeKey];
      var pixelRatio = this.pixelRatio;
      var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);
      var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
      var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
      var width = label.width / pixelRatio - 2 * textState.scale[0];
      var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
      var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
      return {
        label,
        anchorX,
        anchorY
      };
    };
    Executor2.prototype.execute_ = function(context, contextScale, transform2, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
      var pixelCoordinates;
      if (this.pixelCoordinates_ && equals(transform2, this.renderedTransform_)) {
        pixelCoordinates = this.pixelCoordinates_;
      } else {
        if (!this.pixelCoordinates_) {
          this.pixelCoordinates_ = [];
        }
        pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform2, this.pixelCoordinates_);
        setFromArray(this.renderedTransform_, transform2);
      }
      var i = 0;
      var ii = instructions.length;
      var d = 0;
      var dd;
      var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
      var pendingFill = 0;
      var pendingStroke = 0;
      var lastFillInstruction = null;
      var lastStrokeInstruction = null;
      var coordinateCache = this.coordinateCache_;
      var viewRotation = this.viewRotation_;
      var viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
      var state = (
        /** @type {import("../../render.js").State} */
        {
          context,
          pixelRatio: this.pixelRatio,
          resolution: this.resolution,
          rotation: viewRotation
        }
      );
      var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
      var feature;
      var x, y, currentGeometry;
      while (i < ii) {
        var instruction = instructions[i];
        var type = (
          /** @type {import("./Instruction.js").default} */
          instruction[0]
        );
        switch (type) {
          case CanvasInstruction.BEGIN_GEOMETRY:
            feature = /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            currentGeometry = instruction[3];
            if (!feature.getGeometry()) {
              i = /** @type {number} */
              instruction[2];
            } else if (opt_hitExtent !== void 0 && !intersects$1(opt_hitExtent, currentGeometry.getExtent())) {
              i = /** @type {number} */
              instruction[2] + 1;
            } else {
              ++i;
            }
            break;
          case CanvasInstruction.BEGIN_PATH:
            if (pendingFill > batchSize) {
              this.fill_(context);
              pendingFill = 0;
            }
            if (pendingStroke > batchSize) {
              context.stroke();
              pendingStroke = 0;
            }
            if (!pendingFill && !pendingStroke) {
              context.beginPath();
              prevX = NaN;
              prevY = NaN;
            }
            ++i;
            break;
          case CanvasInstruction.CIRCLE:
            d = /** @type {number} */
            instruction[1];
            var x1 = pixelCoordinates[d];
            var y1 = pixelCoordinates[d + 1];
            var x2 = pixelCoordinates[d + 2];
            var y2 = pixelCoordinates[d + 3];
            var dx = x2 - x1;
            var dy = y2 - y1;
            var r = Math.sqrt(dx * dx + dy * dy);
            context.moveTo(x1 + r, y1);
            context.arc(x1, y1, r, 0, 2 * Math.PI, true);
            ++i;
            break;
          case CanvasInstruction.CLOSE_PATH:
            context.closePath();
            ++i;
            break;
          case CanvasInstruction.CUSTOM:
            d = /** @type {number} */
            instruction[1];
            dd = instruction[2];
            var geometry = (
              /** @type {import("../../geom/SimpleGeometry.js").default} */
              instruction[3]
            );
            var renderer = instruction[4];
            var fn = instruction.length == 6 ? instruction[5] : void 0;
            state.geometry = geometry;
            state.feature = feature;
            if (!(i in coordinateCache)) {
              coordinateCache[i] = [];
            }
            var coords = coordinateCache[i];
            if (fn) {
              fn(pixelCoordinates, d, dd, 2, coords);
            } else {
              coords[0] = pixelCoordinates[d];
              coords[1] = pixelCoordinates[d + 1];
              coords.length = 2;
            }
            renderer(coords, state);
            ++i;
            break;
          case CanvasInstruction.DRAW_IMAGE:
            d = /** @type {number} */
            instruction[1];
            dd = /** @type {number} */
            instruction[2];
            image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
            instruction[3];
            anchorX = /** @type {number} */
            instruction[4];
            anchorY = /** @type {number} */
            instruction[5];
            var height = (
              /** @type {number} */
              instruction[6]
            );
            var opacity = (
              /** @type {number} */
              instruction[7]
            );
            var originX = (
              /** @type {number} */
              instruction[8]
            );
            var originY = (
              /** @type {number} */
              instruction[9]
            );
            var rotateWithView = (
              /** @type {boolean} */
              instruction[10]
            );
            var rotation = (
              /** @type {number} */
              instruction[11]
            );
            var scale2 = (
              /** @type {import("../../size.js").Size} */
              instruction[12]
            );
            var width = (
              /** @type {number} */
              instruction[13]
            );
            var declutterMode = (
              /** @type {"declutter"|"obstacle"|"none"|undefined} */
              instruction[14]
            );
            var declutterImageWithText = (
              /** @type {import("../canvas.js").DeclutterImageWithText} */
              instruction[15]
            );
            if (!image && instruction.length >= 20) {
              text = /** @type {string} */
              instruction[19];
              textKey = /** @type {string} */
              instruction[20];
              strokeKey = /** @type {string} */
              instruction[21];
              fillKey = /** @type {string} */
              instruction[22];
              var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
              image = labelWithAnchor.label;
              instruction[3] = image;
              var textOffsetX = (
                /** @type {number} */
                instruction[23]
              );
              anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
              instruction[4] = anchorX;
              var textOffsetY = (
                /** @type {number} */
                instruction[24]
              );
              anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
              instruction[5] = anchorY;
              height = image.height;
              instruction[6] = height;
              width = image.width;
              instruction[13] = width;
            }
            var geometryWidths = void 0;
            if (instruction.length > 25) {
              geometryWidths = /** @type {number} */
              instruction[25];
            }
            var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
            if (instruction.length > 17) {
              padding = /** @type {Array<number>} */
              instruction[16];
              backgroundFill = /** @type {boolean} */
              instruction[17];
              backgroundStroke = /** @type {boolean} */
              instruction[18];
            } else {
              padding = defaultPadding;
              backgroundFill = false;
              backgroundStroke = false;
            }
            if (rotateWithView && viewRotationFromTransform) {
              rotation += viewRotation;
            } else if (!rotateWithView && !viewRotationFromTransform) {
              rotation -= viewRotation;
            }
            var widthIndex = 0;
            for (; d < dd; d += 2) {
              if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                continue;
              }
              var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
              var args = [
                context,
                contextScale,
                image,
                dimensions,
                opacity,
                backgroundFill ? (
                  /** @type {Array<*>} */
                  lastFillInstruction
                ) : null,
                backgroundStroke ? (
                  /** @type {Array<*>} */
                  lastStrokeInstruction
                ) : null
              ];
              if (opt_declutterTree) {
                if (declutterMode === "none") {
                  continue;
                } else if (declutterMode === "obstacle") {
                  opt_declutterTree.insert(dimensions.declutterBox);
                  continue;
                } else {
                  var imageArgs = void 0;
                  var imageDeclutterBox = void 0;
                  if (declutterImageWithText) {
                    var index = dd - d;
                    if (!declutterImageWithText[index]) {
                      declutterImageWithText[index] = args;
                      continue;
                    }
                    imageArgs = declutterImageWithText[index];
                    delete declutterImageWithText[index];
                    imageDeclutterBox = getDeclutterBox(imageArgs);
                    if (opt_declutterTree.collides(imageDeclutterBox)) {
                      continue;
                    }
                  }
                  if (opt_declutterTree.collides(dimensions.declutterBox)) {
                    continue;
                  }
                  if (imageArgs) {
                    opt_declutterTree.insert(imageDeclutterBox);
                    this.replayImageOrLabel_.apply(this, imageArgs);
                  }
                  opt_declutterTree.insert(dimensions.declutterBox);
                }
              }
              this.replayImageOrLabel_.apply(this, args);
            }
            ++i;
            break;
          case CanvasInstruction.DRAW_CHARS:
            var begin = (
              /** @type {number} */
              instruction[1]
            );
            var end = (
              /** @type {number} */
              instruction[2]
            );
            var baseline = (
              /** @type {number} */
              instruction[3]
            );
            var overflow = (
              /** @type {number} */
              instruction[4]
            );
            fillKey = /** @type {string} */
            instruction[5];
            var maxAngle = (
              /** @type {number} */
              instruction[6]
            );
            var measurePixelRatio = (
              /** @type {number} */
              instruction[7]
            );
            var offsetY = (
              /** @type {number} */
              instruction[8]
            );
            strokeKey = /** @type {string} */
            instruction[9];
            var strokeWidth = (
              /** @type {number} */
              instruction[10]
            );
            text = /** @type {string} */
            instruction[11];
            textKey = /** @type {string} */
            instruction[12];
            var pixelRatioScale = [
              /** @type {number} */
              instruction[13],
              /** @type {number} */
              instruction[13]
            ];
            var textState = this.textStates[textKey];
            var font = textState.font;
            var textScale = [
              textState.scale[0] * measurePixelRatio,
              textState.scale[1] * measurePixelRatio
            ];
            var cachedWidths = void 0;
            if (font in this.widths_) {
              cachedWidths = this.widths_[font];
            } else {
              cachedWidths = {};
              this.widths_[font] = cachedWidths;
            }
            var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
            var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
            if (overflow || textLength <= pathLength) {
              var textAlign = this.textStates[textKey].textAlign;
              var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
              var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
              drawChars:
                if (parts) {
                  var replayImageOrLabelArgs = [];
                  var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                  if (strokeKey) {
                    for (c = 0, cc = parts.length; c < cc; ++c) {
                      part = parts[c];
                      chars = /** @type {string} */
                      part[4];
                      label = this.createLabel(chars, textKey, "", strokeKey);
                      anchorX = /** @type {number} */
                      part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                      anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                      var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                      if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                        break drawChars;
                      }
                      replayImageOrLabelArgs.push([
                        context,
                        contextScale,
                        label,
                        dimensions,
                        1,
                        null,
                        null
                      ]);
                    }
                  }
                  if (fillKey) {
                    for (c = 0, cc = parts.length; c < cc; ++c) {
                      part = parts[c];
                      chars = /** @type {string} */
                      part[4];
                      label = this.createLabel(chars, textKey, fillKey, "");
                      anchorX = /** @type {number} */
                      part[2];
                      anchorY = baseline * label.height - offsetY;
                      var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                      if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                        break drawChars;
                      }
                      replayImageOrLabelArgs.push([
                        context,
                        contextScale,
                        label,
                        dimensions,
                        1,
                        null,
                        null
                      ]);
                    }
                  }
                  if (opt_declutterTree) {
                    opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                  }
                  for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                    this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                  }
                }
            }
            ++i;
            break;
          case CanvasInstruction.END_GEOMETRY:
            if (opt_featureCallback !== void 0) {
              feature = /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              var result = opt_featureCallback(feature, currentGeometry);
              if (result) {
                return result;
              }
            }
            ++i;
            break;
          case CanvasInstruction.FILL:
            if (batchSize) {
              pendingFill++;
            } else {
              this.fill_(context);
            }
            ++i;
            break;
          case CanvasInstruction.MOVE_TO_LINE_TO:
            d = /** @type {number} */
            instruction[1];
            dd = /** @type {number} */
            instruction[2];
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;
            if (roundX !== prevX || roundY !== prevY) {
              context.moveTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
            for (d += 2; d < dd; d += 2) {
              x = pixelCoordinates[d];
              y = pixelCoordinates[d + 1];
              roundX = x + 0.5 | 0;
              roundY = y + 0.5 | 0;
              if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                context.lineTo(x, y);
                prevX = roundX;
                prevY = roundY;
              }
            }
            ++i;
            break;
          case CanvasInstruction.SET_FILL_STYLE:
            lastFillInstruction = instruction;
            this.alignFill_ = instruction[2];
            if (pendingFill) {
              this.fill_(context);
              pendingFill = 0;
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
            }
            context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
            instruction[1];
            ++i;
            break;
          case CanvasInstruction.SET_STROKE_STYLE:
            lastStrokeInstruction = instruction;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
            this.setStrokeStyle_(
              context,
              /** @type {Array<*>} */
              instruction
            );
            ++i;
            break;
          case CanvasInstruction.STROKE:
            if (batchSize) {
              pendingStroke++;
            } else {
              context.stroke();
            }
            ++i;
            break;
          default:
            ++i;
            break;
        }
      }
      if (pendingFill) {
        this.fill_(context);
      }
      if (pendingStroke) {
        context.stroke();
      }
      return void 0;
    };
    Executor2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree) {
      this.viewRotation_ = viewRotation;
      this.execute_(context, contextScale, transform2, this.instructions, snapToPixel, void 0, void 0, opt_declutterTree);
    };
    Executor2.prototype.executeHitDetection = function(context, transform2, viewRotation, opt_featureCallback, opt_hitExtent) {
      this.viewRotation_ = viewRotation;
      return this.execute_(context, 1, transform2, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
    };
    return Executor2;
  }()
);
const Executor$1 = Executor;
var ORDER = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
var ExecutorGroup = (
  /** @class */
  function() {
    function ExecutorGroup2(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
      this.maxExtent_ = maxExtent;
      this.overlaps_ = overlaps;
      this.pixelRatio_ = pixelRatio;
      this.resolution_ = resolution;
      this.renderBuffer_ = opt_renderBuffer;
      this.executorsByZIndex_ = {};
      this.hitDetectionContext_ = null;
      this.hitDetectionTransform_ = create();
      this.createExecutors_(allInstructions);
    }
    ExecutorGroup2.prototype.clip = function(context, transform2) {
      var flatClipCoords = this.getClipCoords(transform2);
      context.beginPath();
      context.moveTo(flatClipCoords[0], flatClipCoords[1]);
      context.lineTo(flatClipCoords[2], flatClipCoords[3]);
      context.lineTo(flatClipCoords[4], flatClipCoords[5]);
      context.lineTo(flatClipCoords[6], flatClipCoords[7]);
      context.clip();
    };
    ExecutorGroup2.prototype.createExecutors_ = function(allInstructions) {
      for (var zIndex in allInstructions) {
        var executors = this.executorsByZIndex_[zIndex];
        if (executors === void 0) {
          executors = {};
          this.executorsByZIndex_[zIndex] = executors;
        }
        var instructionByZindex = allInstructions[zIndex];
        for (var builderType in instructionByZindex) {
          var instructions = instructionByZindex[builderType];
          executors[builderType] = new Executor$1(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
        }
      }
    };
    ExecutorGroup2.prototype.hasExecutors = function(executors) {
      for (var zIndex in this.executorsByZIndex_) {
        var candidates = this.executorsByZIndex_[zIndex];
        for (var i = 0, ii = executors.length; i < ii; ++i) {
          if (executors[i] in candidates) {
            return true;
          }
        }
      }
      return false;
    };
    ExecutorGroup2.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
      hitTolerance = Math.round(hitTolerance);
      var contextSize = hitTolerance * 2 + 1;
      var transform2 = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
      var newContext = !this.hitDetectionContext_;
      if (newContext) {
        this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
      }
      var context = this.hitDetectionContext_;
      if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
        context.canvas.width = contextSize;
        context.canvas.height = contextSize;
      } else if (!newContext) {
        context.clearRect(0, 0, contextSize, contextSize);
      }
      var hitExtent;
      if (this.renderBuffer_ !== void 0) {
        hitExtent = createEmpty();
        extendCoordinate(hitExtent, coordinate);
        buffer$1(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
      }
      var indexes = getPixelIndexArray(hitTolerance);
      var builderType;
      function featureCallback(feature, geometry) {
        var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
        for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
          if (imageData[indexes[i_1]] > 0) {
            if (!declutteredFeatures || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.indexOf(feature) !== -1) {
              var idx = (indexes[i_1] - 3) / 4;
              var x = hitTolerance - idx % contextSize;
              var y = hitTolerance - (idx / contextSize | 0);
              var result_1 = callback(feature, geometry, x * x + y * y);
              if (result_1) {
                return result_1;
              }
            }
            context.clearRect(0, 0, contextSize, contextSize);
            break;
          }
        }
        return void 0;
      }
      var zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(numberSafeCompareFunction);
      var i, j, executors, executor, result;
      for (i = zs.length - 1; i >= 0; --i) {
        var zIndexKey = zs[i].toString();
        executors = this.executorsByZIndex_[zIndexKey];
        for (j = ORDER.length - 1; j >= 0; --j) {
          builderType = ORDER[j];
          executor = executors[builderType];
          if (executor !== void 0) {
            result = executor.executeHitDetection(context, transform2, rotation, featureCallback, hitExtent);
            if (result) {
              return result;
            }
          }
        }
      }
      return void 0;
    };
    ExecutorGroup2.prototype.getClipCoords = function(transform2) {
      var maxExtent = this.maxExtent_;
      if (!maxExtent) {
        return null;
      }
      var minX = maxExtent[0];
      var minY = maxExtent[1];
      var maxX = maxExtent[2];
      var maxY = maxExtent[3];
      var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
      transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
      return flatClipCoords;
    };
    ExecutorGroup2.prototype.isEmpty = function() {
      return isEmpty$1(this.executorsByZIndex_);
    };
    ExecutorGroup2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
      var zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(numberSafeCompareFunction);
      if (this.maxExtent_) {
        context.save();
        this.clip(context, transform2);
      }
      var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
      var i, ii, j, jj, replays, replay;
      if (opt_declutterTree) {
        zs.reverse();
      }
      for (i = 0, ii = zs.length; i < ii; ++i) {
        var zIndexKey = zs[i].toString();
        replays = this.executorsByZIndex_[zIndexKey];
        for (j = 0, jj = builderTypes.length; j < jj; ++j) {
          var builderType = builderTypes[j];
          replay = replays[builderType];
          if (replay !== void 0) {
            replay.execute(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree);
          }
        }
      }
      if (this.maxExtent_) {
        context.restore();
      }
    };
    return ExecutorGroup2;
  }()
);
var circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  var size = radius * 2 + 1;
  var maxDistanceSq = radius * radius;
  var distances = new Array(maxDistanceSq + 1);
  for (var i = 0; i <= radius; ++i) {
    for (var j = 0; j <= radius; ++j) {
      var distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      var distance = distances[distanceSq];
      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }
      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }
  var pixelIndex = [];
  for (var i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push.apply(pixelIndex, distances[i]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
const ExecutorGroup$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ExecutorGroup,
  getPixelIndexArray
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(ExecutorGroup$1);
var SIMPLIFY_TOLERANCE = 0.5;
var GEOMETRY_RENDERERS = {
  "Point": renderPointGeometry,
  "LineString": renderLineStringGeometry,
  "Polygon": renderPolygonGeometry,
  "MultiPoint": renderMultiPointGeometry,
  "MultiLineString": renderMultiLineStringGeometry,
  "MultiPolygon": renderMultiPolygonGeometry,
  "GeometryCollection": renderGeometryCollectionGeometry,
  "Circle": renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var fillStyle = style2.getFill();
  var strokeStyle = style2.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = builderGroup.getBuilder(style2.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style2, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
  var loading2 = false;
  var imageStyle = style2.getImage();
  if (imageStyle) {
    var imageState = imageStyle.getImageState();
    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == ImageState.IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener);
      loading2 = true;
    }
  }
  renderFeatureInternal(replayGroup, feature, style2, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
  return loading2;
}
function renderFeatureInternal(replayGroup, feature, style2, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
  var geometry = style2.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
  var renderer = style2.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style2, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style2, feature, opt_declutterBuilderGroup);
  }
}
function renderGeometry(replayGroup, geometry, style2, feature) {
  if (geometry.getType() == "GeometryCollection") {
    var geometries = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      geometry.getGeometries()
    );
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style2, feature);
    }
    return;
  }
  var replay = replayGroup.getBuilder(style2.getZIndex(), "Default");
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    geometry,
    feature,
    style2.getRenderer(),
    style2.getHitDetectionRenderer()
  );
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style2, feature, opt_declutterBuilderGroup);
  }
}
function renderLineStringGeometry(builderGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var strokeStyle = style2.getStroke();
  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), "LineString");
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var strokeStyle = style2.getStroke();
  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), "LineString");
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var fillStyle = style2.getFill();
  var strokeStyle = style2.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = builderGroup.getBuilder(style2.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderPointGeometry(builderGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var imageStyle = style2.getImage();
  var textStyle = style2.getText();
  var declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }
    var imageBuilderGroup = builderGroup;
    if (opt_declutterBuilderGroup) {
      var declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = opt_declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          var imageReplay_1 = builderGroup.getBuilder(style2.getZIndex(), "Image");
          imageReplay_1.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay_1.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    var imageReplay = imageBuilderGroup.getBuilder(style2.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    var textBuilderGroup = builderGroup;
    if (opt_declutterBuilderGroup) {
      textBuilderGroup = opt_declutterBuilderGroup;
    }
    var textReplay = textBuilderGroup.getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var imageStyle = style2.getImage();
  var textStyle = style2.getText();
  var declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState.LOADED) {
      return;
    }
    var imageBuilderGroup = builderGroup;
    if (opt_declutterBuilderGroup) {
      var declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = opt_declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          var imageReplay_2 = builderGroup.getBuilder(style2.getZIndex(), "Image");
          imageReplay_2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay_2.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    var imageReplay = imageBuilderGroup.getBuilder(style2.getZIndex(), "Image");
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    var textBuilderGroup = builderGroup;
    if (opt_declutterBuilderGroup) {
      textBuilderGroup = opt_declutterBuilderGroup;
    }
    var textReplay = textBuilderGroup.getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style2, feature, opt_declutterBuilderGroup) {
  var fillStyle = style2.getFill();
  var strokeStyle = style2.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = builderGroup.getBuilder(style2.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style2.getText();
  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
const vector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultOrder,
  getSquaredTolerance,
  getTolerance,
  renderFeature
}, Symbol.toStringTag, { value: "Module" }));
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(vector);
var ImageStyle = (
  /** @class */
  function() {
    function ImageStyle2(options) {
      this.opacity_ = options.opacity;
      this.rotateWithView_ = options.rotateWithView;
      this.rotation_ = options.rotation;
      this.scale_ = options.scale;
      this.scaleArray_ = toSize(options.scale);
      this.displacement_ = options.displacement;
      this.declutterMode_ = options.declutterMode;
    }
    ImageStyle2.prototype.clone = function() {
      var scale2 = this.getScale();
      return new ImageStyle2({
        opacity: this.getOpacity(),
        scale: Array.isArray(scale2) ? scale2.slice() : scale2,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    };
    ImageStyle2.prototype.getOpacity = function() {
      return this.opacity_;
    };
    ImageStyle2.prototype.getRotateWithView = function() {
      return this.rotateWithView_;
    };
    ImageStyle2.prototype.getRotation = function() {
      return this.rotation_;
    };
    ImageStyle2.prototype.getScale = function() {
      return this.scale_;
    };
    ImageStyle2.prototype.getScaleArray = function() {
      return this.scaleArray_;
    };
    ImageStyle2.prototype.getDisplacement = function() {
      return this.displacement_;
    };
    ImageStyle2.prototype.getDeclutterMode = function() {
      return this.declutterMode_;
    };
    ImageStyle2.prototype.getAnchor = function() {
      return abstract();
    };
    ImageStyle2.prototype.getImage = function(pixelRatio) {
      return abstract();
    };
    ImageStyle2.prototype.getHitDetectionImage = function() {
      return abstract();
    };
    ImageStyle2.prototype.getPixelRatio = function(pixelRatio) {
      return 1;
    };
    ImageStyle2.prototype.getImageState = function() {
      return abstract();
    };
    ImageStyle2.prototype.getImageSize = function() {
      return abstract();
    };
    ImageStyle2.prototype.getOrigin = function() {
      return abstract();
    };
    ImageStyle2.prototype.getSize = function() {
      return abstract();
    };
    ImageStyle2.prototype.setDisplacement = function(displacement) {
      this.displacement_ = displacement;
    };
    ImageStyle2.prototype.setOpacity = function(opacity) {
      this.opacity_ = opacity;
    };
    ImageStyle2.prototype.setRotateWithView = function(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    };
    ImageStyle2.prototype.setRotation = function(rotation) {
      this.rotation_ = rotation;
    };
    ImageStyle2.prototype.setScale = function(scale2) {
      this.scale_ = scale2;
      this.scaleArray_ = toSize(scale2);
    };
    ImageStyle2.prototype.listenImageChange = function(listener) {
      abstract();
    };
    ImageStyle2.prototype.load = function() {
      abstract();
    };
    ImageStyle2.prototype.unlistenImageChange = function(listener) {
      abstract();
    };
    return ImageStyle2;
  }()
);
const ImageStyle$1 = ImageStyle;
var __extends$3 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RegularShape = (
  /** @class */
  function(_super) {
    __extends$3(RegularShape2, _super);
    function RegularShape2(options) {
      var _this = this;
      var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
      _this = _super.call(this, {
        opacity: 1,
        rotateWithView,
        rotation: options.rotation !== void 0 ? options.rotation : 0,
        scale: options.scale !== void 0 ? options.scale : 1,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
        declutterMode: options.declutterMode
      }) || this;
      _this.canvas_ = void 0;
      _this.hitDetectionCanvas_ = null;
      _this.fill_ = options.fill !== void 0 ? options.fill : null;
      _this.origin_ = [0, 0];
      _this.points_ = options.points;
      _this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
      _this.radius2_ = options.radius2;
      _this.angle_ = options.angle !== void 0 ? options.angle : 0;
      _this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      _this.size_ = null;
      _this.renderOptions_ = null;
      _this.render();
      return _this;
    }
    RegularShape2.prototype.clone = function() {
      var scale2 = this.getScale();
      var style2 = new RegularShape2({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale2) ? scale2.slice() : scale2,
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style2.setOpacity(this.getOpacity());
      return style2;
    };
    RegularShape2.prototype.getAnchor = function() {
      var size = this.size_;
      if (!size) {
        return null;
      }
      var displacement = this.getDisplacement();
      return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];
    };
    RegularShape2.prototype.getAngle = function() {
      return this.angle_;
    };
    RegularShape2.prototype.getFill = function() {
      return this.fill_;
    };
    RegularShape2.prototype.setFill = function(fill) {
      this.fill_ = fill;
      this.render();
    };
    RegularShape2.prototype.getHitDetectionImage = function() {
      if (!this.hitDetectionCanvas_) {
        this.createHitDetectionCanvas_(this.renderOptions_);
      }
      return this.hitDetectionCanvas_;
    };
    RegularShape2.prototype.getImage = function(pixelRatio) {
      var image = this.canvas_[pixelRatio];
      if (!image) {
        var renderOptions = this.renderOptions_;
        var context = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
        this.draw_(renderOptions, context, pixelRatio);
        image = context.canvas;
        this.canvas_[pixelRatio] = image;
      }
      return image;
    };
    RegularShape2.prototype.getPixelRatio = function(pixelRatio) {
      return pixelRatio;
    };
    RegularShape2.prototype.getImageSize = function() {
      return this.size_;
    };
    RegularShape2.prototype.getImageState = function() {
      return ImageState.LOADED;
    };
    RegularShape2.prototype.getOrigin = function() {
      return this.origin_;
    };
    RegularShape2.prototype.getPoints = function() {
      return this.points_;
    };
    RegularShape2.prototype.getRadius = function() {
      return this.radius_;
    };
    RegularShape2.prototype.getRadius2 = function() {
      return this.radius2_;
    };
    RegularShape2.prototype.getSize = function() {
      return this.size_;
    };
    RegularShape2.prototype.getStroke = function() {
      return this.stroke_;
    };
    RegularShape2.prototype.setStroke = function(stroke) {
      this.stroke_ = stroke;
      this.render();
    };
    RegularShape2.prototype.listenImageChange = function(listener) {
    };
    RegularShape2.prototype.load = function() {
    };
    RegularShape2.prototype.unlistenImageChange = function(listener) {
    };
    RegularShape2.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {
      if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
        return strokeWidth;
      }
      var r1 = this.radius_;
      var r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
      if (r1 < r2) {
        var tmp2 = r1;
        r1 = r2;
        r2 = tmp2;
      }
      var points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
      var alpha = 2 * Math.PI / points;
      var a = r2 * Math.sin(alpha);
      var b = Math.sqrt(r2 * r2 - a * a);
      var d = r1 - b;
      var e = Math.sqrt(a * a + d * d);
      var miterRatio = e / a;
      if (lineJoin === "miter" && miterRatio <= miterLimit) {
        return miterRatio * strokeWidth;
      }
      var k = strokeWidth / 2 / miterRatio;
      var l = strokeWidth / 2 * (d / e);
      var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
      var bevelAdd = maxr - r1;
      if (this.radius2_ === void 0 || lineJoin === "bevel") {
        return bevelAdd * 2;
      }
      var aa = r1 * Math.sin(alpha);
      var bb = Math.sqrt(r1 * r1 - aa * aa);
      var dd = r2 - bb;
      var ee = Math.sqrt(aa * aa + dd * dd);
      var innerMiterRatio = ee / aa;
      if (innerMiterRatio <= miterLimit) {
        var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
        return 2 * Math.max(bevelAdd, innerLength);
      }
      return bevelAdd * 2;
    };
    RegularShape2.prototype.createRenderOptions = function() {
      var lineJoin = defaultLineJoin;
      var miterLimit = 0;
      var lineDash = null;
      var lineDashOffset = 0;
      var strokeStyle;
      var strokeWidth = 0;
      if (this.stroke_) {
        strokeStyle = this.stroke_.getColor();
        if (strokeStyle === null) {
          strokeStyle = defaultStrokeStyle;
        }
        strokeStyle = asColorLike(strokeStyle);
        strokeWidth = this.stroke_.getWidth();
        if (strokeWidth === void 0) {
          strokeWidth = defaultLineWidth;
        }
        lineDash = this.stroke_.getLineDash();
        lineDashOffset = this.stroke_.getLineDashOffset();
        lineJoin = this.stroke_.getLineJoin();
        if (lineJoin === void 0) {
          lineJoin = defaultLineJoin;
        }
        miterLimit = this.stroke_.getMiterLimit();
        if (miterLimit === void 0) {
          miterLimit = defaultMiterLimit;
        }
      }
      var add2 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
      var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
      var size = Math.ceil(2 * maxRadius + add2);
      return {
        strokeStyle,
        strokeWidth,
        size,
        lineDash,
        lineDashOffset,
        lineJoin,
        miterLimit
      };
    };
    RegularShape2.prototype.render = function() {
      this.renderOptions_ = this.createRenderOptions();
      var size = this.renderOptions_.size;
      this.canvas_ = {};
      this.size_ = [size, size];
    };
    RegularShape2.prototype.draw_ = function(renderOptions, context, pixelRatio) {
      context.scale(pixelRatio, pixelRatio);
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      if (this.fill_) {
        var color = this.fill_.getColor();
        if (color === null) {
          color = defaultFillStyle;
        }
        context.fillStyle = asColorLike(color);
        context.fill();
      }
      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (context.setLineDash && renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    };
    RegularShape2.prototype.createHitDetectionCanvas_ = function(renderOptions) {
      if (this.fill_) {
        var color = this.fill_.getColor();
        var opacity = 0;
        if (typeof color === "string") {
          color = asArray(color);
        }
        if (color === null) {
          opacity = 1;
        } else if (Array.isArray(color)) {
          opacity = color.length === 4 ? color[3] : 1;
        }
        if (opacity === 0) {
          var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
          this.hitDetectionCanvas_ = context.canvas;
          this.drawHitDetectionCanvas_(renderOptions, context);
        }
      }
      if (!this.hitDetectionCanvas_) {
        this.hitDetectionCanvas_ = this.getImage(1);
      }
    };
    RegularShape2.prototype.createPath_ = function(context) {
      var points = this.points_;
      var radius = this.radius_;
      if (points === Infinity) {
        context.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        var radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
        if (this.radius2_ !== void 0) {
          points *= 2;
        }
        var startAngle = this.angle_ - Math.PI / 2;
        var step = 2 * Math.PI / points;
        for (var i = 0; i < points; i++) {
          var angle0 = startAngle + i * step;
          var radiusC = i % 2 === 0 ? radius : radius2;
          context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
        }
        context.closePath();
      }
    };
    RegularShape2.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      context.fillStyle = defaultFillStyle;
      context.fill();
      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    };
    return RegularShape2;
  }(ImageStyle$1)
);
const RegularShape$1 = RegularShape;
var __extends$2 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CircleStyle = (
  /** @class */
  function(_super) {
    __extends$2(CircleStyle2, _super);
    function CircleStyle2(opt_options) {
      var options = opt_options ? opt_options : {};
      return _super.call(this, {
        points: Infinity,
        fill: options.fill,
        radius: options.radius,
        stroke: options.stroke,
        scale: options.scale !== void 0 ? options.scale : 1,
        rotation: options.rotation !== void 0 ? options.rotation : 0,
        rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
        declutterMode: options.declutterMode
      }) || this;
    }
    CircleStyle2.prototype.clone = function() {
      var scale2 = this.getScale();
      var style2 = new CircleStyle2({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        radius: this.getRadius(),
        scale: Array.isArray(scale2) ? scale2.slice() : scale2,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style2.setOpacity(this.getOpacity());
      return style2;
    };
    CircleStyle2.prototype.setRadius = function(radius) {
      this.radius_ = radius;
      this.render();
    };
    return CircleStyle2;
  }(RegularShape$1)
);
const CircleStyle$1 = CircleStyle;
var Fill = (
  /** @class */
  function() {
    function Fill2(opt_options) {
      var options = opt_options || {};
      this.color_ = options.color !== void 0 ? options.color : null;
    }
    Fill2.prototype.clone = function() {
      var color = this.getColor();
      return new Fill2({
        color: Array.isArray(color) ? color.slice() : color || void 0
      });
    };
    Fill2.prototype.getColor = function() {
      return this.color_;
    };
    Fill2.prototype.setColor = function(color) {
      this.color_ = color;
    };
    return Fill2;
  }()
);
const Fill$1 = Fill;
const IconAnchorUnits = {
  /**
   * Anchor is a fraction
   * @api
   */
  FRACTION: "fraction",
  /**
   * Anchor is in pixels
   * @api
   */
  PIXELS: "pixels"
};
const IconOrigin = {
  /**
   * Origin is at bottom left
   * @api
   */
  BOTTOM_LEFT: "bottom-left",
  /**
   * Origin is at bottom right
   * @api
   */
  BOTTOM_RIGHT: "bottom-right",
  /**
   * Origin is at top left
   * @api
   */
  TOP_LEFT: "top-left",
  /**
   * Origin is at top right
   * @api
   */
  TOP_RIGHT: "top-right"
};
var IconImageCache = (
  /** @class */
  function() {
    function IconImageCache2() {
      this.cache_ = {};
      this.cacheSize_ = 0;
      this.maxCacheSize_ = 32;
    }
    IconImageCache2.prototype.clear = function() {
      this.cache_ = {};
      this.cacheSize_ = 0;
    };
    IconImageCache2.prototype.canExpireCache = function() {
      return this.cacheSize_ > this.maxCacheSize_;
    };
    IconImageCache2.prototype.expire = function() {
      if (this.canExpireCache()) {
        var i = 0;
        for (var key in this.cache_) {
          var iconImage = this.cache_[key];
          if ((i++ & 3) === 0 && !iconImage.hasListener()) {
            delete this.cache_[key];
            --this.cacheSize_;
          }
        }
      }
    };
    IconImageCache2.prototype.get = function(src, crossOrigin, color) {
      var key = getKey(src, crossOrigin, color);
      return key in this.cache_ ? this.cache_[key] : null;
    };
    IconImageCache2.prototype.set = function(src, crossOrigin, color, iconImage) {
      var key = getKey(src, crossOrigin, color);
      this.cache_[key] = iconImage;
      ++this.cacheSize_;
    };
    IconImageCache2.prototype.setSize = function(maxCacheSize) {
      this.maxCacheSize_ = maxCacheSize;
      this.expire();
    };
    return IconImageCache2;
  }()
);
function getKey(src, crossOrigin, color) {
  var colorString = color ? asString(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var shared = new IconImageCache();
var __extends$1 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var taintedTestContext = null;
var IconImage = (
  /** @class */
  function(_super) {
    __extends$1(IconImage2, _super);
    function IconImage2(image, src, size, crossOrigin, imageState, color) {
      var _this = _super.call(this) || this;
      _this.hitDetectionImage_ = null;
      _this.image_ = !image ? new Image() : image;
      if (crossOrigin !== null) {
        _this.image_.crossOrigin = crossOrigin;
      }
      _this.canvas_ = {};
      _this.color_ = color;
      _this.unlisten_ = null;
      _this.imageState_ = imageState;
      _this.size_ = size;
      _this.src_ = src;
      _this.tainted_;
      return _this;
    }
    IconImage2.prototype.isTainted_ = function() {
      if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
        if (!taintedTestContext) {
          taintedTestContext = createCanvasContext2D(1, 1);
        }
        taintedTestContext.drawImage(this.image_, 0, 0);
        try {
          taintedTestContext.getImageData(0, 0, 1, 1);
          this.tainted_ = false;
        } catch (e) {
          taintedTestContext = null;
          this.tainted_ = true;
        }
      }
      return this.tainted_ === true;
    };
    IconImage2.prototype.dispatchChangeEvent_ = function() {
      this.dispatchEvent(EventType.CHANGE);
    };
    IconImage2.prototype.handleImageError_ = function() {
      this.imageState_ = ImageState.ERROR;
      this.unlistenImage_();
      this.dispatchChangeEvent_();
    };
    IconImage2.prototype.handleImageLoad_ = function() {
      this.imageState_ = ImageState.LOADED;
      if (this.size_) {
        this.image_.width = this.size_[0];
        this.image_.height = this.size_[1];
      } else {
        this.size_ = [this.image_.width, this.image_.height];
      }
      this.unlistenImage_();
      this.dispatchChangeEvent_();
    };
    IconImage2.prototype.getImage = function(pixelRatio) {
      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    };
    IconImage2.prototype.getPixelRatio = function(pixelRatio) {
      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? pixelRatio : 1;
    };
    IconImage2.prototype.getImageState = function() {
      return this.imageState_;
    };
    IconImage2.prototype.getHitDetectionImage = function() {
      if (!this.hitDetectionImage_) {
        if (this.isTainted_()) {
          var width = this.size_[0];
          var height = this.size_[1];
          var context = createCanvasContext2D(width, height);
          context.fillRect(0, 0, width, height);
          this.hitDetectionImage_ = context.canvas;
        } else {
          this.hitDetectionImage_ = this.image_;
        }
      }
      return this.hitDetectionImage_;
    };
    IconImage2.prototype.getSize = function() {
      return this.size_;
    };
    IconImage2.prototype.getSrc = function() {
      return this.src_;
    };
    IconImage2.prototype.load = function() {
      if (this.imageState_ == ImageState.IDLE) {
        this.imageState_ = ImageState.LOADING;
        try {
          this.image_.src = this.src_;
        } catch (e) {
          this.handleImageError_();
        }
        this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
      }
    };
    IconImage2.prototype.replaceColor_ = function(pixelRatio) {
      if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {
        return;
      }
      var canvas = document.createElement("canvas");
      this.canvas_[pixelRatio] = canvas;
      canvas.width = Math.ceil(this.image_.width * pixelRatio);
      canvas.height = Math.ceil(this.image_.height * pixelRatio);
      var ctx = canvas.getContext("2d");
      ctx.scale(pixelRatio, pixelRatio);
      ctx.drawImage(this.image_, 0, 0);
      ctx.globalCompositeOperation = "multiply";
      if (ctx.globalCompositeOperation === "multiply" || this.isTainted_()) {
        ctx.fillStyle = asString(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(this.image_, 0, 0);
      } else {
        var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var data = imgData.data;
        var r = this.color_[0] / 255;
        var g = this.color_[1] / 255;
        var b = this.color_[2] / 255;
        var a = this.color_[3];
        for (var i = 0, ii = data.length; i < ii; i += 4) {
          data[i] *= r;
          data[i + 1] *= g;
          data[i + 2] *= b;
          data[i + 3] *= a;
        }
        ctx.putImageData(imgData, 0, 0);
      }
    };
    IconImage2.prototype.unlistenImage_ = function() {
      if (this.unlisten_) {
        this.unlisten_();
        this.unlisten_ = null;
      }
    };
    return IconImage2;
  }(EventTarget)
);
function get(image, src, size, crossOrigin, imageState, color) {
  var iconImage = shared.get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
    shared.set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
}
const IconImage$1 = IconImage;
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Icon = (
  /** @class */
  function(_super) {
    __extends(Icon2, _super);
    function Icon2(opt_options) {
      var _this = this;
      var options = opt_options || {};
      var opacity = options.opacity !== void 0 ? options.opacity : 1;
      var rotation = options.rotation !== void 0 ? options.rotation : 0;
      var scale2 = options.scale !== void 0 ? options.scale : 1;
      var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
      _this = _super.call(this, {
        opacity,
        rotation,
        scale: scale2,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
        rotateWithView,
        declutterMode: options.declutterMode
      }) || this;
      _this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
      _this.normalizedAnchor_ = null;
      _this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : IconOrigin.TOP_LEFT;
      _this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : IconAnchorUnits.FRACTION;
      _this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : IconAnchorUnits.FRACTION;
      _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
      var image = options.img !== void 0 ? options.img : null;
      _this.imgSize_ = options.imgSize;
      var src = options.src;
      assert(!(src !== void 0 && image), 4);
      assert(!image || image && _this.imgSize_, 5);
      if ((src === void 0 || src.length === 0) && image) {
        src = /** @type {HTMLImageElement} */
        image.src || getUid(image);
      }
      assert(src !== void 0 && src.length > 0, 6);
      var imageState = options.src !== void 0 ? ImageState.IDLE : ImageState.LOADED;
      _this.color_ = options.color !== void 0 ? asArray(options.color) : null;
      _this.iconImage_ = get(
        image,
        /** @type {string} */
        src,
        _this.imgSize_ !== void 0 ? _this.imgSize_ : null,
        _this.crossOrigin_,
        imageState,
        _this.color_
      );
      _this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
      _this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : IconOrigin.TOP_LEFT;
      _this.origin_ = null;
      _this.size_ = options.size !== void 0 ? options.size : null;
      return _this;
    }
    Icon2.prototype.clone = function() {
      var scale2 = this.getScale();
      return new Icon2({
        anchor: this.anchor_.slice(),
        anchorOrigin: this.anchorOrigin_,
        anchorXUnits: this.anchorXUnits_,
        anchorYUnits: this.anchorYUnits_,
        color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
        crossOrigin: this.crossOrigin_,
        imgSize: this.imgSize_,
        offset: this.offset_.slice(),
        offsetOrigin: this.offsetOrigin_,
        opacity: this.getOpacity(),
        rotateWithView: this.getRotateWithView(),
        rotation: this.getRotation(),
        scale: Array.isArray(scale2) ? scale2.slice() : scale2,
        size: this.size_ !== null ? this.size_.slice() : void 0,
        src: this.getSrc(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    };
    Icon2.prototype.getAnchor = function() {
      var anchor = this.normalizedAnchor_;
      if (!anchor) {
        anchor = this.anchor_;
        var size = this.getSize();
        if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
          if (!size) {
            return null;
          }
          anchor = this.anchor_.slice();
          if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
            anchor[0] *= size[0];
          }
          if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
            anchor[1] *= size[1];
          }
        }
        if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
          if (!size) {
            return null;
          }
          if (anchor === this.anchor_) {
            anchor = this.anchor_.slice();
          }
          if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
            anchor[0] = -anchor[0] + size[0];
          }
          if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
            anchor[1] = -anchor[1] + size[1];
          }
        }
        this.normalizedAnchor_ = anchor;
      }
      var displacement = this.getDisplacement();
      return [anchor[0] - displacement[0], anchor[1] + displacement[1]];
    };
    Icon2.prototype.setAnchor = function(anchor) {
      this.anchor_ = anchor;
      this.normalizedAnchor_ = null;
    };
    Icon2.prototype.getColor = function() {
      return this.color_;
    };
    Icon2.prototype.getImage = function(pixelRatio) {
      return this.iconImage_.getImage(pixelRatio);
    };
    Icon2.prototype.getPixelRatio = function(pixelRatio) {
      return this.iconImage_.getPixelRatio(pixelRatio);
    };
    Icon2.prototype.getImageSize = function() {
      return this.iconImage_.getSize();
    };
    Icon2.prototype.getImageState = function() {
      return this.iconImage_.getImageState();
    };
    Icon2.prototype.getHitDetectionImage = function() {
      return this.iconImage_.getHitDetectionImage();
    };
    Icon2.prototype.getOrigin = function() {
      if (this.origin_) {
        return this.origin_;
      }
      var offset = this.offset_;
      if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
        var size = this.getSize();
        var iconImageSize = this.iconImage_.getSize();
        if (!size || !iconImageSize) {
          return null;
        }
        offset = offset.slice();
        if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
          offset[0] = iconImageSize[0] - size[0] - offset[0];
        }
        if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
          offset[1] = iconImageSize[1] - size[1] - offset[1];
        }
      }
      this.origin_ = offset;
      return this.origin_;
    };
    Icon2.prototype.getSrc = function() {
      return this.iconImage_.getSrc();
    };
    Icon2.prototype.getSize = function() {
      return !this.size_ ? this.iconImage_.getSize() : this.size_;
    };
    Icon2.prototype.listenImageChange = function(listener) {
      this.iconImage_.addEventListener(EventType.CHANGE, listener);
    };
    Icon2.prototype.load = function() {
      this.iconImage_.load();
    };
    Icon2.prototype.unlistenImageChange = function(listener) {
      this.iconImage_.removeEventListener(EventType.CHANGE, listener);
    };
    return Icon2;
  }(ImageStyle$1)
);
const Icon$1 = Icon;
var Stroke = (
  /** @class */
  function() {
    function Stroke2(opt_options) {
      var options = opt_options || {};
      this.color_ = options.color !== void 0 ? options.color : null;
      this.lineCap_ = options.lineCap;
      this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
      this.lineDashOffset_ = options.lineDashOffset;
      this.lineJoin_ = options.lineJoin;
      this.miterLimit_ = options.miterLimit;
      this.width_ = options.width;
    }
    Stroke2.prototype.clone = function() {
      var color = this.getColor();
      return new Stroke2({
        color: Array.isArray(color) ? color.slice() : color || void 0,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    };
    Stroke2.prototype.getColor = function() {
      return this.color_;
    };
    Stroke2.prototype.getLineCap = function() {
      return this.lineCap_;
    };
    Stroke2.prototype.getLineDash = function() {
      return this.lineDash_;
    };
    Stroke2.prototype.getLineDashOffset = function() {
      return this.lineDashOffset_;
    };
    Stroke2.prototype.getLineJoin = function() {
      return this.lineJoin_;
    };
    Stroke2.prototype.getMiterLimit = function() {
      return this.miterLimit_;
    };
    Stroke2.prototype.getWidth = function() {
      return this.width_;
    };
    Stroke2.prototype.setColor = function(color) {
      this.color_ = color;
    };
    Stroke2.prototype.setLineCap = function(lineCap) {
      this.lineCap_ = lineCap;
    };
    Stroke2.prototype.setLineDash = function(lineDash) {
      this.lineDash_ = lineDash;
    };
    Stroke2.prototype.setLineDashOffset = function(lineDashOffset) {
      this.lineDashOffset_ = lineDashOffset;
    };
    Stroke2.prototype.setLineJoin = function(lineJoin) {
      this.lineJoin_ = lineJoin;
    };
    Stroke2.prototype.setMiterLimit = function(miterLimit) {
      this.miterLimit_ = miterLimit;
    };
    Stroke2.prototype.setWidth = function(width) {
      this.width_ = width;
    };
    return Stroke2;
  }()
);
const Stroke$1 = Stroke;
var Style = (
  /** @class */
  function() {
    function Style2(opt_options) {
      var options = opt_options || {};
      this.geometry_ = null;
      this.geometryFunction_ = defaultGeometryFunction;
      if (options.geometry !== void 0) {
        this.setGeometry(options.geometry);
      }
      this.fill_ = options.fill !== void 0 ? options.fill : null;
      this.image_ = options.image !== void 0 ? options.image : null;
      this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
      this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
      this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      this.text_ = options.text !== void 0 ? options.text : null;
      this.zIndex_ = options.zIndex;
    }
    Style2.prototype.clone = function() {
      var geometry = this.getGeometry();
      if (geometry && typeof geometry === "object") {
        geometry = /** @type {import("../geom/Geometry.js").default} */
        geometry.clone();
      }
      return new Style2({
        geometry,
        fill: this.getFill() ? this.getFill().clone() : void 0,
        image: this.getImage() ? this.getImage().clone() : void 0,
        renderer: this.getRenderer(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        text: this.getText() ? this.getText().clone() : void 0,
        zIndex: this.getZIndex()
      });
    };
    Style2.prototype.getRenderer = function() {
      return this.renderer_;
    };
    Style2.prototype.setRenderer = function(renderer) {
      this.renderer_ = renderer;
    };
    Style2.prototype.setHitDetectionRenderer = function(renderer) {
      this.hitDetectionRenderer_ = renderer;
    };
    Style2.prototype.getHitDetectionRenderer = function() {
      return this.hitDetectionRenderer_;
    };
    Style2.prototype.getGeometry = function() {
      return this.geometry_;
    };
    Style2.prototype.getGeometryFunction = function() {
      return this.geometryFunction_;
    };
    Style2.prototype.getFill = function() {
      return this.fill_;
    };
    Style2.prototype.setFill = function(fill) {
      this.fill_ = fill;
    };
    Style2.prototype.getImage = function() {
      return this.image_;
    };
    Style2.prototype.setImage = function(image) {
      this.image_ = image;
    };
    Style2.prototype.getStroke = function() {
      return this.stroke_;
    };
    Style2.prototype.setStroke = function(stroke) {
      this.stroke_ = stroke;
    };
    Style2.prototype.getText = function() {
      return this.text_;
    };
    Style2.prototype.setText = function(text) {
      this.text_ = text;
    };
    Style2.prototype.getZIndex = function() {
      return this.zIndex_;
    };
    Style2.prototype.setGeometry = function(geometry) {
      if (typeof geometry === "function") {
        this.geometryFunction_ = geometry;
      } else if (typeof geometry === "string") {
        this.geometryFunction_ = function(feature) {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            feature.get(geometry)
          );
        };
      } else if (!geometry) {
        this.geometryFunction_ = defaultGeometryFunction;
      } else if (geometry !== void 0) {
        this.geometryFunction_ = function() {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            geometry
          );
        };
      }
      this.geometry_ = geometry;
    };
    Style2.prototype.setZIndex = function(zIndex) {
      this.zIndex_ = zIndex;
    };
    return Style2;
  }()
);
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
const Style$1 = Style;
var DEFAULT_FILL_COLOR = "#333";
var Text = (
  /** @class */
  function() {
    function Text2(opt_options) {
      var options = opt_options || {};
      this.font_ = options.font;
      this.rotation_ = options.rotation;
      this.rotateWithView_ = options.rotateWithView;
      this.scale_ = options.scale;
      this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
      this.text_ = options.text;
      this.textAlign_ = options.textAlign;
      this.justify_ = options.justify;
      this.textBaseline_ = options.textBaseline;
      this.fill_ = options.fill !== void 0 ? options.fill : new Fill$1({ color: DEFAULT_FILL_COLOR });
      this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
      this.placement_ = options.placement !== void 0 ? options.placement : TextPlacement.POINT;
      this.overflow_ = !!options.overflow;
      this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
      this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
      this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
      this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
      this.padding_ = options.padding === void 0 ? null : options.padding;
    }
    Text2.prototype.clone = function() {
      var scale2 = this.getScale();
      return new Text2({
        font: this.getFont(),
        placement: this.getPlacement(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale2) ? scale2.slice() : scale2,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
        backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
        padding: this.getPadding() || void 0
      });
    };
    Text2.prototype.getOverflow = function() {
      return this.overflow_;
    };
    Text2.prototype.getFont = function() {
      return this.font_;
    };
    Text2.prototype.getMaxAngle = function() {
      return this.maxAngle_;
    };
    Text2.prototype.getPlacement = function() {
      return this.placement_;
    };
    Text2.prototype.getOffsetX = function() {
      return this.offsetX_;
    };
    Text2.prototype.getOffsetY = function() {
      return this.offsetY_;
    };
    Text2.prototype.getFill = function() {
      return this.fill_;
    };
    Text2.prototype.getRotateWithView = function() {
      return this.rotateWithView_;
    };
    Text2.prototype.getRotation = function() {
      return this.rotation_;
    };
    Text2.prototype.getScale = function() {
      return this.scale_;
    };
    Text2.prototype.getScaleArray = function() {
      return this.scaleArray_;
    };
    Text2.prototype.getStroke = function() {
      return this.stroke_;
    };
    Text2.prototype.getText = function() {
      return this.text_;
    };
    Text2.prototype.getTextAlign = function() {
      return this.textAlign_;
    };
    Text2.prototype.getJustify = function() {
      return this.justify_;
    };
    Text2.prototype.getTextBaseline = function() {
      return this.textBaseline_;
    };
    Text2.prototype.getBackgroundFill = function() {
      return this.backgroundFill_;
    };
    Text2.prototype.getBackgroundStroke = function() {
      return this.backgroundStroke_;
    };
    Text2.prototype.getPadding = function() {
      return this.padding_;
    };
    Text2.prototype.setOverflow = function(overflow) {
      this.overflow_ = overflow;
    };
    Text2.prototype.setFont = function(font) {
      this.font_ = font;
    };
    Text2.prototype.setMaxAngle = function(maxAngle) {
      this.maxAngle_ = maxAngle;
    };
    Text2.prototype.setOffsetX = function(offsetX) {
      this.offsetX_ = offsetX;
    };
    Text2.prototype.setOffsetY = function(offsetY) {
      this.offsetY_ = offsetY;
    };
    Text2.prototype.setPlacement = function(placement) {
      this.placement_ = placement;
    };
    Text2.prototype.setRotateWithView = function(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    };
    Text2.prototype.setFill = function(fill) {
      this.fill_ = fill;
    };
    Text2.prototype.setRotation = function(rotation) {
      this.rotation_ = rotation;
    };
    Text2.prototype.setScale = function(scale2) {
      this.scale_ = scale2;
      this.scaleArray_ = toSize(scale2 !== void 0 ? scale2 : 1);
    };
    Text2.prototype.setStroke = function(stroke) {
      this.stroke_ = stroke;
    };
    Text2.prototype.setText = function(text) {
      this.text_ = text;
    };
    Text2.prototype.setTextAlign = function(textAlign) {
      this.textAlign_ = textAlign;
    };
    Text2.prototype.setJustify = function(justify) {
      this.justify_ = justify;
    };
    Text2.prototype.setTextBaseline = function(textBaseline) {
      this.textBaseline_ = textBaseline;
    };
    Text2.prototype.setBackgroundFill = function(fill) {
      this.backgroundFill_ = fill;
    };
    Text2.prototype.setBackgroundStroke = function(stroke) {
      this.backgroundStroke_ = stroke;
    };
    Text2.prototype.setPadding = function(padding) {
      this.padding_ = padding;
    };
    return Text2;
  }()
);
const Text$1 = Text;
const style = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: CircleStyle$1,
  Fill: Fill$1,
  Icon: Icon$1,
  IconImage: IconImage$1,
  Image: ImageStyle$1,
  RegularShape: RegularShape$1,
  Stroke: Stroke$1,
  Style: Style$1,
  Text: Text$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(style);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(transform);
var hasRequiredOLVectorTileProvider;
function requireOLVectorTileProvider() {
  if (hasRequiredOLVectorTileProvider)
    return OLVectorTileProvider;
  hasRequiredOLVectorTileProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(OLVectorTileProvider, "__esModule", {
    value: true
  });
  OLVectorTileProvider.default = void 0;
  var _three2 = require$$8$1;
  var _TileState = _interopRequireDefault2(require$$2$1);
  var _events = require$$3$1;
  var _extent = require$$4$1;
  var _BuilderGroup = _interopRequireDefault2(require$$2);
  var _ExecutorGroup = _interopRequireDefault2(require$$3);
  var _vector3 = require$$4;
  var _style = require$$5;
  var _transform = require$$6;
  var _Extent2 = _interopRequireDefault2(requireExtent());
  var tmpTransform_ = (0, _transform.create)();
  var emptyTexture2 = new _three2.Texture();
  function Foo() {
    var _this = this;
    this.storage = {};
    this.contains = function(tileCoord) {
      return tileCoord in _this.storage;
    };
  }
  function preprocessDataLayer(layer) {
    var source = layer.source;
    var projection = source.getProjection();
    var tileGrid = source.getTileGridForProjection(projection);
    var sizePixel = source.getTilePixelSize(
      0,
      1,
      projection
    );
    layer.imageSize = {
      w: sizePixel[0],
      h: sizePixel[1]
    };
    var extent2 = tileGrid.getExtent();
    layer.extent = fromOLExtent(extent2, projection.getCode());
    layer.getStyleFunction = function() {
      return layer.style(_style.Style, _style.Fill, _style.Stroke, _style.Icon, _style.Text);
    };
    layer.fx = 0;
    layer.usedTiles = {};
  }
  function fromOLExtent(extent2, projectionCode) {
    return new _Extent2.default(projectionCode, extent2[0], extent2[2], extent2[1], extent2[3]);
  }
  function toOLExtent(extent2) {
    return [Math.ceil(extent2.west()), Math.ceil(extent2.south()), Math.floor(extent2.east()), Math.floor(extent2.north())];
  }
  function getPossibleTextureImprovements(layer, extent2, texture) {
    var ex = extent2.as(layer.extent.crs());
    var tile = selectTile(layer, ex);
    if (texture && texture.extent && texture.extent.isInside(tile.tileExtent)) {
      return null;
    }
    if (texture === emptyTexture2) {
      return null;
    }
    return tile;
  }
  function selectTile(layer, extent2) {
    var source = layer.source;
    var projection = source.getProjection();
    var tileGrid = source.getTileGridForProjection(projection);
    var tileCoord = tileCoordForExtent(tileGrid, extent2);
    if (!tileCoord) {
      return null;
    }
    var tile = source.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, projection);
    var zKey = tile.tileCoord[0].toString();
    if (!(zKey in layer.usedTiles)) {
      layer.usedTiles[zKey] = new Foo();
    }
    layer.usedTiles[zKey].storage[tile.tileCoord] = tile;
    var tileExtent = fromOLExtent(tileGrid.getTileCoordExtent(tileCoord), projection.getCode());
    var dim = layer.extent.dimensions();
    var ratio = dim.y / dim.x;
    tileExtent._values[3] = tileExtent._values[2] + tileExtent.dimensions().x * ratio;
    var pitch = extent2.offsetToParent(tileExtent);
    return {
      extent: extent2,
      pitch,
      tile,
      tileExtent
    };
  }
  function tileCoordForExtent(tileGrid, extent2) {
    extent2 = toOLExtent(extent2);
    var minZoom = tileGrid.getMinZoom();
    var maxZoom = tileGrid.getMaxZoom();
    for (var z = maxZoom, tileRange; z >= minZoom; z--) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z, tileRange);
      if (tileRange.getWidth() === 1 && tileRange.getHeight() === 1) {
        return [z, tileRange.minX, tileRange.minY];
      }
    }
    return null;
  }
  function executeCommand(command) {
    return loadTile(command.requester, command.toDownload, command.layer);
  }
  function loadTile(node, tile, layer) {
    var promise;
    var imageTile = tile.tile;
    if (imageTile.getState() === _TileState.default.LOADED) {
      promise = Promise.resolve(createTexture(node, tile, layer));
    } else {
      promise = new Promise(function(resolve, reject) {
        imageTile.load();
        (0, _events.listenOnce)(imageTile, "change", function(evt) {
          var imageTile2 = evt.target;
          var tileState = imageTile2.getState();
          if (tileState === _TileState.default.ERROR) {
            reject();
          } else if (tileState === _TileState.default.LOADED) {
            resolve(createTexture(node, tile, layer));
          }
        });
      });
    }
    return promise;
  }
  function createTexture(node, tile, layer) {
    if (!node.material) {
      return null;
    }
    var _canvas2 = node.material.canvas;
    var texture = new _three2.CanvasTexture(_canvas2);
    texture.premultiplyAlpha = layer.transparent;
    texture.extent = tile.tileExtent;
    var empty = createBuilderGroup(tile.tile, layer);
    if (empty) {
      return {
        texture,
        pitch: new _three2.Vector4(0, 0, 0, 0)
      };
    }
    var atlas = node.layer.atlasInfo.atlas[layer.id];
    renderTileImage(_canvas2, tile.tile, atlas, layer);
    var zKey = tile.tile.tileCoord[0].toString();
    delete layer.usedTiles[zKey].storage[tile.tile.tileCoord];
    layer.source.tileCache.expireCache(layer.usedTiles);
    return {
      texture,
      pitch: tile.pitch
    };
  }
  function createBuilderGroup(tile, layer) {
    var _this2 = this;
    var replayState = tile.getReplayState(layer);
    var source = layer.source;
    var sourceTileGrid = source.getTileGrid();
    var sourceProjection = source.getProjection();
    var tileGrid = source.getTileGridForProjection(sourceProjection);
    var resolution = tileGrid.getResolution(tile.tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var pixelRatio = 1;
    var tmpExtent2 = (0, _extent.createEmpty)();
    var empty = true;
    tile.executorGroups[layer.ol_uid] = [];
    var sourceTiles = source.getSourceTiles(pixelRatio, sourceProjection, tile);
    var _loop = function _loop2(t2, tt2) {
      var sourceTile = sourceTiles[t2];
      if (sourceTile.getState() !== _TileState.default.LOADED) {
        console.warn("not loaded !!!", sourceTile);
        return "continue";
      }
      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = (0, _extent.getIntersection)(tileExtent, sourceTileExtent);
      var renderBuffer = 100;
      var builderExtent = (0, _extent.buffer)(sharedExtent, renderBuffer * resolution, tmpExtent2);
      var bufferedExtent = (0, _extent.equals)(sourceTileExtent, sharedExtent) ? null : builderExtent;
      var builderGroup = new _BuilderGroup.default(0, builderExtent, resolution, pixelRatio);
      var squaredTolerance = (0, _vector3.getSquaredTolerance)(resolution, pixelRatio);
      var render2 = function render3(feature2) {
        var styles;
        var styleFunction = feature2.getStyleFunction() || layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature2, resolution);
        }
        if (styles) {
          var dirty = renderFeature2(feature2, squaredTolerance, styles, builderGroup);
          replayState.dirty = replayState.dirty || dirty;
        }
      };
      var features = sourceTile.getFeatures();
      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];
        if (!bufferedExtent || (0, _extent.intersects)(bufferedExtent, feature.getGeometry().getExtent())) {
          render2.call(_this2, feature);
        }
        empty = false;
      }
      if (!empty) {
        var renderingReplayGroup = new _ExecutorGroup.default(builderExtent, resolution, pixelRatio, source.getOverlaps(), builderGroup.finish(), renderBuffer);
        tile.executorGroups[layer.ol_uid].push(renderingReplayGroup);
      }
    };
    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {
      var _ret = _loop(t);
      if (_ret === "continue")
        continue;
    }
    replayState.renderedRevision = 1;
    replayState.renderedRenderOrder = null;
    return empty;
  }
  function renderFeature2(feature, squaredTolerance, styles, builderGroup) {
    if (!styles) {
      return false;
    }
    var loading2 = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading2 = (0, _vector3.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, handleStyleImageChange_, void 0) || loading2;
      }
    } else {
      loading2 = (0, _vector3.renderFeature)(builderGroup, feature, styles, squaredTolerance, handleStyleImageChange_, void 0);
    }
    return loading2;
  }
  function handleStyleImageChange_() {
  }
  function renderTileImage(_canvas2, tile, atlasInfo, layer) {
    var pixelRatio = 1;
    var replayState = tile.getReplayState(layer);
    var revision = 1;
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var source = layer.source;
    var tileGrid = source.getTileGridForProjection(source.getProjection());
    var resolution = tileGrid.getResolution(z);
    var ctx = _canvas2.getContext("2d");
    ctx.save();
    ctx.translate(atlasInfo.x, atlasInfo.y);
    ctx.clearRect(0, 0, layer.imageSize.w, layer.imageSize.h + 2 * atlasInfo.offset);
    ctx.beginPath();
    ctx.rect(0, 0, layer.imageSize.w, layer.imageSize.h + 2 * atlasInfo.offset);
    ctx.clip();
    if (layer.backgroundColor) {
      ctx.fillStyle = layer.backgroundColor;
      ctx.fillRect(0, 0, layer.imageSize.w, layer.imageSize.h + 2 * atlasInfo.offset);
    }
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
    var pixelScale = pixelRatio / resolution;
    var transform2 = (0, _transform.reset)(tmpTransform_);
    (0, _transform.scale)(transform2, pixelScale, -pixelScale);
    (0, _transform.translate)(transform2, -tileExtent[0], -tileExtent[3]);
    var executorGroups = tile.executorGroups[layer.ol_uid];
    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {
      var executorGroup = executorGroups[i];
      executorGroup.execute(ctx, 1, transform2, 0, true);
    }
    ctx.restore();
  }
  function tileTextureCount(tile, layer) {
    return 1;
  }
  function tileInsideLimit(tile, layer) {
    var extent2 = tile.getExtentForLayer(layer).as(layer.extent.crs());
    return extent2.isInside(layer.extent);
  }
  var _default2 = {
    preprocessDataLayer,
    executeCommand,
    tileTextureCount,
    tileInsideLimit,
    getPossibleTextureImprovements
  };
  OLVectorTileProvider.default = _default2;
  return OLVectorTileProvider;
}
var OLVectorProvider = {};
var hasRequiredOLVectorProvider;
function requireOLVectorProvider() {
  if (hasRequiredOLVectorProvider)
    return OLVectorProvider;
  hasRequiredOLVectorProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(OLVectorProvider, "__esModule", {
    value: true
  });
  OLVectorProvider.default = void 0;
  var _three2 = require$$8$1;
  var _BuilderGroup = _interopRequireDefault2(require$$2);
  var _ExecutorGroup = _interopRequireDefault2(require$$3);
  var _vector3 = require$$4;
  var _style = require$$5;
  var _transform = require$$6;
  var _Extent2 = _interopRequireDefault2(requireExtent());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function fromOLExtent(extent2, projectionCode) {
    return new _Extent2.default(projectionCode, extent2[0], extent2[2], extent2[1], extent2[3]);
  }
  var emptyTexture2 = new _three2.Texture();
  emptyTexture2.empty = true;
  var tmpTransform_ = (0, _transform.create)();
  function preprocessDataLayer(layer) {
    layer.imageSize = {
      w: 256,
      h: 256
    };
    var format = layer.source.getFormat();
    if (format && format.dataProjection.getCode() !== layer.projection) {
      var _iterator = _createForOfIteratorHelper2(layer.source.getFeatures()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var f = _step.value;
          f.getGeometry().transform(layer.source.getFormat().dataProjection.getCode(), layer.projection);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      layer.source.on("addfeature", function(evt) {
        var frmt = layer.source.getFormat();
        if (frmt) {
          evt.feature.getGeometry().transform(frmt.dataProjection.getCode(), layer.projection);
        }
      });
    }
    layer.getStyleFunction = function() {
      return layer.style(_style.Style, _style.Fill, _style.Stroke, _style.Icon, _style.Text);
    };
  }
  function toOLExtent(extent2) {
    return [Math.floor(extent2.west()), Math.floor(extent2.south()), Math.ceil(extent2.east()), Math.ceil(extent2.north())];
  }
  function getPossibleTextureImprovements(layer, extent2, texture) {
    if (texture && texture.extent && texture.extent.isInside(extent2) && texture.revision === layer.source.getRevision()) {
      return null;
    }
    var layerExtent = fromOLExtent(layer.source.getExtent(), layer.projection);
    if (extent2.intersectsExtent(layerExtent)) {
      return extent2;
    }
    if (texture && texture.empty) {
      return null;
    }
    return extent2;
  }
  function executeCommand(command) {
    return createTexture(command.requester, command.toDownload, command.layer);
  }
  function createTexture(node, extent2, layer) {
    var layerExtent = fromOLExtent(layer.source.getExtent(), layer.projection);
    if (!extent2.intersectsExtent(layerExtent)) {
      return Promise.resolve({
        texture: emptyTexture2,
        pitch: new _three2.Vector4(0, 0, 0, 0)
      });
    }
    var builderGroup = createBuilderGroup(extent2, layer);
    var texture;
    var pitch;
    if (!builderGroup) {
      texture = new _three2.Texture();
      pitch = new _three2.Vector4(0, 0, 0, 0);
    } else {
      var _canvas2 = node.material.canvas;
      var atlas = node.layer.atlasInfo.atlas[layer.id];
      renderTileImage(_canvas2, builderGroup, extent2, atlas, layer);
      texture = new _three2.CanvasTexture(_canvas2);
      pitch = new _three2.Vector4(0, 0, 1, 1);
    }
    texture.extent = extent2;
    texture.revision = layer.source.getRevision();
    return Promise.resolve({
      texture,
      pitch
    });
  }
  function createBuilderGroup(extent2, layer) {
    var source = layer.source;
    var pixelRatio = 1;
    var resolution = extent2.dimensions().x / layer.imageSize.w;
    var olExtent = toOLExtent(extent2);
    var builderGroup = new _BuilderGroup.default(0, olExtent, resolution, pixelRatio);
    var squaredTolerance = (0, _vector3.getSquaredTolerance)(resolution, pixelRatio);
    var used = false;
    source.forEachFeatureInExtent(olExtent, function(feature) {
      var styles;
      var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
      if (styles) {
        renderFeature2(feature, squaredTolerance, styles, builderGroup);
      }
      used = true;
    }, this);
    if (used) {
      return builderGroup;
    }
    return null;
  }
  function renderFeature2(feature, squaredTolerance, styles, builderGroup) {
    if (!styles) {
      return false;
    }
    var loading2 = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading2 = (0, _vector3.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, handleStyleImageChange_) || loading2;
      }
    } else {
      loading2 = (0, _vector3.renderFeature)(builderGroup, feature, styles, squaredTolerance, handleStyleImageChange_);
    }
    return loading2;
  }
  function handleStyleImageChange_() {
  }
  function renderTileImage(_canvas2, builderGroup, extent2, atlasInfo, layer) {
    var pixelRatio = 1;
    var resolutionX = extent2.dimensions().x / layer.imageSize.w;
    var resolutionY = extent2.dimensions().y / layer.imageSize.h;
    var ctx = _canvas2.getContext("2d");
    ctx.save();
    ctx.translate(atlasInfo.x, atlasInfo.y);
    ctx.clearRect(0, 0, layer.imageSize.w, layer.imageSize.h + 2 * atlasInfo.offset);
    ctx.beginPath();
    ctx.rect(0, 0, layer.imageSize.w, layer.imageSize.h + 2 * atlasInfo.offset);
    ctx.clip();
    var transform2 = (0, _transform.reset)(tmpTransform_);
    (0, _transform.scale)(transform2, pixelRatio / resolutionX, -pixelRatio / resolutionY);
    (0, _transform.translate)(transform2, -extent2.west(), -extent2.north());
    var olExtent = toOLExtent(extent2);
    var resolution = extent2.dimensions().x / layer.imageSize.w;
    var executor = new _ExecutorGroup.default(olExtent, resolution, pixelRatio, true, builderGroup.finish());
    executor.execute(ctx, 1, transform2, 0, true);
    ctx.restore();
  }
  function tileTextureCount() {
    return 1;
  }
  function tileInsideLimit() {
    return true;
  }
  var _default2 = {
    preprocessDataLayer,
    executeCommand,
    tileTextureCount,
    tileInsideLimit,
    getPossibleTextureImprovements
  };
  OLVectorProvider.default = _default2;
  return OLVectorProvider;
}
var COGProvider = {};
var regeneratorRuntimeExports = {};
var regeneratorRuntime$1 = {
  get exports() {
    return regeneratorRuntimeExports;
  },
  set exports(v) {
    regeneratorRuntimeExports = v;
  }
};
var hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  if (hasRequiredRegeneratorRuntime)
    return regeneratorRuntimeExports;
  hasRequiredRegeneratorRuntime = 1;
  (function(module) {
    var _typeof2 = _typeofExports["default"];
    function _regeneratorRuntime() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
        return generator._invoke = function(innerFn2, self3, context2) {
          var state = "suspendedStart";
          return function(method, arg) {
            if ("executing" === state)
              throw new Error("Generator is already running");
            if ("completed" === state) {
              if ("throw" === method)
                throw arg;
              return doneResult();
            }
            for (context2.method = method, context2.arg = arg; ; ) {
              var delegate = context2.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context2);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if ("next" === context2.method)
                context2.sent = context2._sent = context2.arg;
              else if ("throw" === context2.method) {
                if ("suspendedStart" === state)
                  throw state = "completed", context2.arg;
                context2.dispatchException(context2.arg);
              } else
                "return" === context2.method && context2.abrupt("return", context2.arg);
              state = "executing";
              var record = tryCatch(innerFn2, self3, context2);
              if ("normal" === record.type) {
                if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                  continue;
                return {
                  value: record.arg,
                  done: context2.done
                };
              }
              "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
            }
          };
        }(innerFn, self2, context), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        this._invoke = function(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (void 0 === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method))
              return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context2(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; ) {
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              }
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context2.prototype = {
        constructor: Context2,
        reset: function reset2(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this) {
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
            }
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);
  return regeneratorRuntimeExports;
}
var regenerator;
var hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator)
    return regenerator;
  hasRequiredRegenerator = 1;
  var runtime = requireRegeneratorRuntime()();
  regenerator = runtime;
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  return regenerator;
}
var asyncToGeneratorExports = {};
var asyncToGenerator = {
  get exports() {
    return asyncToGeneratorExports;
  },
  set exports(v) {
    asyncToGeneratorExports = v;
  }
};
var hasRequiredAsyncToGenerator;
function requireAsyncToGenerator() {
  if (hasRequiredAsyncToGenerator)
    return asyncToGeneratorExports;
  hasRequiredAsyncToGenerator = 1;
  (function(module) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(asyncToGenerator);
  return asyncToGeneratorExports;
}
var geotiff = {};
var geotiffimage = {};
var lib = {};
var Float16Array = {};
var arrayIterator = {};
var primordials = {};
var messages$1 = {};
var hasRequiredMessages$1;
function requireMessages$1() {
  if (hasRequiredMessages$1)
    return messages$1;
  hasRequiredMessages$1 = 1;
  Object.defineProperty(messages$1, "__esModule", {
    value: true
  });
  const THIS_IS_NOT_AN_OBJECT = "This is not an object";
  messages$1.THIS_IS_NOT_AN_OBJECT = THIS_IS_NOT_AN_OBJECT;
  const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = "This is not a Float16Array object";
  messages$1.THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT;
  const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY = "This constructor is not a subclass of Float16Array";
  messages$1.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY = THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY;
  const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT = "The constructor property value is not an object";
  messages$1.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT = THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT;
  const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT = "Species constructor didn't return TypedArray object";
  messages$1.SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT = SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT;
  const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH = "Derived constructor created TypedArray object which was too small length";
  messages$1.DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH = DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH;
  const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER = "Attempting to access detached ArrayBuffer";
  messages$1.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER = ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER;
  const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT = "Cannot convert undefined or null to object";
  messages$1.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT = CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT;
  const CANNOT_MIX_BIGINT_AND_OTHER_TYPES = "Cannot mix BigInt and other types, use explicit conversions";
  messages$1.CANNOT_MIX_BIGINT_AND_OTHER_TYPES = CANNOT_MIX_BIGINT_AND_OTHER_TYPES;
  const ITERATOR_PROPERTY_IS_NOT_CALLABLE = "@@iterator property is not callable";
  messages$1.ITERATOR_PROPERTY_IS_NOT_CALLABLE = ITERATOR_PROPERTY_IS_NOT_CALLABLE;
  const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE = "Reduce of empty array with no initial value";
  messages$1.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE = REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE;
  const OFFSET_IS_OUT_OF_BOUNDS = "Offset is out of bounds";
  messages$1.OFFSET_IS_OUT_OF_BOUNDS = OFFSET_IS_OUT_OF_BOUNDS;
  return messages$1;
}
var hasRequiredPrimordials;
function requirePrimordials() {
  if (hasRequiredPrimordials)
    return primordials;
  hasRequiredPrimordials = 1;
  Object.defineProperty(primordials, "__esModule", {
    value: true
  });
  var _messages = requireMessages$1();
  function uncurryThis(target) {
    return (thisArg, ...args) => {
      return ReflectApply(target, thisArg, args);
    };
  }
  function uncurryThisGetter(target, key) {
    return uncurryThis(ReflectGetOwnPropertyDescriptor(target, key).get);
  }
  const {
    apply: ReflectApply,
    construct: ReflectConstruct,
    defineProperty: ReflectDefineProperty,
    get: ReflectGet,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,
    getPrototypeOf: ReflectGetPrototypeOf,
    has: ReflectHas,
    ownKeys: ReflectOwnKeys,
    set: ReflectSet,
    setPrototypeOf: ReflectSetPrototypeOf
  } = Reflect;
  primordials.ReflectSetPrototypeOf = ReflectSetPrototypeOf;
  primordials.ReflectSet = ReflectSet;
  primordials.ReflectOwnKeys = ReflectOwnKeys;
  primordials.ReflectHas = ReflectHas;
  primordials.ReflectGetPrototypeOf = ReflectGetPrototypeOf;
  primordials.ReflectGetOwnPropertyDescriptor = ReflectGetOwnPropertyDescriptor;
  primordials.ReflectGet = ReflectGet;
  primordials.ReflectDefineProperty = ReflectDefineProperty;
  primordials.ReflectConstruct = ReflectConstruct;
  primordials.ReflectApply = ReflectApply;
  const NativeProxy = Proxy;
  primordials.NativeProxy = NativeProxy;
  const {
    MAX_SAFE_INTEGER,
    isFinite: NumberIsFinite,
    isNaN: NumberIsNaN
  } = Number;
  primordials.NumberIsNaN = NumberIsNaN;
  primordials.NumberIsFinite = NumberIsFinite;
  primordials.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
  const {
    iterator: SymbolIterator,
    species: SymbolSpecies,
    toStringTag: SymbolToStringTag,
    for: SymbolFor
  } = Symbol;
  primordials.SymbolFor = SymbolFor;
  primordials.SymbolToStringTag = SymbolToStringTag;
  primordials.SymbolSpecies = SymbolSpecies;
  primordials.SymbolIterator = SymbolIterator;
  const NativeObject = Object;
  primordials.NativeObject = NativeObject;
  const {
    create: ObjectCreate,
    defineProperty: ObjectDefineProperty,
    freeze: ObjectFreeze,
    is: ObjectIs
  } = NativeObject;
  primordials.ObjectIs = ObjectIs;
  primordials.ObjectFreeze = ObjectFreeze;
  primordials.ObjectDefineProperty = ObjectDefineProperty;
  primordials.ObjectCreate = ObjectCreate;
  const ObjectPrototype = NativeObject.prototype;
  const ObjectPrototype__lookupGetter__ = ObjectPrototype.__lookupGetter__ ? uncurryThis(ObjectPrototype.__lookupGetter__) : (object, key) => {
    if (object == null) {
      throw NativeTypeError(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);
    }
    let target = NativeObject(object);
    do {
      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);
      if (descriptor !== void 0) {
        if (ObjectHasOwn(descriptor, "get")) {
          return descriptor.get;
        }
        return;
      }
    } while ((target = ReflectGetPrototypeOf(target)) !== null);
  };
  primordials.ObjectPrototype__lookupGetter__ = ObjectPrototype__lookupGetter__;
  const ObjectHasOwn = NativeObject.hasOwn || uncurryThis(ObjectPrototype.hasOwnProperty);
  primordials.ObjectHasOwn = ObjectHasOwn;
  const NativeArray = Array;
  const ArrayIsArray = NativeArray.isArray;
  primordials.ArrayIsArray = ArrayIsArray;
  const ArrayPrototype = NativeArray.prototype;
  const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);
  primordials.ArrayPrototypeJoin = ArrayPrototypeJoin;
  const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);
  primordials.ArrayPrototypePush = ArrayPrototypePush;
  const ArrayPrototypeToLocaleString = uncurryThis(ArrayPrototype.toLocaleString);
  primordials.ArrayPrototypeToLocaleString = ArrayPrototypeToLocaleString;
  const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];
  primordials.NativeArrayPrototypeSymbolIterator = NativeArrayPrototypeSymbolIterator;
  const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);
  primordials.ArrayPrototypeSymbolIterator = ArrayPrototypeSymbolIterator;
  const MathTrunc = Math.trunc;
  primordials.MathTrunc = MathTrunc;
  const NativeArrayBuffer = ArrayBuffer;
  primordials.NativeArrayBuffer = NativeArrayBuffer;
  const ArrayBufferIsView = NativeArrayBuffer.isView;
  primordials.ArrayBufferIsView = ArrayBufferIsView;
  const ArrayBufferPrototype = NativeArrayBuffer.prototype;
  const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);
  primordials.ArrayBufferPrototypeSlice = ArrayBufferPrototypeSlice;
  const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, "byteLength");
  primordials.ArrayBufferPrototypeGetByteLength = ArrayBufferPrototypeGetByteLength;
  const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : null;
  primordials.NativeSharedArrayBuffer = NativeSharedArrayBuffer;
  const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer && uncurryThisGetter(NativeSharedArrayBuffer.prototype, "byteLength");
  primordials.SharedArrayBufferPrototypeGetByteLength = SharedArrayBufferPrototypeGetByteLength;
  const TypedArray = ReflectGetPrototypeOf(Uint8Array);
  primordials.TypedArray = TypedArray;
  const TypedArrayFrom = TypedArray.from;
  const TypedArrayPrototype = TypedArray.prototype;
  primordials.TypedArrayPrototype = TypedArrayPrototype;
  const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];
  primordials.NativeTypedArrayPrototypeSymbolIterator = NativeTypedArrayPrototypeSymbolIterator;
  const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);
  primordials.TypedArrayPrototypeKeys = TypedArrayPrototypeKeys;
  const TypedArrayPrototypeValues = uncurryThis(TypedArrayPrototype.values);
  primordials.TypedArrayPrototypeValues = TypedArrayPrototypeValues;
  const TypedArrayPrototypeEntries = uncurryThis(TypedArrayPrototype.entries);
  primordials.TypedArrayPrototypeEntries = TypedArrayPrototypeEntries;
  const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);
  primordials.TypedArrayPrototypeSet = TypedArrayPrototypeSet;
  const TypedArrayPrototypeReverse = uncurryThis(TypedArrayPrototype.reverse);
  primordials.TypedArrayPrototypeReverse = TypedArrayPrototypeReverse;
  const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);
  primordials.TypedArrayPrototypeFill = TypedArrayPrototypeFill;
  const TypedArrayPrototypeCopyWithin = uncurryThis(TypedArrayPrototype.copyWithin);
  primordials.TypedArrayPrototypeCopyWithin = TypedArrayPrototypeCopyWithin;
  const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);
  primordials.TypedArrayPrototypeSort = TypedArrayPrototypeSort;
  const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);
  primordials.TypedArrayPrototypeSlice = TypedArrayPrototypeSlice;
  const TypedArrayPrototypeSubarray = uncurryThis(TypedArrayPrototype.subarray);
  primordials.TypedArrayPrototypeSubarray = TypedArrayPrototypeSubarray;
  const TypedArrayPrototypeGetBuffer = uncurryThisGetter(TypedArrayPrototype, "buffer");
  primordials.TypedArrayPrototypeGetBuffer = TypedArrayPrototypeGetBuffer;
  const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(TypedArrayPrototype, "byteOffset");
  primordials.TypedArrayPrototypeGetByteOffset = TypedArrayPrototypeGetByteOffset;
  const TypedArrayPrototypeGetLength = uncurryThisGetter(TypedArrayPrototype, "length");
  primordials.TypedArrayPrototypeGetLength = TypedArrayPrototypeGetLength;
  const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(TypedArrayPrototype, SymbolToStringTag);
  primordials.TypedArrayPrototypeGetSymbolToStringTag = TypedArrayPrototypeGetSymbolToStringTag;
  const NativeUint16Array = Uint16Array;
  primordials.NativeUint16Array = NativeUint16Array;
  const Uint16ArrayFrom = (...args) => {
    return ReflectApply(TypedArrayFrom, NativeUint16Array, args);
  };
  primordials.Uint16ArrayFrom = Uint16ArrayFrom;
  const NativeUint32Array = Uint32Array;
  primordials.NativeUint32Array = NativeUint32Array;
  const NativeFloat32Array = Float32Array;
  primordials.NativeFloat32Array = NativeFloat32Array;
  const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());
  primordials.ArrayIteratorPrototype = ArrayIteratorPrototype;
  const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);
  primordials.ArrayIteratorPrototypeNext = ArrayIteratorPrototypeNext;
  const GeneratorPrototypeNext = uncurryThis(function* () {
  }().next);
  primordials.GeneratorPrototypeNext = GeneratorPrototypeNext;
  const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);
  primordials.IteratorPrototype = IteratorPrototype;
  const DataViewPrototype = DataView.prototype;
  const DataViewPrototypeGetUint16 = uncurryThis(DataViewPrototype.getUint16);
  primordials.DataViewPrototypeGetUint16 = DataViewPrototypeGetUint16;
  const DataViewPrototypeSetUint16 = uncurryThis(DataViewPrototype.setUint16);
  primordials.DataViewPrototypeSetUint16 = DataViewPrototypeSetUint16;
  const NativeTypeError = TypeError;
  primordials.NativeTypeError = NativeTypeError;
  const NativeRangeError = RangeError;
  primordials.NativeRangeError = NativeRangeError;
  const NativeWeakSet = WeakSet;
  primordials.NativeWeakSet = NativeWeakSet;
  const WeakSetPrototype = NativeWeakSet.prototype;
  const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);
  primordials.WeakSetPrototypeAdd = WeakSetPrototypeAdd;
  const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);
  primordials.WeakSetPrototypeHas = WeakSetPrototypeHas;
  const NativeWeakMap = WeakMap;
  primordials.NativeWeakMap = NativeWeakMap;
  const WeakMapPrototype = NativeWeakMap.prototype;
  const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);
  primordials.WeakMapPrototypeGet = WeakMapPrototypeGet;
  const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);
  primordials.WeakMapPrototypeHas = WeakMapPrototypeHas;
  const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);
  primordials.WeakMapPrototypeSet = WeakMapPrototypeSet;
  return primordials;
}
var hasRequiredArrayIterator;
function requireArrayIterator() {
  if (hasRequiredArrayIterator)
    return arrayIterator;
  hasRequiredArrayIterator = 1;
  Object.defineProperty(arrayIterator, "__esModule", {
    value: true
  });
  arrayIterator.safeIfNeeded = safeIfNeeded;
  arrayIterator.wrap = wrap;
  var _primordials = requirePrimordials();
  const arrayIterators = new _primordials.NativeWeakMap();
  const SafeIteratorPrototype = (0, _primordials.ObjectCreate)(null, {
    next: {
      value: function next() {
        const arrayIterator2 = (0, _primordials.WeakMapPrototypeGet)(arrayIterators, this);
        return (0, _primordials.ArrayIteratorPrototypeNext)(arrayIterator2);
      }
    },
    [_primordials.SymbolIterator]: {
      value: function values() {
        return this;
      }
    }
  });
  function safeIfNeeded(array) {
    if (array[_primordials.SymbolIterator] === _primordials.NativeArrayPrototypeSymbolIterator) {
      return array;
    }
    const safe = (0, _primordials.ObjectCreate)(SafeIteratorPrototype);
    (0, _primordials.WeakMapPrototypeSet)(arrayIterators, safe, (0, _primordials.ArrayPrototypeSymbolIterator)(array));
    return safe;
  }
  const generators = new _primordials.NativeWeakMap();
  const DummyArrayIteratorPrototype = (0, _primordials.ObjectCreate)(_primordials.IteratorPrototype, {
    next: {
      value: function next() {
        const generator = (0, _primordials.WeakMapPrototypeGet)(generators, this);
        return (0, _primordials.GeneratorPrototypeNext)(generator);
      },
      writable: true,
      configurable: true
    }
  });
  for (const key of (0, _primordials.ReflectOwnKeys)(_primordials.ArrayIteratorPrototype)) {
    if (key === "next") {
      continue;
    }
    (0, _primordials.ObjectDefineProperty)(DummyArrayIteratorPrototype, key, (0, _primordials.ReflectGetOwnPropertyDescriptor)(_primordials.ArrayIteratorPrototype, key));
  }
  function wrap(generator) {
    const dummy = (0, _primordials.ObjectCreate)(DummyArrayIteratorPrototype);
    (0, _primordials.WeakMapPrototypeSet)(generators, dummy, generator);
    return dummy;
  }
  return arrayIterator;
}
var brand = {};
var is = {};
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs)
    return is;
  hasRequiredIs = 1;
  Object.defineProperty(is, "__esModule", {
    value: true
  });
  is.isArrayBuffer = isArrayBuffer;
  is.isCanonicalIntegerIndexString = isCanonicalIntegerIndexString;
  is.isNativeBigIntTypedArray = isNativeBigIntTypedArray;
  is.isNativeTypedArray = isNativeTypedArray;
  is.isObject = isObject;
  is.isObjectLike = isObjectLike;
  is.isOrdinaryArray = isOrdinaryArray;
  is.isOrdinaryNativeTypedArray = isOrdinaryNativeTypedArray;
  is.isSharedArrayBuffer = isSharedArrayBuffer;
  var _primordials = requirePrimordials();
  function isObject(value) {
    return value !== null && typeof value === "object" || typeof value === "function";
  }
  function isObjectLike(value) {
    return value !== null && typeof value === "object";
  }
  function isNativeTypedArray(value) {
    return (0, _primordials.TypedArrayPrototypeGetSymbolToStringTag)(value) !== void 0;
  }
  function isNativeBigIntTypedArray(value) {
    const typedArrayName = (0, _primordials.TypedArrayPrototypeGetSymbolToStringTag)(value);
    return typedArrayName === "BigInt64Array" || typedArrayName === "BigUint64Array";
  }
  function isArrayBuffer(value) {
    try {
      (0, _primordials.ArrayBufferPrototypeGetByteLength)(value);
      return true;
    } catch (e) {
      return false;
    }
  }
  function isSharedArrayBuffer(value) {
    if (_primordials.NativeSharedArrayBuffer === null) {
      return false;
    }
    try {
      (0, _primordials.SharedArrayBufferPrototypeGetByteLength)(value);
      return true;
    } catch (e) {
      return false;
    }
  }
  function isOrdinaryArray(value) {
    if (!(0, _primordials.ArrayIsArray)(value)) {
      return false;
    }
    if (value[_primordials.SymbolIterator] === _primordials.NativeArrayPrototypeSymbolIterator) {
      return true;
    }
    const iterator = value[_primordials.SymbolIterator]();
    return iterator[_primordials.SymbolToStringTag] === "Array Iterator";
  }
  function isOrdinaryNativeTypedArray(value) {
    if (!isNativeTypedArray(value)) {
      return false;
    }
    if (value[_primordials.SymbolIterator] === _primordials.NativeTypedArrayPrototypeSymbolIterator) {
      return true;
    }
    const iterator = value[_primordials.SymbolIterator]();
    return iterator[_primordials.SymbolToStringTag] === "Array Iterator";
  }
  function isCanonicalIntegerIndexString(value) {
    if (typeof value !== "string") {
      return false;
    }
    const number = +value;
    if (value !== number + "") {
      return false;
    }
    if (!(0, _primordials.NumberIsFinite)(number)) {
      return false;
    }
    return number === (0, _primordials.MathTrunc)(number);
  }
  return is;
}
var hasRequiredBrand;
function requireBrand() {
  if (hasRequiredBrand)
    return brand;
  hasRequiredBrand = 1;
  Object.defineProperty(brand, "__esModule", {
    value: true
  });
  brand.hasFloat16ArrayBrand = hasFloat16ArrayBrand;
  var _is = requireIs();
  var _messages = requireMessages$1();
  var _primordials = requirePrimordials();
  const brand$1 = (0, _primordials.SymbolFor)("__Float16Array__");
  brand.brand = brand$1;
  function hasFloat16ArrayBrand(target) {
    if (!(0, _is.isObjectLike)(target)) {
      return false;
    }
    const prototype = (0, _primordials.ReflectGetPrototypeOf)(target);
    if (!(0, _is.isObjectLike)(prototype)) {
      return false;
    }
    const constructor = prototype.constructor;
    if (constructor === void 0) {
      return false;
    }
    if (!(0, _is.isObject)(constructor)) {
      throw (0, _primordials.NativeTypeError)(_messages.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);
    }
    return (0, _primordials.ReflectHas)(constructor, brand$1);
  }
  return brand;
}
var converter = {};
var hasRequiredConverter;
function requireConverter() {
  if (hasRequiredConverter)
    return converter;
  hasRequiredConverter = 1;
  Object.defineProperty(converter, "__esModule", {
    value: true
  });
  converter.convertToNumber = convertToNumber;
  converter.roundToFloat16Bits = roundToFloat16Bits;
  var _primordials = requirePrimordials();
  const buffer2 = new _primordials.NativeArrayBuffer(4);
  const floatView = new _primordials.NativeFloat32Array(buffer2);
  const uint32View = new _primordials.NativeUint32Array(buffer2);
  const baseTable = new _primordials.NativeUint32Array(512);
  const shiftTable = new _primordials.NativeUint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      baseTable[i] = 0;
      baseTable[i | 256] = 32768;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else if (e < -14) {
      baseTable[i] = 1024 >> -e - 14;
      baseTable[i | 256] = 1024 >> -e - 14 | 32768;
      shiftTable[i] = -e - 1;
      shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 256] = e + 15 << 10 | 32768;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    } else if (e < 128) {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    }
  }
  function roundToFloat16Bits(num) {
    floatView[0] = num;
    const f = uint32View[0];
    const e = f >> 23 & 511;
    return baseTable[e] + ((f & 8388607) >> shiftTable[e]);
  }
  const mantissaTable = new _primordials.NativeUint32Array(2048);
  const exponentTable = new _primordials.NativeUint32Array(64);
  const offsetTable = new _primordials.NativeUint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= ~8388608;
    e += 947912704;
    mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 939524096 + (i - 1024 << 13);
  }
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }
  function convertToNumber(float16bits) {
    const m = float16bits >> 10;
    uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 1023)] + exponentTable[m];
    return floatView[0];
  }
  return converter;
}
var spec = {};
var hasRequiredSpec;
function requireSpec() {
  if (hasRequiredSpec)
    return spec;
  hasRequiredSpec = 1;
  Object.defineProperty(spec, "__esModule", {
    value: true
  });
  spec.IsDetachedBuffer = IsDetachedBuffer;
  spec.SpeciesConstructor = SpeciesConstructor;
  spec.ToIntegerOrInfinity = ToIntegerOrInfinity;
  spec.ToLength = ToLength;
  spec.defaultCompare = defaultCompare2;
  var _is = requireIs();
  var _messages = requireMessages$1();
  var _primordials = requirePrimordials();
  function ToIntegerOrInfinity(target) {
    const number = +target;
    if ((0, _primordials.NumberIsNaN)(number) || number === 0) {
      return 0;
    }
    return (0, _primordials.MathTrunc)(number);
  }
  function ToLength(target) {
    const length = ToIntegerOrInfinity(target);
    if (length < 0) {
      return 0;
    }
    return length < _primordials.MAX_SAFE_INTEGER ? length : _primordials.MAX_SAFE_INTEGER;
  }
  function SpeciesConstructor(target, defaultConstructor) {
    if (!(0, _is.isObject)(target)) {
      throw (0, _primordials.NativeTypeError)(_messages.THIS_IS_NOT_AN_OBJECT);
    }
    const constructor = target.constructor;
    if (constructor === void 0) {
      return defaultConstructor;
    }
    if (!(0, _is.isObject)(constructor)) {
      throw (0, _primordials.NativeTypeError)(_messages.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);
    }
    const species = constructor[_primordials.SymbolSpecies];
    if (species == null) {
      return defaultConstructor;
    }
    return species;
  }
  function IsDetachedBuffer(buffer2) {
    if ((0, _is.isSharedArrayBuffer)(buffer2)) {
      return false;
    }
    try {
      (0, _primordials.ArrayBufferPrototypeSlice)(buffer2, 0, 0);
      return false;
    } catch (e) {
    }
    return true;
  }
  function defaultCompare2(x, y) {
    const isXNaN = (0, _primordials.NumberIsNaN)(x);
    const isYNaN = (0, _primordials.NumberIsNaN)(y);
    if (isXNaN && isYNaN) {
      return 0;
    }
    if (isXNaN) {
      return 1;
    }
    if (isYNaN) {
      return -1;
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    if (x === 0 && y === 0) {
      const isXPlusZero = (0, _primordials.ObjectIs)(x, 0);
      const isYPlusZero = (0, _primordials.ObjectIs)(y, 0);
      if (!isXPlusZero && isYPlusZero) {
        return -1;
      }
      if (isXPlusZero && !isYPlusZero) {
        return 1;
      }
    }
    return 0;
  }
  return spec;
}
var hasRequiredFloat16Array;
function requireFloat16Array() {
  if (hasRequiredFloat16Array)
    return Float16Array;
  hasRequiredFloat16Array = 1;
  Object.defineProperty(Float16Array, "__esModule", {
    value: true
  });
  Float16Array.isFloat16Array = isFloat16Array;
  var _arrayIterator = requireArrayIterator();
  var _brand = requireBrand();
  var _converter = requireConverter();
  var _is = requireIs();
  var _messages = requireMessages$1();
  var _primordials = requirePrimordials();
  var _spec = requireSpec();
  const BYTES_PER_ELEMENT = 2;
  const float16bitsArrays = new _primordials.NativeWeakMap();
  function isFloat16Array(target) {
    return (0, _primordials.WeakMapPrototypeHas)(float16bitsArrays, target) || !(0, _primordials.ArrayBufferIsView)(target) && (0, _brand.hasFloat16ArrayBrand)(target);
  }
  function assertFloat16Array(target) {
    if (!isFloat16Array(target)) {
      throw (0, _primordials.NativeTypeError)(_messages.THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);
    }
  }
  function assertSpeciesTypedArray(target, count) {
    const isTargetFloat16Array = isFloat16Array(target);
    const isTargetTypedArray = (0, _is.isNativeTypedArray)(target);
    if (!isTargetFloat16Array && !isTargetTypedArray) {
      throw (0, _primordials.NativeTypeError)(_messages.SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);
    }
    if (typeof count === "number") {
      let length;
      if (isTargetFloat16Array) {
        const float16bitsArray = getFloat16BitsArray(target);
        length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      } else {
        length = (0, _primordials.TypedArrayPrototypeGetLength)(target);
      }
      if (length < count) {
        throw (0, _primordials.NativeTypeError)(_messages.DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH);
      }
    }
    if ((0, _is.isNativeBigIntTypedArray)(target)) {
      throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
    }
  }
  function getFloat16BitsArray(float16) {
    const float16bitsArray = (0, _primordials.WeakMapPrototypeGet)(float16bitsArrays, float16);
    if (float16bitsArray !== void 0) {
      const buffer3 = (0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray);
      if ((0, _spec.IsDetachedBuffer)(buffer3)) {
        throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
      }
      return float16bitsArray;
    }
    const buffer2 = float16.buffer;
    if ((0, _spec.IsDetachedBuffer)(buffer2)) {
      throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
    }
    const cloned = (0, _primordials.ReflectConstruct)(Float16Array$1, [buffer2, float16.byteOffset, float16.length], float16.constructor);
    return (0, _primordials.WeakMapPrototypeGet)(float16bitsArrays, cloned);
  }
  function copyToArray(float16bitsArray) {
    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
    const array = [];
    for (let i = 0; i < length; ++i) {
      array[i] = (0, _converter.convertToNumber)(float16bitsArray[i]);
    }
    return array;
  }
  const TypedArrayPrototypeGetters = new _primordials.NativeWeakSet();
  for (const key of (0, _primordials.ReflectOwnKeys)(_primordials.TypedArrayPrototype)) {
    if (key === _primordials.SymbolToStringTag) {
      continue;
    }
    const descriptor = (0, _primordials.ReflectGetOwnPropertyDescriptor)(_primordials.TypedArrayPrototype, key);
    if ((0, _primordials.ObjectHasOwn)(descriptor, "get") && typeof descriptor.get === "function") {
      (0, _primordials.WeakSetPrototypeAdd)(TypedArrayPrototypeGetters, descriptor.get);
    }
  }
  const handler = (0, _primordials.ObjectFreeze)({
    get(target, key, receiver) {
      if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {
        return (0, _converter.convertToNumber)((0, _primordials.ReflectGet)(target, key));
      }
      if ((0, _primordials.WeakSetPrototypeHas)(TypedArrayPrototypeGetters, (0, _primordials.ObjectPrototype__lookupGetter__)(target, key))) {
        return (0, _primordials.ReflectGet)(target, key);
      }
      return (0, _primordials.ReflectGet)(target, key, receiver);
    },
    set(target, key, value, receiver) {
      if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {
        return (0, _primordials.ReflectSet)(target, key, (0, _converter.roundToFloat16Bits)(value));
      }
      return (0, _primordials.ReflectSet)(target, key, value, receiver);
    },
    getOwnPropertyDescriptor(target, key) {
      if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {
        const descriptor = (0, _primordials.ReflectGetOwnPropertyDescriptor)(target, key);
        descriptor.value = (0, _converter.convertToNumber)(descriptor.value);
        return descriptor;
      }
      return (0, _primordials.ReflectGetOwnPropertyDescriptor)(target, key);
    },
    defineProperty(target, key, descriptor) {
      if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key) && (0, _primordials.ObjectHasOwn)(descriptor, "value")) {
        descriptor.value = (0, _converter.roundToFloat16Bits)(descriptor.value);
        return (0, _primordials.ReflectDefineProperty)(target, key, descriptor);
      }
      return (0, _primordials.ReflectDefineProperty)(target, key, descriptor);
    }
  });
  let Float16Array$1 = class Float16Array2 {
    constructor(input, _byteOffset, _length) {
      let float16bitsArray;
      if (isFloat16Array(input)) {
        float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [getFloat16BitsArray(input)], new.target);
      } else if ((0, _is.isObject)(input) && !(0, _is.isArrayBuffer)(input)) {
        let list;
        let length;
        if ((0, _is.isNativeTypedArray)(input)) {
          list = input;
          length = (0, _primordials.TypedArrayPrototypeGetLength)(input);
          const buffer2 = (0, _primordials.TypedArrayPrototypeGetBuffer)(input);
          const BufferConstructor = !(0, _is.isSharedArrayBuffer)(buffer2) ? (0, _spec.SpeciesConstructor)(buffer2, _primordials.NativeArrayBuffer) : _primordials.NativeArrayBuffer;
          if ((0, _spec.IsDetachedBuffer)(buffer2)) {
            throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
          }
          if ((0, _is.isNativeBigIntTypedArray)(input)) {
            throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
          }
          const data = new BufferConstructor(length * BYTES_PER_ELEMENT);
          float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [data], new.target);
        } else {
          const iterator = input[_primordials.SymbolIterator];
          if (iterator != null && typeof iterator !== "function") {
            throw (0, _primordials.NativeTypeError)(_messages.ITERATOR_PROPERTY_IS_NOT_CALLABLE);
          }
          if (iterator != null) {
            if ((0, _is.isOrdinaryArray)(input)) {
              list = input;
              length = input.length;
            } else {
              list = [...input];
              length = list.length;
            }
          } else {
            list = input;
            length = (0, _spec.ToLength)(list.length);
          }
          float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [length], new.target);
        }
        for (let i = 0; i < length; ++i) {
          float16bitsArray[i] = (0, _converter.roundToFloat16Bits)(list[i]);
        }
      } else {
        float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, arguments, new.target);
      }
      const proxy = new _primordials.NativeProxy(float16bitsArray, handler);
      (0, _primordials.WeakMapPrototypeSet)(float16bitsArrays, proxy, float16bitsArray);
      return proxy;
    }
    static from(src, ...opts) {
      const Constructor = this;
      if (!(0, _primordials.ReflectHas)(Constructor, _brand.brand)) {
        throw (0, _primordials.NativeTypeError)(_messages.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);
      }
      if (Constructor === Float16Array2) {
        if (isFloat16Array(src) && opts.length === 0) {
          const float16bitsArray = getFloat16BitsArray(src);
          const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
          return new Float16Array2((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16)));
        }
        if (opts.length === 0) {
          return new Float16Array2((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.Uint16ArrayFrom)(src, _converter.roundToFloat16Bits)));
        }
        const mapFunc = opts[0];
        const thisArg = opts[1];
        return new Float16Array2((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.Uint16ArrayFrom)(src, function(val, ...args) {
          return (0, _converter.roundToFloat16Bits)((0, _primordials.ReflectApply)(mapFunc, this, [val, ...(0, _arrayIterator.safeIfNeeded)(args)]));
        }, thisArg)));
      }
      let list;
      let length;
      const iterator = src[_primordials.SymbolIterator];
      if (iterator != null && typeof iterator !== "function") {
        throw (0, _primordials.NativeTypeError)(_messages.ITERATOR_PROPERTY_IS_NOT_CALLABLE);
      }
      if (iterator != null) {
        if ((0, _is.isOrdinaryArray)(src)) {
          list = src;
          length = src.length;
        } else if ((0, _is.isOrdinaryNativeTypedArray)(src)) {
          list = src;
          length = (0, _primordials.TypedArrayPrototypeGetLength)(src);
        } else {
          list = [...src];
          length = list.length;
        }
      } else {
        if (src == null) {
          throw (0, _primordials.NativeTypeError)(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);
        }
        list = (0, _primordials.NativeObject)(src);
        length = (0, _spec.ToLength)(list.length);
      }
      const array = new Constructor(length);
      if (opts.length === 0) {
        for (let i = 0; i < length; ++i) {
          array[i] = list[i];
        }
      } else {
        const mapFunc = opts[0];
        const thisArg = opts[1];
        for (let i = 0; i < length; ++i) {
          array[i] = (0, _primordials.ReflectApply)(mapFunc, thisArg, [list[i], i]);
        }
      }
      return array;
    }
    static of(...items) {
      const Constructor = this;
      if (!(0, _primordials.ReflectHas)(Constructor, _brand.brand)) {
        throw (0, _primordials.NativeTypeError)(_messages.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);
      }
      const length = items.length;
      if (Constructor === Float16Array2) {
        const proxy = new Float16Array2(length);
        const float16bitsArray = getFloat16BitsArray(proxy);
        for (let i = 0; i < length; ++i) {
          float16bitsArray[i] = (0, _converter.roundToFloat16Bits)(items[i]);
        }
        return proxy;
      }
      const array = new Constructor(length);
      for (let i = 0; i < length; ++i) {
        array[i] = items[i];
      }
      return array;
    }
    keys() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      return (0, _primordials.TypedArrayPrototypeKeys)(float16bitsArray);
    }
    values() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      return (0, _arrayIterator.wrap)(function* () {
        for (const val of (0, _primordials.TypedArrayPrototypeValues)(float16bitsArray)) {
          yield (0, _converter.convertToNumber)(val);
        }
      }());
    }
    entries() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      return (0, _arrayIterator.wrap)(function* () {
        for (const [i, val] of (0, _primordials.TypedArrayPrototypeEntries)(float16bitsArray)) {
          yield [i, (0, _converter.convertToNumber)(val)];
        }
      }());
    }
    at(index) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const relativeIndex = (0, _spec.ToIntegerOrInfinity)(index);
      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
      if (k < 0 || k >= length) {
        return;
      }
      return (0, _converter.convertToNumber)(float16bitsArray[k]);
    }
    map(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array2);
      if (Constructor === Float16Array2) {
        const proxy = new Float16Array2(length);
        const array2 = getFloat16BitsArray(proxy);
        for (let i = 0; i < length; ++i) {
          const val = (0, _converter.convertToNumber)(float16bitsArray[i]);
          array2[i] = (0, _converter.roundToFloat16Bits)((0, _primordials.ReflectApply)(callback, thisArg, [val, i, this]));
        }
        return proxy;
      }
      const array = new Constructor(length);
      assertSpeciesTypedArray(array, length);
      for (let i = 0; i < length; ++i) {
        const val = (0, _converter.convertToNumber)(float16bitsArray[i]);
        array[i] = (0, _primordials.ReflectApply)(callback, thisArg, [val, i, this]);
      }
      return array;
    }
    filter(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      const kept = [];
      for (let i = 0; i < length; ++i) {
        const val = (0, _converter.convertToNumber)(float16bitsArray[i]);
        if ((0, _primordials.ReflectApply)(callback, thisArg, [val, i, this])) {
          (0, _primordials.ArrayPrototypePush)(kept, val);
        }
      }
      const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array2);
      const array = new Constructor(kept);
      assertSpeciesTypedArray(array);
      return array;
    }
    reduce(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      if (length === 0 && opts.length === 0) {
        throw (0, _primordials.NativeTypeError)(_messages.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);
      }
      let accumulator, start2;
      if (opts.length === 0) {
        accumulator = (0, _converter.convertToNumber)(float16bitsArray[0]);
        start2 = 1;
      } else {
        accumulator = opts[0];
        start2 = 0;
      }
      for (let i = start2; i < length; ++i) {
        accumulator = callback(accumulator, (0, _converter.convertToNumber)(float16bitsArray[i]), i, this);
      }
      return accumulator;
    }
    reduceRight(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      if (length === 0 && opts.length === 0) {
        throw (0, _primordials.NativeTypeError)(_messages.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);
      }
      let accumulator, start2;
      if (opts.length === 0) {
        accumulator = (0, _converter.convertToNumber)(float16bitsArray[length - 1]);
        start2 = length - 2;
      } else {
        accumulator = opts[0];
        start2 = length - 1;
      }
      for (let i = start2; i >= 0; --i) {
        accumulator = callback(accumulator, (0, _converter.convertToNumber)(float16bitsArray[i]), i, this);
      }
      return accumulator;
    }
    forEach(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        (0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i]), i, this]);
      }
    }
    find(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        const value = (0, _converter.convertToNumber)(float16bitsArray[i]);
        if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {
          return value;
        }
      }
    }
    findIndex(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        const value = (0, _converter.convertToNumber)(float16bitsArray[i]);
        if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {
          return i;
        }
      }
      return -1;
    }
    findLast(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      for (let i = length - 1; i >= 0; --i) {
        const value = (0, _converter.convertToNumber)(float16bitsArray[i]);
        if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {
          return value;
        }
      }
    }
    findLastIndex(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      for (let i = length - 1; i >= 0; --i) {
        const value = (0, _converter.convertToNumber)(float16bitsArray[i]);
        if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {
          return i;
        }
      }
      return -1;
    }
    every(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        if (!(0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i]), i, this])) {
          return false;
        }
      }
      return true;
    }
    some(callback, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const thisArg = opts[0];
      for (let i = 0; i < length; ++i) {
        if ((0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i]), i, this])) {
          return true;
        }
      }
      return false;
    }
    set(input, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const targetOffset = (0, _spec.ToIntegerOrInfinity)(opts[0]);
      if (targetOffset < 0) {
        throw (0, _primordials.NativeRangeError)(_messages.OFFSET_IS_OUT_OF_BOUNDS);
      }
      if (input == null) {
        throw (0, _primordials.NativeTypeError)(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);
      }
      if ((0, _is.isNativeBigIntTypedArray)(input)) {
        throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);
      }
      if (isFloat16Array(input)) {
        return (0, _primordials.TypedArrayPrototypeSet)(getFloat16BitsArray(this), getFloat16BitsArray(input), targetOffset);
      }
      if ((0, _is.isNativeTypedArray)(input)) {
        const buffer2 = (0, _primordials.TypedArrayPrototypeGetBuffer)(input);
        if ((0, _spec.IsDetachedBuffer)(buffer2)) {
          throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
        }
      }
      const targetLength = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const src = (0, _primordials.NativeObject)(input);
      const srcLength = (0, _spec.ToLength)(src.length);
      if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {
        throw (0, _primordials.NativeRangeError)(_messages.OFFSET_IS_OUT_OF_BOUNDS);
      }
      for (let i = 0; i < srcLength; ++i) {
        float16bitsArray[i + targetOffset] = (0, _converter.roundToFloat16Bits)(src[i]);
      }
    }
    reverse() {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      (0, _primordials.TypedArrayPrototypeReverse)(float16bitsArray);
      return this;
    }
    fill(value, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      (0, _primordials.TypedArrayPrototypeFill)(float16bitsArray, (0, _converter.roundToFloat16Bits)(value), ...(0, _arrayIterator.safeIfNeeded)(opts));
      return this;
    }
    copyWithin(target, start2, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      (0, _primordials.TypedArrayPrototypeCopyWithin)(float16bitsArray, target, start2, ...(0, _arrayIterator.safeIfNeeded)(opts));
      return this;
    }
    sort(compareFn) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const sortCompare = compareFn !== void 0 ? compareFn : _spec.defaultCompare;
      (0, _primordials.TypedArrayPrototypeSort)(float16bitsArray, (x, y) => {
        return sortCompare((0, _converter.convertToNumber)(x), (0, _converter.convertToNumber)(y));
      });
      return this;
    }
    slice(start2, end) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array2);
      if (Constructor === Float16Array2) {
        const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
        return new Float16Array2((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16, start2, end)));
      }
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      const relativeStart = (0, _spec.ToIntegerOrInfinity)(start2);
      const relativeEnd = end === void 0 ? length : (0, _spec.ToIntegerOrInfinity)(end);
      let k;
      if (relativeStart === -Infinity) {
        k = 0;
      } else if (relativeStart < 0) {
        k = length + relativeStart > 0 ? length + relativeStart : 0;
      } else {
        k = length < relativeStart ? length : relativeStart;
      }
      let final;
      if (relativeEnd === -Infinity) {
        final = 0;
      } else if (relativeEnd < 0) {
        final = length + relativeEnd > 0 ? length + relativeEnd : 0;
      } else {
        final = length < relativeEnd ? length : relativeEnd;
      }
      const count = final - k > 0 ? final - k : 0;
      const array = new Constructor(count);
      assertSpeciesTypedArray(array, count);
      if (count === 0) {
        return array;
      }
      const buffer2 = (0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray);
      if ((0, _spec.IsDetachedBuffer)(buffer2)) {
        throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);
      }
      let n = 0;
      while (k < final) {
        array[n] = (0, _converter.convertToNumber)(float16bitsArray[k]);
        ++k;
        ++n;
      }
      return array;
    }
    subarray(begin, end) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array2);
      const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));
      const uint16Subarray = (0, _primordials.TypedArrayPrototypeSubarray)(uint16, begin, end);
      const array = new Constructor((0, _primordials.TypedArrayPrototypeGetBuffer)(uint16Subarray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(uint16Subarray), (0, _primordials.TypedArrayPrototypeGetLength)(uint16Subarray));
      assertSpeciesTypedArray(array);
      return array;
    }
    indexOf(element, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);
      if (from === Infinity) {
        return -1;
      }
      if (from < 0) {
        from += length;
        if (from < 0) {
          from = 0;
        }
      }
      for (let i = from; i < length; ++i) {
        if ((0, _primordials.ObjectHasOwn)(float16bitsArray, i) && (0, _converter.convertToNumber)(float16bitsArray[i]) === element) {
          return i;
        }
      }
      return -1;
    }
    lastIndexOf(element, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      let from = opts.length >= 1 ? (0, _spec.ToIntegerOrInfinity)(opts[0]) : length - 1;
      if (from === -Infinity) {
        return -1;
      }
      if (from >= 0) {
        from = from < length - 1 ? from : length - 1;
      } else {
        from += length;
      }
      for (let i = from; i >= 0; --i) {
        if ((0, _primordials.ObjectHasOwn)(float16bitsArray, i) && (0, _converter.convertToNumber)(float16bitsArray[i]) === element) {
          return i;
        }
      }
      return -1;
    }
    includes(element, ...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);
      let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);
      if (from === Infinity) {
        return false;
      }
      if (from < 0) {
        from += length;
        if (from < 0) {
          from = 0;
        }
      }
      const isNaN2 = (0, _primordials.NumberIsNaN)(element);
      for (let i = from; i < length; ++i) {
        const value = (0, _converter.convertToNumber)(float16bitsArray[i]);
        if (isNaN2 && (0, _primordials.NumberIsNaN)(value)) {
          return true;
        }
        if (value === element) {
          return true;
        }
      }
      return false;
    }
    join(separator) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const array = copyToArray(float16bitsArray);
      return (0, _primordials.ArrayPrototypeJoin)(array, separator);
    }
    toLocaleString(...opts) {
      assertFloat16Array(this);
      const float16bitsArray = getFloat16BitsArray(this);
      const array = copyToArray(float16bitsArray);
      return (0, _primordials.ArrayPrototypeToLocaleString)(array, ...(0, _arrayIterator.safeIfNeeded)(opts));
    }
    get [_primordials.SymbolToStringTag]() {
      if (isFloat16Array(this)) {
        return "Float16Array";
      }
    }
  };
  Float16Array.Float16Array = Float16Array$1;
  (0, _primordials.ObjectDefineProperty)(Float16Array$1, "BYTES_PER_ELEMENT", {
    value: BYTES_PER_ELEMENT
  });
  (0, _primordials.ObjectDefineProperty)(Float16Array$1, _brand.brand, {});
  (0, _primordials.ReflectSetPrototypeOf)(Float16Array$1, _primordials.TypedArray);
  const Float16ArrayPrototype = Float16Array$1.prototype;
  (0, _primordials.ObjectDefineProperty)(Float16ArrayPrototype, "BYTES_PER_ELEMENT", {
    value: BYTES_PER_ELEMENT
  });
  (0, _primordials.ObjectDefineProperty)(Float16ArrayPrototype, _primordials.SymbolIterator, {
    value: Float16ArrayPrototype.values,
    writable: true,
    configurable: true
  });
  (0, _primordials.ReflectSetPrototypeOf)(Float16ArrayPrototype, _primordials.TypedArrayPrototype);
  return Float16Array;
}
var isTypedArray = {};
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray;
  hasRequiredIsTypedArray = 1;
  Object.defineProperty(isTypedArray, "__esModule", {
    value: true
  });
  isTypedArray.isTypedArray = isTypedArray$1;
  var _Float16Array = requireFloat16Array();
  var _is = requireIs();
  function isTypedArray$1(target) {
    return (0, _is.isNativeTypedArray)(target) || (0, _Float16Array.isFloat16Array)(target);
  }
  return isTypedArray;
}
var _DataView = {};
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView)
    return _DataView;
  hasRequired_DataView = 1;
  Object.defineProperty(_DataView, "__esModule", {
    value: true
  });
  _DataView.getFloat16 = getFloat16;
  _DataView.setFloat16 = setFloat16;
  var _arrayIterator = requireArrayIterator();
  var _converter = requireConverter();
  var _primordials = requirePrimordials();
  function getFloat16(dataView, byteOffset, ...opts) {
    return (0, _converter.convertToNumber)((0, _primordials.DataViewPrototypeGetUint16)(dataView, byteOffset, ...(0, _arrayIterator.safeIfNeeded)(opts)));
  }
  function setFloat16(dataView, byteOffset, value, ...opts) {
    return (0, _primordials.DataViewPrototypeSetUint16)(dataView, byteOffset, (0, _converter.roundToFloat16Bits)(value), ...(0, _arrayIterator.safeIfNeeded)(opts));
  }
  return _DataView;
}
var hfround = {};
var hasRequiredHfround;
function requireHfround() {
  if (hasRequiredHfround)
    return hfround;
  hasRequiredHfround = 1;
  Object.defineProperty(hfround, "__esModule", {
    value: true
  });
  hfround.hfround = hfround$1;
  var _converter = requireConverter();
  var _primordials = requirePrimordials();
  function hfround$1(x) {
    const number = +x;
    if (!(0, _primordials.NumberIsFinite)(number) || number === 0) {
      return number;
    }
    const x16 = (0, _converter.roundToFloat16Bits)(number);
    return (0, _converter.convertToNumber)(x16);
  }
  return hfround;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib;
  hasRequiredLib = 1;
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  var _Float16Array = requireFloat16Array();
  lib.Float16Array = _Float16Array.Float16Array;
  lib.isFloat16Array = _Float16Array.isFloat16Array;
  var _isTypedArray = requireIsTypedArray();
  lib.isTypedArray = _isTypedArray.isTypedArray;
  var _DataView2 = require_DataView();
  lib.getFloat16 = _DataView2.getFloat16;
  lib.setFloat16 = _DataView2.setFloat16;
  var _hfround = requireHfround();
  lib.hfround = _hfround.hfround;
  return lib;
}
var getAttributeExports = {};
var getAttribute = {
  get exports() {
    return getAttributeExports;
  },
  set exports(v) {
    getAttributeExports = v;
  }
};
var hasRequiredGetAttribute;
function requireGetAttribute() {
  if (hasRequiredGetAttribute)
    return getAttributeExports;
  hasRequiredGetAttribute = 1;
  function getAttribute$1(tag, attributeName, options) {
    const debug = options && options.debug || false;
    if (debug)
      console.log("getting " + attributeName + " in " + tag);
    const xml = typeof tag === "object" ? tag.outer : tag;
    const pattern = `${attributeName}\\="([^"]*)"`;
    if (debug)
      console.log("pattern:", pattern);
    const re = new RegExp(pattern);
    const match2 = re.exec(xml);
    if (debug)
      console.log("match:", match2);
    if (match2)
      return match2[1];
  }
  getAttribute.exports = getAttribute$1;
  getAttributeExports.default = getAttribute$1;
  return getAttributeExports;
}
var findTagsByNameExports = {};
var findTagsByName = {
  get exports() {
    return findTagsByNameExports;
  },
  set exports(v) {
    findTagsByNameExports = v;
  }
};
var findTagByNameExports = {};
var findTagByName = {
  get exports() {
    return findTagByNameExports;
  },
  set exports(v) {
    findTagByNameExports = v;
  }
};
var indexOfMatchExports = {};
var indexOfMatch = {
  get exports() {
    return indexOfMatchExports;
  },
  set exports(v) {
    indexOfMatchExports = v;
  }
};
var hasRequiredIndexOfMatch;
function requireIndexOfMatch() {
  if (hasRequiredIndexOfMatch)
    return indexOfMatchExports;
  hasRequiredIndexOfMatch = 1;
  function indexOfMatch$1(xml, pattern, startIndex) {
    const re = new RegExp(pattern);
    const match2 = re.exec(xml.slice(startIndex));
    if (match2)
      return startIndex + match2.index;
    else
      return -1;
  }
  indexOfMatch.exports = indexOfMatch$1;
  indexOfMatchExports.default = indexOfMatch$1;
  return indexOfMatchExports;
}
var indexOfMatchEndExports = {};
var indexOfMatchEnd = {
  get exports() {
    return indexOfMatchEndExports;
  },
  set exports(v) {
    indexOfMatchEndExports = v;
  }
};
var hasRequiredIndexOfMatchEnd;
function requireIndexOfMatchEnd() {
  if (hasRequiredIndexOfMatchEnd)
    return indexOfMatchEndExports;
  hasRequiredIndexOfMatchEnd = 1;
  function indexOfMatchEnd$1(xml, pattern, startIndex) {
    const re = new RegExp(pattern);
    const match2 = re.exec(xml.slice(startIndex));
    if (match2)
      return startIndex + match2.index + match2[0].length - 1;
    else
      return -1;
  }
  indexOfMatchEnd.exports = indexOfMatchEnd$1;
  indexOfMatchEndExports.default = indexOfMatchEnd$1;
  return indexOfMatchEndExports;
}
var countSubstringExports = {};
var countSubstring = {
  get exports() {
    return countSubstringExports;
  },
  set exports(v) {
    countSubstringExports = v;
  }
};
var hasRequiredCountSubstring;
function requireCountSubstring() {
  if (hasRequiredCountSubstring)
    return countSubstringExports;
  hasRequiredCountSubstring = 1;
  function countSubstring$1(string, substring) {
    const pattern = new RegExp(substring, "g");
    const match2 = string.match(pattern);
    return match2 ? match2.length : 0;
  }
  countSubstring.exports = countSubstring$1;
  countSubstringExports.default = countSubstring$1;
  return countSubstringExports;
}
var hasRequiredFindTagByName;
function requireFindTagByName() {
  if (hasRequiredFindTagByName)
    return findTagByNameExports;
  hasRequiredFindTagByName = 1;
  const indexOfMatch2 = requireIndexOfMatch();
  const indexOfMatchEnd2 = requireIndexOfMatchEnd();
  const countSubstring2 = requireCountSubstring();
  function findTagByName$1(xml, tagName, options) {
    const debug = options && options.debug || false;
    const nested = !(options && typeof options.nested === false);
    const startIndex = options && options.startIndex || 0;
    if (debug)
      console.log("[xml-utils] starting findTagByName with", tagName, " and ", options);
    const start2 = indexOfMatch2(xml, `<${tagName}[ >/]`, startIndex);
    if (debug)
      console.log("[xml-utils] start:", start2);
    if (start2 === -1)
      return void 0;
    const afterStart = xml.slice(start2 + tagName.length);
    let relativeEnd = indexOfMatchEnd2(afterStart, "^[^<]*[ /]>", 0);
    const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === "/";
    if (debug)
      console.log("[xml-utils] selfClosing:", selfClosing);
    if (selfClosing === false) {
      if (nested) {
        let startIndex2 = 0;
        let openings = 1;
        let closings = 0;
        while ((relativeEnd = indexOfMatchEnd2(afterStart, "[ /]" + tagName + ">", startIndex2)) !== -1) {
          const clip = afterStart.substring(startIndex2, relativeEnd + 1);
          openings += countSubstring2(clip, "<" + tagName);
          closings += countSubstring2(clip, "/" + tagName + ">");
          if (closings >= openings)
            break;
          startIndex2 = relativeEnd;
        }
      } else {
        relativeEnd = indexOfMatchEnd2(afterStart, "[ /]" + tagName + ">", 0);
      }
    }
    const end = start2 + tagName.length + relativeEnd + 1;
    if (debug)
      console.log("[xml-utils] end:", end);
    if (end === -1)
      return void 0;
    const outer = xml.slice(start2, end);
    let inner;
    if (selfClosing) {
      inner = null;
    } else {
      inner = outer.slice(outer.indexOf(">") + 1, outer.lastIndexOf("<"));
    }
    return { inner, outer, start: start2, end };
  }
  findTagByName.exports = findTagByName$1;
  findTagByNameExports.default = findTagByName$1;
  return findTagByNameExports;
}
var hasRequiredFindTagsByName;
function requireFindTagsByName() {
  if (hasRequiredFindTagsByName)
    return findTagsByNameExports;
  hasRequiredFindTagsByName = 1;
  const findTagByName2 = requireFindTagByName();
  function findTagsByName$1(xml, tagName, options) {
    const tags = [];
    const debug = options && options.debug || false;
    const nested = options && typeof options.nested === "boolean" ? options.nested : true;
    let startIndex = options && options.startIndex || 0;
    let tag;
    while (tag = findTagByName2(xml, tagName, { debug, startIndex })) {
      if (nested) {
        startIndex = tag.start + 1 + tagName.length;
      } else {
        startIndex = tag.end;
      }
      tags.push(tag);
    }
    if (debug)
      console.log("findTagsByName found", tags.length, "tags");
    return tags;
  }
  findTagsByName.exports = findTagsByName$1;
  findTagsByNameExports.default = findTagsByName$1;
  return findTagsByNameExports;
}
var globals = {};
var hasRequiredGlobals;
function requireGlobals() {
  if (hasRequiredGlobals)
    return globals;
  hasRequiredGlobals = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.geoKeys = exports2.geoKeyNames = exports2.LercAddCompression = exports2.LercParameters = exports2.ExtraSamplesValues = exports2.photometricInterpretations = exports2.fieldTypes = exports2.fieldTypeNames = exports2.arrayFields = exports2.fieldTagTypes = exports2.fieldTags = exports2.fieldTagNames = void 0;
    exports2.fieldTagNames = {
      // TIFF Baseline
      315: "Artist",
      258: "BitsPerSample",
      265: "CellLength",
      264: "CellWidth",
      320: "ColorMap",
      259: "Compression",
      33432: "Copyright",
      306: "DateTime",
      338: "ExtraSamples",
      266: "FillOrder",
      289: "FreeByteCounts",
      288: "FreeOffsets",
      291: "GrayResponseCurve",
      290: "GrayResponseUnit",
      316: "HostComputer",
      270: "ImageDescription",
      257: "ImageLength",
      256: "ImageWidth",
      271: "Make",
      281: "MaxSampleValue",
      280: "MinSampleValue",
      272: "Model",
      254: "NewSubfileType",
      274: "Orientation",
      262: "PhotometricInterpretation",
      284: "PlanarConfiguration",
      296: "ResolutionUnit",
      278: "RowsPerStrip",
      277: "SamplesPerPixel",
      305: "Software",
      279: "StripByteCounts",
      273: "StripOffsets",
      255: "SubfileType",
      263: "Threshholding",
      282: "XResolution",
      283: "YResolution",
      // TIFF Extended
      326: "BadFaxLines",
      327: "CleanFaxData",
      343: "ClipPath",
      328: "ConsecutiveBadFaxLines",
      433: "Decode",
      434: "DefaultImageColor",
      269: "DocumentName",
      336: "DotRange",
      321: "HalftoneHints",
      346: "Indexed",
      347: "JPEGTables",
      285: "PageName",
      297: "PageNumber",
      317: "Predictor",
      319: "PrimaryChromaticities",
      532: "ReferenceBlackWhite",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      559: "StripRowCounts",
      330: "SubIFDs",
      292: "T4Options",
      293: "T6Options",
      325: "TileByteCounts",
      323: "TileLength",
      324: "TileOffsets",
      322: "TileWidth",
      301: "TransferFunction",
      318: "WhitePoint",
      344: "XClipPathUnits",
      286: "XPosition",
      529: "YCbCrCoefficients",
      531: "YCbCrPositioning",
      530: "YCbCrSubSampling",
      345: "YClipPathUnits",
      287: "YPosition",
      // EXIF
      37378: "ApertureValue",
      40961: "ColorSpace",
      36868: "DateTimeDigitized",
      36867: "DateTimeOriginal",
      34665: "Exif IFD",
      36864: "ExifVersion",
      33434: "ExposureTime",
      41728: "FileSource",
      37385: "Flash",
      40960: "FlashpixVersion",
      33437: "FNumber",
      42016: "ImageUniqueID",
      37384: "LightSource",
      37500: "MakerNote",
      37377: "ShutterSpeedValue",
      37510: "UserComment",
      // IPTC
      33723: "IPTC",
      // ICC
      34675: "ICC Profile",
      // XMP
      700: "XMP",
      // GDAL
      42112: "GDAL_METADATA",
      42113: "GDAL_NODATA",
      // Photoshop
      34377: "Photoshop",
      // GeoTiff
      33550: "ModelPixelScale",
      33922: "ModelTiepoint",
      34264: "ModelTransformation",
      34735: "GeoKeyDirectory",
      34736: "GeoDoubleParams",
      34737: "GeoAsciiParams",
      // LERC
      50674: "LercParameters"
    };
    exports2.fieldTags = {};
    for (const key in exports2.fieldTagNames) {
      if (exports2.fieldTagNames.hasOwnProperty(key)) {
        exports2.fieldTags[exports2.fieldTagNames[key]] = parseInt(key, 10);
      }
    }
    exports2.fieldTagTypes = {
      256: "SHORT",
      257: "SHORT",
      258: "SHORT",
      259: "SHORT",
      262: "SHORT",
      273: "LONG",
      274: "SHORT",
      277: "SHORT",
      278: "LONG",
      279: "LONG",
      282: "RATIONAL",
      283: "RATIONAL",
      284: "SHORT",
      286: "SHORT",
      287: "RATIONAL",
      296: "SHORT",
      297: "SHORT",
      305: "ASCII",
      306: "ASCII",
      338: "SHORT",
      339: "SHORT",
      513: "LONG",
      514: "LONG",
      1024: "SHORT",
      1025: "SHORT",
      2048: "SHORT",
      2049: "ASCII",
      3072: "SHORT",
      3073: "ASCII",
      33550: "DOUBLE",
      33922: "DOUBLE",
      34665: "LONG",
      34735: "SHORT",
      34737: "ASCII",
      42113: "ASCII"
    };
    exports2.arrayFields = [
      exports2.fieldTags.BitsPerSample,
      exports2.fieldTags.ExtraSamples,
      exports2.fieldTags.SampleFormat,
      exports2.fieldTags.StripByteCounts,
      exports2.fieldTags.StripOffsets,
      exports2.fieldTags.StripRowCounts,
      exports2.fieldTags.TileByteCounts,
      exports2.fieldTags.TileOffsets,
      exports2.fieldTags.SubIFDs
    ];
    exports2.fieldTypeNames = {
      1: "BYTE",
      2: "ASCII",
      3: "SHORT",
      4: "LONG",
      5: "RATIONAL",
      6: "SBYTE",
      7: "UNDEFINED",
      8: "SSHORT",
      9: "SLONG",
      10: "SRATIONAL",
      11: "FLOAT",
      12: "DOUBLE",
      // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html
      13: "IFD",
      // introduced by BigTIFF
      16: "LONG8",
      17: "SLONG8",
      18: "IFD8"
    };
    exports2.fieldTypes = {};
    for (const key in exports2.fieldTypeNames) {
      if (exports2.fieldTypeNames.hasOwnProperty(key)) {
        exports2.fieldTypes[exports2.fieldTypeNames[key]] = parseInt(key, 10);
      }
    }
    exports2.photometricInterpretations = {
      WhiteIsZero: 0,
      BlackIsZero: 1,
      RGB: 2,
      Palette: 3,
      TransparencyMask: 4,
      CMYK: 5,
      YCbCr: 6,
      CIELab: 8,
      ICCLab: 9
    };
    exports2.ExtraSamplesValues = {
      Unspecified: 0,
      Assocalpha: 1,
      Unassalpha: 2
    };
    exports2.LercParameters = {
      Version: 0,
      AddCompression: 1
    };
    exports2.LercAddCompression = {
      None: 0,
      Deflate: 1
    };
    exports2.geoKeyNames = {
      1024: "GTModelTypeGeoKey",
      1025: "GTRasterTypeGeoKey",
      1026: "GTCitationGeoKey",
      2048: "GeographicTypeGeoKey",
      2049: "GeogCitationGeoKey",
      2050: "GeogGeodeticDatumGeoKey",
      2051: "GeogPrimeMeridianGeoKey",
      2052: "GeogLinearUnitsGeoKey",
      2053: "GeogLinearUnitSizeGeoKey",
      2054: "GeogAngularUnitsGeoKey",
      2055: "GeogAngularUnitSizeGeoKey",
      2056: "GeogEllipsoidGeoKey",
      2057: "GeogSemiMajorAxisGeoKey",
      2058: "GeogSemiMinorAxisGeoKey",
      2059: "GeogInvFlatteningGeoKey",
      2060: "GeogAzimuthUnitsGeoKey",
      2061: "GeogPrimeMeridianLongGeoKey",
      2062: "GeogTOWGS84GeoKey",
      3072: "ProjectedCSTypeGeoKey",
      3073: "PCSCitationGeoKey",
      3074: "ProjectionGeoKey",
      3075: "ProjCoordTransGeoKey",
      3076: "ProjLinearUnitsGeoKey",
      3077: "ProjLinearUnitSizeGeoKey",
      3078: "ProjStdParallel1GeoKey",
      3079: "ProjStdParallel2GeoKey",
      3080: "ProjNatOriginLongGeoKey",
      3081: "ProjNatOriginLatGeoKey",
      3082: "ProjFalseEastingGeoKey",
      3083: "ProjFalseNorthingGeoKey",
      3084: "ProjFalseOriginLongGeoKey",
      3085: "ProjFalseOriginLatGeoKey",
      3086: "ProjFalseOriginEastingGeoKey",
      3087: "ProjFalseOriginNorthingGeoKey",
      3088: "ProjCenterLongGeoKey",
      3089: "ProjCenterLatGeoKey",
      3090: "ProjCenterEastingGeoKey",
      3091: "ProjCenterNorthingGeoKey",
      3092: "ProjScaleAtNatOriginGeoKey",
      3093: "ProjScaleAtCenterGeoKey",
      3094: "ProjAzimuthAngleGeoKey",
      3095: "ProjStraightVertPoleLongGeoKey",
      3096: "ProjRectifiedGridAngleGeoKey",
      4096: "VerticalCSTypeGeoKey",
      4097: "VerticalCitationGeoKey",
      4098: "VerticalDatumGeoKey",
      4099: "VerticalUnitsGeoKey"
    };
    exports2.geoKeys = {};
    for (const key in exports2.geoKeyNames) {
      if (exports2.geoKeyNames.hasOwnProperty(key)) {
        exports2.geoKeys[exports2.geoKeyNames[key]] = parseInt(key, 10);
      }
    }
  })(globals);
  return globals;
}
var rgb = {};
var hasRequiredRgb;
function requireRgb() {
  if (hasRequiredRgb)
    return rgb;
  hasRequiredRgb = 1;
  Object.defineProperty(rgb, "__esModule", { value: true });
  rgb.fromCIELab = rgb.fromYCbCr = rgb.fromCMYK = rgb.fromPalette = rgb.fromBlackIsZero = rgb.fromWhiteIsZero = void 0;
  function fromWhiteIsZero(raster, max) {
    const { width, height } = raster;
    const rgbRaster = new Uint8Array(width * height * 3);
    let value;
    for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {
      value = 256 - raster[i] / max * 256;
      rgbRaster[j] = value;
      rgbRaster[j + 1] = value;
      rgbRaster[j + 2] = value;
    }
    return rgbRaster;
  }
  rgb.fromWhiteIsZero = fromWhiteIsZero;
  function fromBlackIsZero(raster, max) {
    const { width, height } = raster;
    const rgbRaster = new Uint8Array(width * height * 3);
    let value;
    for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {
      value = raster[i] / max * 256;
      rgbRaster[j] = value;
      rgbRaster[j + 1] = value;
      rgbRaster[j + 2] = value;
    }
    return rgbRaster;
  }
  rgb.fromBlackIsZero = fromBlackIsZero;
  function fromPalette(raster, colorMap) {
    const { width, height } = raster;
    const rgbRaster = new Uint8Array(width * height * 3);
    const greenOffset = colorMap.length / 3;
    const blueOffset = colorMap.length / 3 * 2;
    for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {
      const mapIndex = raster[i];
      rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;
      rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;
      rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;
    }
    return rgbRaster;
  }
  rgb.fromPalette = fromPalette;
  function fromCMYK(cmykRaster) {
    const { width, height } = cmykRaster;
    const rgbRaster = new Uint8Array(width * height * 3);
    for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {
      const c = cmykRaster[i];
      const m = cmykRaster[i + 1];
      const y = cmykRaster[i + 2];
      const k = cmykRaster[i + 3];
      rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);
      rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);
      rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);
    }
    return rgbRaster;
  }
  rgb.fromCMYK = fromCMYK;
  function fromYCbCr(yCbCrRaster) {
    const { width, height } = yCbCrRaster;
    const rgbRaster = new Uint8ClampedArray(width * height * 3);
    for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {
      const y = yCbCrRaster[i];
      const cb = yCbCrRaster[i + 1];
      const cr = yCbCrRaster[i + 2];
      rgbRaster[j] = y + 1.402 * (cr - 128);
      rgbRaster[j + 1] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128);
      rgbRaster[j + 2] = y + 1.772 * (cb - 128);
    }
    return rgbRaster;
  }
  rgb.fromYCbCr = fromYCbCr;
  const Xn = 0.95047;
  const Yn = 1;
  const Zn = 1.08883;
  function fromCIELab(cieLabRaster) {
    const { width, height } = cieLabRaster;
    const rgbRaster = new Uint8Array(width * height * 3);
    for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {
      const L = cieLabRaster[i + 0];
      const a_ = cieLabRaster[i + 1] << 24 >> 24;
      const b_ = cieLabRaster[i + 2] << 24 >> 24;
      let y = (L + 16) / 116;
      let x = a_ / 500 + y;
      let z = y - b_ / 200;
      let r;
      let g;
      let b;
      x = Xn * (x * x * x > 8856e-6 ? x * x * x : (x - 16 / 116) / 7.787);
      y = Yn * (y * y * y > 8856e-6 ? y * y * y : (y - 16 / 116) / 7.787);
      z = Zn * (z * z * z > 8856e-6 ? z * z * z : (z - 16 / 116) / 7.787);
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : 12.92 * g;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : 12.92 * b;
      rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;
      rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;
      rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;
    }
    return rgbRaster;
  }
  rgb.fromCIELab = fromCIELab;
  return rgb;
}
var compression = {};
var raw = {};
var basedecoder = {};
var predictor = {};
var hasRequiredPredictor;
function requirePredictor() {
  if (hasRequiredPredictor)
    return predictor;
  hasRequiredPredictor = 1;
  Object.defineProperty(predictor, "__esModule", { value: true });
  predictor.applyPredictor = void 0;
  function decodeRowAcc(row, stride) {
    let length = row.length - stride;
    let offset = 0;
    do {
      for (let i = stride; i > 0; i--) {
        row[offset + stride] += row[offset];
        offset++;
      }
      length -= stride;
    } while (length > 0);
  }
  function decodeRowFloatingPoint(row, stride, bytesPerSample) {
    let index = 0;
    let count = row.length;
    const wc = count / bytesPerSample;
    while (count > stride) {
      for (let i = stride; i > 0; --i) {
        row[index + stride] += row[index];
        ++index;
      }
      count -= stride;
    }
    const copy = row.slice();
    for (let i = 0; i < wc; ++i) {
      for (let b = 0; b < bytesPerSample; ++b) {
        row[bytesPerSample * i + b] = copy[(bytesPerSample - b - 1) * wc + i];
      }
    }
  }
  function applyPredictor(block, predictor2, width, height, bitsPerSample, planarConfiguration) {
    if (!predictor2 || predictor2 === 1) {
      return block;
    }
    for (let i = 0; i < bitsPerSample.length; ++i) {
      if (bitsPerSample[i] % 8 !== 0) {
        throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");
      }
      if (bitsPerSample[i] !== bitsPerSample[0]) {
        throw new Error("When decoding with predictor, all samples must have the same size.");
      }
    }
    const bytesPerSample = bitsPerSample[0] / 8;
    const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;
    for (let i = 0; i < height; ++i) {
      if (i * stride * width * bytesPerSample >= block.byteLength) {
        break;
      }
      let row;
      if (predictor2 === 2) {
        switch (bitsPerSample[0]) {
          case 8:
            row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);
            break;
          case 16:
            row = new Uint16Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);
            break;
          case 32:
            row = new Uint32Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);
            break;
          default:
            throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);
        }
        decodeRowAcc(row, stride);
      } else if (predictor2 === 3) {
        row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);
        decodeRowFloatingPoint(row, stride, bytesPerSample);
      }
    }
    return block;
  }
  predictor.applyPredictor = applyPredictor;
  return predictor;
}
var hasRequiredBasedecoder;
function requireBasedecoder() {
  if (hasRequiredBasedecoder)
    return basedecoder;
  hasRequiredBasedecoder = 1;
  Object.defineProperty(basedecoder, "__esModule", { value: true });
  const predictor_js_1 = requirePredictor();
  class BaseDecoder {
    async decode(fileDirectory, buffer2) {
      const decoded = await this.decodeBlock(buffer2);
      const predictor2 = fileDirectory.Predictor || 1;
      if (predictor2 !== 1) {
        const isTiled = !fileDirectory.StripOffsets;
        const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;
        const tileHeight = isTiled ? fileDirectory.TileLength : fileDirectory.RowsPerStrip || fileDirectory.ImageLength;
        return (0, predictor_js_1.applyPredictor)(decoded, predictor2, tileWidth, tileHeight, fileDirectory.BitsPerSample, fileDirectory.PlanarConfiguration);
      }
      return decoded;
    }
  }
  basedecoder.default = BaseDecoder;
  return basedecoder;
}
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw)
    return raw;
  hasRequiredRaw = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(raw, "__esModule", { value: true });
  const basedecoder_js_1 = __importDefault(requireBasedecoder());
  class RawDecoder extends basedecoder_js_1.default {
    decodeBlock(buffer2) {
      return buffer2;
    }
  }
  raw.default = RawDecoder;
  return raw;
}
var lzw = {};
var hasRequiredLzw;
function requireLzw() {
  if (hasRequiredLzw)
    return lzw;
  hasRequiredLzw = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(lzw, "__esModule", { value: true });
  const basedecoder_js_1 = __importDefault(requireBasedecoder());
  const MIN_BITS = 9;
  const CLEAR_CODE = 256;
  const EOI_CODE = 257;
  const MAX_BYTELENGTH = 12;
  function getByte(array, position, length) {
    const d = position % 8;
    const a = Math.floor(position / 8);
    const de = 8 - d;
    const ef = position + length - (a + 1) * 8;
    let fg = 8 * (a + 2) - (position + length);
    const dg = (a + 2) * 8 - position;
    fg = Math.max(0, fg);
    if (a >= array.length) {
      console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)");
      return EOI_CODE;
    }
    let chunk1 = array[a] & 2 ** (8 - d) - 1;
    chunk1 <<= length - de;
    let chunks = chunk1;
    if (a + 1 < array.length) {
      let chunk2 = array[a + 1] >>> fg;
      chunk2 <<= Math.max(0, length - dg);
      chunks += chunk2;
    }
    if (ef > 8 && a + 2 < array.length) {
      const hi = (a + 3) * 8 - (position + length);
      const chunk3 = array[a + 2] >>> hi;
      chunks += chunk3;
    }
    return chunks;
  }
  function appendReversed(dest, source) {
    for (let i = source.length - 1; i >= 0; i--) {
      dest.push(source[i]);
    }
    return dest;
  }
  function decompress(input) {
    const dictionaryIndex = new Uint16Array(4093);
    const dictionaryChar = new Uint8Array(4093);
    for (let i = 0; i <= 257; i++) {
      dictionaryIndex[i] = 4096;
      dictionaryChar[i] = i;
    }
    let dictionaryLength = 258;
    let byteLength = MIN_BITS;
    let position = 0;
    function initDictionary() {
      dictionaryLength = 258;
      byteLength = MIN_BITS;
    }
    function getNext(array2) {
      const byte = getByte(array2, position, byteLength);
      position += byteLength;
      return byte;
    }
    function addToDictionary(i, c) {
      dictionaryChar[dictionaryLength] = c;
      dictionaryIndex[dictionaryLength] = i;
      dictionaryLength++;
      return dictionaryLength - 1;
    }
    function getDictionaryReversed(n) {
      const rev = [];
      for (let i = n; i !== 4096; i = dictionaryIndex[i]) {
        rev.push(dictionaryChar[i]);
      }
      return rev;
    }
    const result = [];
    initDictionary();
    const array = new Uint8Array(input);
    let code = getNext(array);
    let oldCode;
    while (code !== EOI_CODE) {
      if (code === CLEAR_CODE) {
        initDictionary();
        code = getNext(array);
        while (code === CLEAR_CODE) {
          code = getNext(array);
        }
        if (code === EOI_CODE) {
          break;
        } else if (code > CLEAR_CODE) {
          throw new Error(`corrupted code at scanline ${code}`);
        } else {
          const val = getDictionaryReversed(code);
          appendReversed(result, val);
          oldCode = code;
        }
      } else if (code < dictionaryLength) {
        const val = getDictionaryReversed(code);
        appendReversed(result, val);
        addToDictionary(oldCode, val[val.length - 1]);
        oldCode = code;
      } else {
        const oldVal = getDictionaryReversed(oldCode);
        if (!oldVal) {
          throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);
        }
        appendReversed(result, oldVal);
        result.push(oldVal[oldVal.length - 1]);
        addToDictionary(oldCode, oldVal[oldVal.length - 1]);
        oldCode = code;
      }
      if (dictionaryLength + 1 >= 2 ** byteLength) {
        if (byteLength === MAX_BYTELENGTH) {
          oldCode = void 0;
        } else {
          byteLength++;
        }
      }
      code = getNext(array);
    }
    return new Uint8Array(result);
  }
  class LZWDecoder extends basedecoder_js_1.default {
    decodeBlock(buffer2) {
      return decompress(buffer2).buffer;
    }
  }
  lzw.default = LZWDecoder;
  return lzw;
}
var jpeg = {};
var hasRequiredJpeg;
function requireJpeg() {
  if (hasRequiredJpeg)
    return jpeg;
  hasRequiredJpeg = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(jpeg, "__esModule", { value: true });
  const basedecoder_js_1 = __importDefault(requireBasedecoder());
  const dctZigZag = new Int32Array([
    0,
    1,
    8,
    16,
    9,
    2,
    3,
    10,
    17,
    24,
    32,
    25,
    18,
    11,
    4,
    5,
    12,
    19,
    26,
    33,
    40,
    48,
    41,
    34,
    27,
    20,
    13,
    6,
    7,
    14,
    21,
    28,
    35,
    42,
    49,
    56,
    57,
    50,
    43,
    36,
    29,
    22,
    15,
    23,
    30,
    37,
    44,
    51,
    58,
    59,
    52,
    45,
    38,
    31,
    39,
    46,
    53,
    60,
    61,
    54,
    47,
    55,
    62,
    63
  ]);
  const dctCos1 = 4017;
  const dctSin1 = 799;
  const dctCos3 = 3406;
  const dctSin3 = 2276;
  const dctCos6 = 1567;
  const dctSin6 = 3784;
  const dctSqrt2 = 5793;
  const dctSqrt1d2 = 2896;
  function buildHuffmanTable(codeLengths, values) {
    let k = 0;
    const code = [];
    let length = 16;
    while (length > 0 && !codeLengths[length - 1]) {
      --length;
    }
    code.push({ children: [], index: 0 });
    let p = code[0];
    let q;
    for (let i = 0; i < length; i++) {
      for (let j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = { children: [], index: 0 });
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        code.push(q = { children: [], index: 0 });
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }
  function decodeScan(data, initialOffset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
    const { mcusPerLine, progressive } = frame;
    const startOffset = initialOffset;
    let offset = initialOffset;
    let bitsData = 0;
    let bitsCount = 0;
    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return bitsData >> bitsCount & 1;
      }
      bitsData = data[offset++];
      if (bitsData === 255) {
        const nextByte = data[offset++];
        if (nextByte) {
          throw new Error(`unexpected marker: ${(bitsData << 8 | nextByte).toString(16)}`);
        }
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }
    function decodeHuffman(tree) {
      let node = tree;
      let bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === "number") {
          return node;
        }
        if (typeof node !== "object") {
          throw new Error("invalid huffman sequence");
        }
      }
      return null;
    }
    function receive(initialLength) {
      let length = initialLength;
      let n2 = 0;
      while (length > 0) {
        const bit = readBit();
        if (bit === null) {
          return void 0;
        }
        n2 = n2 << 1 | bit;
        --length;
      }
      return n2;
    }
    function receiveAndExtend(length) {
      const n2 = receive(length);
      if (n2 >= 1 << length - 1) {
        return n2;
      }
      return n2 + (-1 << length) + 1;
    }
    function decodeBaseline(component2, zz) {
      const t = decodeHuffman(component2.huffmanTableDC);
      const diff = t === 0 ? 0 : receiveAndExtend(t);
      component2.pred += diff;
      zz[0] = component2.pred;
      let k2 = 1;
      while (k2 < 64) {
        const rs = decodeHuffman(component2.huffmanTableAC);
        const s = rs & 15;
        const r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            break;
          }
          k2 += 16;
        } else {
          k2 += r;
          const z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s);
          k2++;
        }
      }
    }
    function decodeDCFirst(component2, zz) {
      const t = decodeHuffman(component2.huffmanTableDC);
      const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
      component2.pred += diff;
      zz[0] = component2.pred;
    }
    function decodeDCSuccessive(component2, zz) {
      zz[0] |= readBit() << successive;
    }
    let eobrun = 0;
    function decodeACFirst(component2, zz) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      let k2 = spectralStart;
      const e = spectralEnd;
      while (k2 <= e) {
        const rs = decodeHuffman(component2.huffmanTableAC);
        const s = rs & 15;
        const r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k2 += 16;
        } else {
          k2 += r;
          const z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s) * (1 << successive);
          k2++;
        }
      }
    }
    let successiveACState = 0;
    let successiveACNextValue;
    function decodeACSuccessive(component2, zz) {
      let k2 = spectralStart;
      const e = spectralEnd;
      let r = 0;
      while (k2 <= e) {
        const z = dctZigZag[k2];
        const direction = zz[z] < 0 ? -1 : 1;
        switch (successiveACState) {
          case 0: {
            const rs = decodeHuffman(component2.huffmanTableAC);
            const s = rs & 15;
            r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1) {
                throw new Error("invalid ACn encoding");
              }
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          }
          case 1:
          case 2:
            if (zz[z]) {
              zz[z] += (readBit() << successive) * direction;
            } else {
              r--;
              if (r === 0) {
                successiveACState = successiveACState === 2 ? 3 : 0;
              }
            }
            break;
          case 3:
            if (zz[z]) {
              zz[z] += (readBit() << successive) * direction;
            } else {
              zz[z] = successiveACNextValue << successive;
              successiveACState = 0;
            }
            break;
          case 4:
            if (zz[z]) {
              zz[z] += (readBit() << successive) * direction;
            }
            break;
        }
        k2++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0) {
          successiveACState = 0;
        }
      }
    }
    function decodeMcu(component2, decodeFunction, mcu2, row, col) {
      const mcuRow = mcu2 / mcusPerLine | 0;
      const mcuCol = mcu2 % mcusPerLine;
      const blockRow = mcuRow * component2.v + row;
      const blockCol = mcuCol * component2.h + col;
      decodeFunction(component2, component2.blocks[blockRow][blockCol]);
    }
    function decodeBlock(component2, decodeFunction, mcu2) {
      const blockRow = mcu2 / component2.blocksPerLine | 0;
      const blockCol = mcu2 % component2.blocksPerLine;
      decodeFunction(component2, component2.blocks[blockRow][blockCol]);
    }
    const componentsLength = components.length;
    let component;
    let i;
    let j;
    let k;
    let n;
    let decodeFn;
    if (progressive) {
      if (spectralStart === 0) {
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      } else {
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      }
    } else {
      decodeFn = decodeBaseline;
    }
    let mcu = 0;
    let marker;
    let mcuExpected;
    if (componentsLength === 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    const usedResetInterval = resetInterval || mcuExpected;
    while (mcu < mcuExpected) {
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;
      if (componentsLength === 1) {
        component = components[0];
        for (n = 0; n < usedResetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < usedResetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            const { h, v } = component;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
          if (mcu === mcuExpected) {
            break;
          }
        }
      }
      bitsCount = 0;
      marker = data[offset] << 8 | data[offset + 1];
      if (marker < 65280) {
        throw new Error("marker was not found");
      }
      if (marker >= 65488 && marker <= 65495) {
        offset += 2;
      } else {
        break;
      }
    }
    return offset - startOffset;
  }
  function buildComponentData(frame, component) {
    const lines = [];
    const { blocksPerLine, blocksPerColumn } = component;
    const samplesPerLine = blocksPerLine << 3;
    const R = new Int32Array(64);
    const r = new Uint8Array(64);
    function quantizeAndInverse(zz, dataOut, dataIn) {
      const qt = component.quantizationTable;
      let v0;
      let v1;
      let v2;
      let v3;
      let v4;
      let v5;
      let v6;
      let v7;
      let t;
      const p = dataIn;
      let i;
      for (i = 0; i < 64; i++) {
        p[i] = zz[i] * qt[i];
      }
      for (i = 0; i < 8; ++i) {
        const row = 8 * i;
        if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 && p[7 + row] === 0) {
          t = dctSqrt2 * p[0 + row] + 512 >> 10;
          p[0 + row] = t;
          p[1 + row] = t;
          p[2 + row] = t;
          p[3 + row] = t;
          p[4 + row] = t;
          p[5 + row] = t;
          p[6 + row] = t;
          p[7 + row] = t;
          continue;
        }
        v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
        v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
        v2 = p[2 + row];
        v3 = p[6 + row];
        v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
        v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
        v5 = p[3 + row] << 4;
        v6 = p[5 + row] << 4;
        t = v0 - v1 + 1 >> 1;
        v0 = v0 + v1 + 1 >> 1;
        v1 = t;
        t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
        v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
        v3 = t;
        t = v4 - v6 + 1 >> 1;
        v4 = v4 + v6 + 1 >> 1;
        v6 = t;
        t = v7 + v5 + 1 >> 1;
        v5 = v7 - v5 + 1 >> 1;
        v7 = t;
        t = v0 - v3 + 1 >> 1;
        v0 = v0 + v3 + 1 >> 1;
        v3 = t;
        t = v1 - v2 + 1 >> 1;
        v1 = v1 + v2 + 1 >> 1;
        v2 = t;
        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
        v7 = t;
        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
        v6 = t;
        p[0 + row] = v0 + v7;
        p[7 + row] = v0 - v7;
        p[1 + row] = v1 + v6;
        p[6 + row] = v1 - v6;
        p[2 + row] = v2 + v5;
        p[5 + row] = v2 - v5;
        p[3 + row] = v3 + v4;
        p[4 + row] = v3 - v4;
      }
      for (i = 0; i < 8; ++i) {
        const col = i;
        if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 && p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 && p[7 * 8 + col] === 0) {
          t = dctSqrt2 * dataIn[i + 0] + 8192 >> 14;
          p[0 * 8 + col] = t;
          p[1 * 8 + col] = t;
          p[2 * 8 + col] = t;
          p[3 * 8 + col] = t;
          p[4 * 8 + col] = t;
          p[5 * 8 + col] = t;
          p[6 * 8 + col] = t;
          p[7 * 8 + col] = t;
          continue;
        }
        v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
        v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
        v2 = p[2 * 8 + col];
        v3 = p[6 * 8 + col];
        v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
        v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
        v5 = p[3 * 8 + col];
        v6 = p[5 * 8 + col];
        t = v0 - v1 + 1 >> 1;
        v0 = v0 + v1 + 1 >> 1;
        v1 = t;
        t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
        v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
        v3 = t;
        t = v4 - v6 + 1 >> 1;
        v4 = v4 + v6 + 1 >> 1;
        v6 = t;
        t = v7 + v5 + 1 >> 1;
        v5 = v7 - v5 + 1 >> 1;
        v7 = t;
        t = v0 - v3 + 1 >> 1;
        v0 = v0 + v3 + 1 >> 1;
        v3 = t;
        t = v1 - v2 + 1 >> 1;
        v1 = v1 + v2 + 1 >> 1;
        v2 = t;
        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
        v7 = t;
        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
        v6 = t;
        p[0 * 8 + col] = v0 + v7;
        p[7 * 8 + col] = v0 - v7;
        p[1 * 8 + col] = v1 + v6;
        p[6 * 8 + col] = v1 - v6;
        p[2 * 8 + col] = v2 + v5;
        p[5 * 8 + col] = v2 - v5;
        p[3 * 8 + col] = v3 + v4;
        p[4 * 8 + col] = v3 - v4;
      }
      for (i = 0; i < 64; ++i) {
        const sample = 128 + (p[i] + 8 >> 4);
        if (sample < 0) {
          dataOut[i] = 0;
        } else if (sample > 255) {
          dataOut[i] = 255;
        } else {
          dataOut[i] = sample;
        }
      }
    }
    for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      const scanLine = blockRow << 3;
      for (let i = 0; i < 8; i++) {
        lines.push(new Uint8Array(samplesPerLine));
      }
      for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
        let offset = 0;
        const sample = blockCol << 3;
        for (let j = 0; j < 8; j++) {
          const line = lines[scanLine + j];
          for (let i = 0; i < 8; i++) {
            line[sample + i] = r[offset++];
          }
        }
      }
    }
    return lines;
  }
  class JpegStreamReader {
    constructor() {
      this.jfif = null;
      this.adobe = null;
      this.quantizationTables = [];
      this.huffmanTablesAC = [];
      this.huffmanTablesDC = [];
      this.resetFrames();
    }
    resetFrames() {
      this.frames = [];
    }
    parse(data) {
      let offset = 0;
      function readUint16() {
        const value = data[offset] << 8 | data[offset + 1];
        offset += 2;
        return value;
      }
      function readDataBlock() {
        const length = readUint16();
        const array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }
      function prepareComponents(frame) {
        let maxH = 0;
        let maxV = 0;
        let component;
        let componentId;
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            if (maxH < component.h) {
              maxH = component.h;
            }
            if (maxV < component.v) {
              maxV = component.v;
            }
          }
        }
        const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
        const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
            const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);
            const blocksPerLineForMcu = mcusPerLine * component.h;
            const blocksPerColumnForMcu = mcusPerColumn * component.v;
            const blocks = [];
            for (let i = 0; i < blocksPerColumnForMcu; i++) {
              const row = [];
              for (let j = 0; j < blocksPerLineForMcu; j++) {
                row.push(new Int32Array(64));
              }
              blocks.push(row);
            }
            component.blocksPerLine = blocksPerLine;
            component.blocksPerColumn = blocksPerColumn;
            component.blocks = blocks;
          }
        }
        frame.maxH = maxH;
        frame.maxV = maxV;
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }
      let fileMarker = readUint16();
      if (fileMarker !== 65496) {
        throw new Error("SOI not found");
      }
      fileMarker = readUint16();
      while (fileMarker !== 65497) {
        switch (fileMarker) {
          case 65280:
            break;
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534: {
            const appData = readDataBlock();
            if (fileMarker === 65504) {
              if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                this.jfif = {
                  version: { major: appData[5], minor: appData[6] },
                  densityUnits: appData[7],
                  xDensity: appData[8] << 8 | appData[9],
                  yDensity: appData[10] << 8 | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            if (fileMarker === 65518) {
              if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                this.adobe = {
                  version: appData[6],
                  flags0: appData[7] << 8 | appData[8],
                  flags1: appData[9] << 8 | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;
          }
          case 65499: {
            const quantizationTablesLength = readUint16();
            const quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              const quantizationTableSpec = data[offset++];
              const tableData = new Int32Array(64);
              if (quantizationTableSpec >> 4 === 0) {
                for (let j = 0; j < 64; j++) {
                  const z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if (quantizationTableSpec >> 4 === 1) {
                for (let j = 0; j < 64; j++) {
                  const z = dctZigZag[j];
                  tableData[z] = readUint16();
                }
              } else {
                throw new Error("DQT: invalid table spec");
              }
              this.quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;
          }
          case 65472:
          case 65473:
          case 65474: {
            readUint16();
            const frame = {
              extended: fileMarker === 65473,
              progressive: fileMarker === 65474,
              precision: data[offset++],
              scanLines: readUint16(),
              samplesPerLine: readUint16(),
              components: {},
              componentsOrder: []
            };
            const componentsCount = data[offset++];
            let componentId;
            for (let i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              const h = data[offset + 1] >> 4;
              const v = data[offset + 1] & 15;
              const qId = data[offset + 2];
              frame.componentsOrder.push(componentId);
              frame.components[componentId] = {
                h,
                v,
                quantizationIdx: qId
              };
              offset += 3;
            }
            prepareComponents(frame);
            this.frames.push(frame);
            break;
          }
          case 65476: {
            const huffmanLength = readUint16();
            for (let i = 2; i < huffmanLength; ) {
              const huffmanTableSpec = data[offset++];
              const codeLengths = new Uint8Array(16);
              let codeLengthSum = 0;
              for (let j = 0; j < 16; j++, offset++) {
                codeLengths[j] = data[offset];
                codeLengthSum += codeLengths[j];
              }
              const huffmanValues = new Uint8Array(codeLengthSum);
              for (let j = 0; j < codeLengthSum; j++, offset++) {
                huffmanValues[j] = data[offset];
              }
              i += 17 + codeLengthSum;
              if (huffmanTableSpec >> 4 === 0) {
                this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
              } else {
                this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
              }
            }
            break;
          }
          case 65501:
            readUint16();
            this.resetInterval = readUint16();
            break;
          case 65498: {
            readUint16();
            const selectorsCount = data[offset++];
            const components = [];
            const frame = this.frames[0];
            for (let i = 0; i < selectorsCount; i++) {
              const component = frame.components[data[offset++]];
              const tableSpec = data[offset++];
              component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            const spectralStart = data[offset++];
            const spectralEnd = data[offset++];
            const successiveApproximation = data[offset++];
            const processed = decodeScan(data, offset, frame, components, this.resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          }
          case 65535:
            if (data[offset] !== 255) {
              offset--;
            }
            break;
          default:
            if (data[offset - 3] === 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
              offset -= 3;
              break;
            }
            throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);
        }
        fileMarker = readUint16();
      }
    }
    getResult() {
      const { frames } = this;
      if (this.frames.length === 0) {
        throw new Error("no frames were decoded");
      } else if (this.frames.length > 1) {
        console.warn("more than one frame is not supported");
      }
      for (let i = 0; i < this.frames.length; i++) {
        const cp = this.frames[i].components;
        for (const j of Object.keys(cp)) {
          cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];
          delete cp[j].quantizationIdx;
        }
      }
      const frame = frames[0];
      const { components, componentsOrder } = frame;
      const outComponents = [];
      const width = frame.samplesPerLine;
      const height = frame.scanLines;
      for (let i = 0; i < componentsOrder.length; i++) {
        const component = components[componentsOrder[i]];
        outComponents.push({
          lines: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV
        });
      }
      const out = new Uint8Array(width * height * outComponents.length);
      let oi = 0;
      for (let y = 0; y < height; ++y) {
        for (let x = 0; x < width; ++x) {
          for (let i = 0; i < outComponents.length; ++i) {
            const component = outComponents[i];
            out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];
            ++oi;
          }
        }
      }
      return out;
    }
  }
  class JpegDecoder extends basedecoder_js_1.default {
    constructor(fileDirectory) {
      super();
      this.reader = new JpegStreamReader();
      if (fileDirectory.JPEGTables) {
        this.reader.parse(fileDirectory.JPEGTables);
      }
    }
    decodeBlock(buffer2) {
      this.reader.resetFrames();
      this.reader.parse(new Uint8Array(buffer2));
      return this.reader.getResult().buffer;
    }
  }
  jpeg.default = JpegDecoder;
  return jpeg;
}
var deflate$2 = {};
var pako = {};
var deflate$1 = {};
var deflate = {};
var trees = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees)
    return trees;
  hasRequiredTrees = 1;
  const Z_FIXED = 4;
  const Z_BINARY = 0;
  const Z_TEXT = 1;
  const Z_UNKNOWN = 2;
  function zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  const STORED_BLOCK = 0;
  const STATIC_TREES = 1;
  const DYN_TREES = 2;
  const MIN_MATCH = 3;
  const MAX_MATCH = 258;
  const LENGTH_CODES = 29;
  const LITERALS = 256;
  const L_CODES = LITERALS + 1 + LENGTH_CODES;
  const D_CODES = 30;
  const BL_CODES = 19;
  const HEAP_SIZE = 2 * L_CODES + 1;
  const MAX_BITS = 15;
  const Buf_size = 16;
  const MAX_BL_BITS = 7;
  const END_BLOCK = 256;
  const REP_3_6 = 16;
  const REPZ_3_10 = 17;
  const REPZ_11_138 = 18;
  const extra_lbits = (
    /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
  );
  const extra_dbits = (
    /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
  );
  const extra_blbits = (
    /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
  );
  const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  const DIST_CODE_LEN = 512;
  const static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  const static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  const _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  const _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  const base_length = new Array(LENGTH_CODES);
  zero(base_length);
  const base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  let static_l_desc;
  let static_d_desc;
  let static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  const d_code = (dist) => {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  };
  const put_short = (s, w) => {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  };
  const send_bits = (s, value, length) => {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  };
  const send_code = (s, c, tree) => {
    send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  };
  const bi_reverse = (code, len) => {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  };
  const bi_flush = (s) => {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  };
  const gen_bitlen = (s, desc) => {
    const tree = desc.dyn_tree;
    const max_code = desc.max_code;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const extra = desc.stat_desc.extra_bits;
    const base2 = desc.stat_desc.extra_base;
    const max_length = desc.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f;
    let overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base2) {
        xbits = extra[n - base2];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  };
  const gen_codes = (tree, max_code, bl_count) => {
    const next_code = new Array(MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  };
  const tr_static_init = () => {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  };
  const init_block = (s) => {
    let n;
    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  };
  const bi_windup = (s) => {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  };
  const copy_block = (s, buf, len, header) => {
    bi_windup(s);
    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  };
  const smaller = (tree, n, m, depth) => {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  };
  const pqdownheap = (s, tree, k) => {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  };
  const compress_block = (s, ltree, dtree) => {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  };
  const build_tree = (s, desc) => {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  };
  const scan_tree = (s, tree, max_code) => {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  const send_tree = (s, tree, max_code) => {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  const build_bl_tree = (s) => {
    let max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  };
  const send_all_trees = (s, lcodes, dcodes, blcodes) => {
    let rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  };
  const detect_data_type = (s) => {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  };
  let static_init_done = false;
  const _tr_init = (s) => {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  };
  const _tr_stored_block = (s, buf, stored_len, last) => {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  };
  const _tr_align = (s) => {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  };
  const _tr_flush_block = (s, buf, stored_len, last) => {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  };
  const _tr_tally = (s, dist, lc) => {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  };
  trees._tr_init = _tr_init;
  trees._tr_stored_block = _tr_stored_block;
  trees._tr_flush_block = _tr_flush_block;
  trees._tr_tally = _tr_tally;
  trees._tr_align = _tr_align;
  return trees;
}
var adler32_1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32)
    return adler32_1;
  hasRequiredAdler32 = 1;
  const adler32 = (adler, buf, len, pos) => {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  };
  adler32_1 = adler32;
  return adler32_1;
}
var crc32_1;
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32)
    return crc32_1;
  hasRequiredCrc32 = 1;
  const makeTable = () => {
    let c, table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  };
  const crcTable = new Uint32Array(makeTable());
  const crc32 = (crc, buf, len, pos) => {
    const t = crcTable;
    const end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  };
  crc32_1 = crc32;
  return crc32_1;
}
var messages;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages)
    return messages;
  hasRequiredMessages = 1;
  messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants;
  hasRequiredConstants = 1;
  constants = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants;
}
var hasRequiredDeflate$2;
function requireDeflate$2() {
  if (hasRequiredDeflate$2)
    return deflate;
  hasRequiredDeflate$2 = 1;
  const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = requireTrees();
  const adler32 = requireAdler32();
  const crc32 = requireCrc32();
  const msg = requireMessages();
  const {
    Z_NO_FLUSH,
    Z_PARTIAL_FLUSH,
    Z_FULL_FLUSH,
    Z_FINISH,
    Z_BLOCK,
    Z_OK,
    Z_STREAM_END,
    Z_STREAM_ERROR,
    Z_DATA_ERROR,
    Z_BUF_ERROR,
    Z_DEFAULT_COMPRESSION,
    Z_FILTERED,
    Z_HUFFMAN_ONLY,
    Z_RLE,
    Z_FIXED,
    Z_DEFAULT_STRATEGY,
    Z_UNKNOWN,
    Z_DEFLATED
  } = requireConstants();
  const MAX_MEM_LEVEL = 9;
  const MAX_WBITS = 15;
  const DEF_MEM_LEVEL = 8;
  const LENGTH_CODES = 29;
  const LITERALS = 256;
  const L_CODES = LITERALS + 1 + LENGTH_CODES;
  const D_CODES = 30;
  const BL_CODES = 19;
  const HEAP_SIZE = 2 * L_CODES + 1;
  const MAX_BITS = 15;
  const MIN_MATCH = 3;
  const MAX_MATCH = 258;
  const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  const PRESET_DICT = 32;
  const INIT_STATE = 42;
  const EXTRA_STATE = 69;
  const NAME_STATE = 73;
  const COMMENT_STATE = 91;
  const HCRC_STATE = 103;
  const BUSY_STATE = 113;
  const FINISH_STATE = 666;
  const BS_NEED_MORE = 1;
  const BS_BLOCK_DONE = 2;
  const BS_FINISH_STARTED = 3;
  const BS_FINISH_DONE = 4;
  const OS_CODE = 3;
  const err = (strm, errorCode) => {
    strm.msg = msg[errorCode];
    return errorCode;
  };
  const rank = (f) => {
    return (f << 1) - (f > 4 ? 9 : 0);
  };
  const zero = (buf) => {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
  let HASH = HASH_ZLIB;
  const flush_pending = (strm) => {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  };
  const flush_block_only = (s, last) => {
    _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  };
  const put_byte = (s, b) => {
    s.pending_buf[s.pending++] = b;
  };
  const putShortMSB = (s, b) => {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  };
  const read_buf = (strm, buf, start2, size) => {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start2);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start2);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start2);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  };
  const longest_match = (s, cur_match) => {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match2;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match2 = cur_match;
      if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match2++;
      do {
      } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  };
  const fill_window = (s) => {
    const _w_size = s.w_size;
    let p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  };
  const deflate_stored = (s, flush) => {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  };
  const deflate_fast = (s, flush) => {
    let hash_head;
    let bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
        }
      } else {
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  const deflate_slow = (s, flush) => {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  const deflate_rle = (s, flush) => {
    let bflush;
    let prev;
    let scan, strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  const deflate_huff = (s, flush) => {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  const configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  const lm_init = (s) => {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  };
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  const deflateResetKeep = (strm) => {
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    const s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    _tr_init(s);
    return Z_OK;
  };
  const deflateReset = (strm) => {
    const ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  };
  const deflateSetHeader = (strm, head) => {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  };
  const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  };
  const deflateInit = (strm, level) => {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  };
  const deflate$12 = (strm, flush) => {
    let beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    const s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          _tr_align(s);
        } else if (flush !== Z_BLOCK) {
          _tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  };
  const deflateEnd = (strm) => {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    const status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  };
  const deflateSetDictionary = (strm, dictionary) => {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  };
  deflate.deflateInit = deflateInit;
  deflate.deflateInit2 = deflateInit2;
  deflate.deflateReset = deflateReset;
  deflate.deflateResetKeep = deflateResetKeep;
  deflate.deflateSetHeader = deflateSetHeader;
  deflate.deflate = deflate$12;
  deflate.deflateEnd = deflateEnd;
  deflate.deflateSetDictionary = deflateSetDictionary;
  deflate.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate;
}
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  const _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  common.assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (const p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  common.flattenChunks = (chunks) => {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  };
  return common;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings)
    return strings;
  hasRequiredStrings = 1;
  let STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  const _utf8len = new Uint8Array(256);
  for (let q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  strings.string2buf = (str) => {
    if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str);
    }
    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  const buf2binstring = (buf, len) => {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  };
  strings.buf2string = (buf, max) => {
    const len = max || buf.length;
    if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max));
    }
    let i, out;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  strings.utf8border = (buf, max) => {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
  return strings;
}
var zstream;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream)
    return zstream;
  hasRequiredZstream = 1;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  zstream = ZStream;
  return zstream;
}
var hasRequiredDeflate$1;
function requireDeflate$1() {
  if (hasRequiredDeflate$1)
    return deflate$1;
  hasRequiredDeflate$1 = 1;
  const zlib_deflate = requireDeflate$2();
  const utils2 = requireCommon();
  const strings2 = requireStrings();
  const msg = requireMessages();
  const ZStream = requireZstream();
  const toString2 = Object.prototype.toString;
  const {
    Z_NO_FLUSH,
    Z_SYNC_FLUSH,
    Z_FULL_FLUSH,
    Z_FINISH,
    Z_OK,
    Z_STREAM_END,
    Z_DEFAULT_COMPRESSION,
    Z_DEFAULT_STRATEGY,
    Z_DEFLATED
  } = requireConstants();
  function Deflate(options) {
    this.options = utils2.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = strings2.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode)
      _flush_mode = flush_mode;
    else
      _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings2.string2buf(data);
    } else if (toString2.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      this.result = utils2.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate2(input, options) {
    const deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate2(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate2(input, options);
  }
  deflate$1.Deflate = Deflate;
  deflate$1.deflate = deflate2;
  deflate$1.deflateRaw = deflateRaw;
  deflate$1.gzip = gzip;
  deflate$1.constants = requireConstants();
  return deflate$1;
}
var inflate$1 = {};
var inflate = {};
var inffast;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast)
    return inffast;
  hasRequiredInffast = 1;
  const BAD = 30;
  const TYPE = 12;
  inffast = function inflate_fast(strm, start2) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input, output;
    const state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start2 - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return inffast;
}
var inftrees;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees)
    return inftrees;
  hasRequiredInftrees = 1;
  const MAXBITS = 15;
  const ENOUGH_LENS = 852;
  const ENOUGH_DISTS = 592;
  const CODES = 0;
  const LENS = 1;
  const DISTS = 2;
  const lbase = new Uint16Array([
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ]);
  const lext = new Uint8Array([
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ]);
  const dbase = new Uint16Array([
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ]);
  const dext = new Uint8Array([
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ]);
  const inflate_table = (type, lens, lens_index, codes2, table, table_index, work, opts) => {
    const bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min = 0, max = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base2 = null;
    let base_index = 0;
    let end;
    const count = new Uint16Array(MAXBITS + 1);
    const offs = new Uint16Array(MAXBITS + 1);
    let extra = null;
    let extra_index = 0;
    let here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes2; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes2; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base2 = extra = work;
      end = 19;
    } else if (type === LENS) {
      base2 = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base2 = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base2[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  inftrees = inflate_table;
  return inftrees;
}
var hasRequiredInflate$1;
function requireInflate$1() {
  if (hasRequiredInflate$1)
    return inflate;
  hasRequiredInflate$1 = 1;
  const adler32 = requireAdler32();
  const crc32 = requireCrc32();
  const inflate_fast = requireInffast();
  const inflate_table = requireInftrees();
  const CODES = 0;
  const LENS = 1;
  const DISTS = 2;
  const {
    Z_FINISH,
    Z_BLOCK,
    Z_TREES,
    Z_OK,
    Z_STREAM_END,
    Z_NEED_DICT,
    Z_STREAM_ERROR,
    Z_DATA_ERROR,
    Z_MEM_ERROR,
    Z_BUF_ERROR,
    Z_DEFLATED
  } = requireConstants();
  const HEAD = 1;
  const FLAGS = 2;
  const TIME = 3;
  const OS = 4;
  const EXLEN = 5;
  const EXTRA = 6;
  const NAME = 7;
  const COMMENT = 8;
  const HCRC = 9;
  const DICTID = 10;
  const DICT = 11;
  const TYPE = 12;
  const TYPEDO = 13;
  const STORED = 14;
  const COPY_ = 15;
  const COPY = 16;
  const TABLE = 17;
  const LENLENS = 18;
  const CODELENS = 19;
  const LEN_ = 20;
  const LEN = 21;
  const LENEXT = 22;
  const DIST = 23;
  const DISTEXT = 24;
  const MATCH = 25;
  const LIT = 26;
  const CHECK = 27;
  const LENGTH = 28;
  const DONE = 29;
  const BAD = 30;
  const MEM = 31;
  const SYNC = 32;
  const ENOUGH_LENS = 852;
  const ENOUGH_DISTS = 592;
  const MAX_WBITS = 15;
  const DEF_WBITS = MAX_WBITS;
  const zswap32 = (q) => {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  };
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  const inflateResetKeep = (strm) => {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  };
  const inflateReset = (strm) => {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  };
  const inflateReset2 = (strm, windowBits) => {
    let wrap;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    const state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };
  const inflateInit2 = (strm, windowBits) => {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    const state = new InflateState();
    strm.state = state;
    state.window = null;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  };
  const inflateInit = (strm) => {
    return inflateInit2(strm, DEF_WBITS);
  };
  let virgin = true;
  let lenfix, distfix;
  const fixedtables = (state) => {
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };
  const updatewindow = (strm, src, end, copy) => {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  };
  const inflate$12 = (strm, flush) => {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    const order = (
      /* permutation of code lengths */
      new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(
                    input.subarray(
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      next + copy
                    ),
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
        ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };
  const inflateEnd = (strm) => {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  };
  const inflateGetHeader = (strm, head) => {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    const state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  };
  const inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  };
  inflate.inflateReset = inflateReset;
  inflate.inflateReset2 = inflateReset2;
  inflate.inflateResetKeep = inflateResetKeep;
  inflate.inflateInit = inflateInit;
  inflate.inflateInit2 = inflateInit2;
  inflate.inflate = inflate$12;
  inflate.inflateEnd = inflateEnd;
  inflate.inflateGetHeader = inflateGetHeader;
  inflate.inflateSetDictionary = inflateSetDictionary;
  inflate.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate;
}
var gzheader;
var hasRequiredGzheader;
function requireGzheader() {
  if (hasRequiredGzheader)
    return gzheader;
  hasRequiredGzheader = 1;
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  gzheader = GZheader;
  return gzheader;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate)
    return inflate$1;
  hasRequiredInflate = 1;
  const zlib_inflate = requireInflate$1();
  const utils2 = requireCommon();
  const strings2 = requireStrings();
  const msg = requireMessages();
  const ZStream = requireZstream();
  const GZheader = requireGzheader();
  const toString2 = Object.prototype.toString;
  const {
    Z_NO_FLUSH,
    Z_FINISH,
    Z_OK,
    Z_STREAM_END,
    Z_NEED_DICT,
    Z_STREAM_ERROR,
    Z_DATA_ERROR,
    Z_MEM_ERROR
  } = requireConstants();
  function Inflate(options) {
    this.options = utils2.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings2.string2buf(opt.dictionary);
      } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode)
      _flush_mode = flush_mode;
    else
      _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString2.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          status = Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings2.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === Z_OK && last_avail_out === 0)
        continue;
      if (status === Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate2(input, options) {
    const inflator = new Inflate(options);
    inflator.push(input);
    if (inflator.err)
      throw inflator.msg || msg[inflator.err];
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate2(input, options);
  }
  inflate$1.Inflate = Inflate;
  inflate$1.inflate = inflate2;
  inflate$1.inflateRaw = inflateRaw;
  inflate$1.ungzip = inflate2;
  inflate$1.constants = requireConstants();
  return inflate$1;
}
var hasRequiredPako;
function requirePako() {
  if (hasRequiredPako)
    return pako;
  hasRequiredPako = 1;
  const { Deflate, deflate: deflate2, deflateRaw, gzip } = requireDeflate$1();
  const { Inflate, inflate: inflate2, inflateRaw, ungzip } = requireInflate();
  const constants2 = requireConstants();
  pako.Deflate = Deflate;
  pako.deflate = deflate2;
  pako.deflateRaw = deflateRaw;
  pako.gzip = gzip;
  pako.Inflate = Inflate;
  pako.inflate = inflate2;
  pako.inflateRaw = inflateRaw;
  pako.ungzip = ungzip;
  pako.constants = constants2;
  return pako;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate)
    return deflate$2;
  hasRequiredDeflate = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(deflate$2, "__esModule", { value: true });
  const pako_1 = requirePako();
  const basedecoder_js_1 = __importDefault(requireBasedecoder());
  class DeflateDecoder extends basedecoder_js_1.default {
    decodeBlock(buffer2) {
      return (0, pako_1.inflate)(new Uint8Array(buffer2)).buffer;
    }
  }
  deflate$2.default = DeflateDecoder;
  return deflate$2;
}
var packbits = {};
var hasRequiredPackbits;
function requirePackbits() {
  if (hasRequiredPackbits)
    return packbits;
  hasRequiredPackbits = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(packbits, "__esModule", { value: true });
  const basedecoder_js_1 = __importDefault(requireBasedecoder());
  class PackbitsDecoder extends basedecoder_js_1.default {
    decodeBlock(buffer2) {
      const dataView = new DataView(buffer2);
      const out = [];
      for (let i = 0; i < buffer2.byteLength; ++i) {
        let header = dataView.getInt8(i);
        if (header < 0) {
          const next = dataView.getUint8(i + 1);
          header = -header;
          for (let j = 0; j <= header; ++j) {
            out.push(next);
          }
          i += 1;
        } else {
          for (let j = 0; j <= header; ++j) {
            out.push(dataView.getUint8(i + j + 1));
          }
          i += header + 1;
        }
      }
      return new Uint8Array(out).buffer;
    }
  }
  packbits.default = PackbitsDecoder;
  return packbits;
}
var lerc = {};
var LercDecodeExports = {};
var LercDecode = {
  get exports() {
    return LercDecodeExports;
  },
  set exports(v) {
    LercDecodeExports = v;
  }
};
var hasRequiredLercDecode;
function requireLercDecode() {
  if (hasRequiredLercDecode)
    return LercDecodeExports;
  hasRequiredLercDecode = 1;
  (function(module) {
    /* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */
    (function() {
      var LercDecode2 = function() {
        var CntZImage = {};
        CntZImage.defaultNoDataValue = -34027999387901484e22;
        CntZImage.decode = function(input, options) {
          options = options || {};
          var skipMask = options.encodedMaskData || options.encodedMaskData === null;
          var parsedData = parse2(input, options.inputOffset || 0, skipMask);
          var noDataValue = options.noDataValue !== null ? options.noDataValue : CntZImage.defaultNoDataValue;
          var uncompressedData = uncompressPixelValues(
            parsedData,
            options.pixelType || Float32Array,
            options.encodedMaskData,
            noDataValue,
            options.returnMask
          );
          var result = {
            width: parsedData.width,
            height: parsedData.height,
            pixelData: uncompressedData.resultPixels,
            minValue: uncompressedData.minValue,
            maxValue: parsedData.pixels.maxValue,
            noDataValue
          };
          if (uncompressedData.resultMask) {
            result.maskData = uncompressedData.resultMask;
          }
          if (options.returnEncodedMask && parsedData.mask) {
            result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;
          }
          if (options.returnFileInfo) {
            result.fileInfo = formatFileInfo(parsedData);
            if (options.computeUsedBitDepths) {
              result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);
            }
          }
          return result;
        };
        var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {
          var blockIdx = 0;
          var numX = data.pixels.numBlocksX;
          var numY = data.pixels.numBlocksY;
          var blockWidth = Math.floor(data.width / numX);
          var blockHeight = Math.floor(data.height / numY);
          var scale2 = 2 * data.maxZError;
          var minValue = Number.MAX_VALUE, currentValue;
          maskBitset = maskBitset || (data.mask ? data.mask.bitset : null);
          var resultPixels, resultMask;
          resultPixels = new TypedArrayClass(data.width * data.height);
          if (storeDecodedMask && maskBitset) {
            resultMask = new Uint8Array(data.width * data.height);
          }
          var blockDataBuffer = new Float32Array(blockWidth * blockHeight);
          var xx, yy;
          for (var y = 0; y <= numY; y++) {
            var thisBlockHeight = y !== numY ? blockHeight : data.height % numY;
            if (thisBlockHeight === 0) {
              continue;
            }
            for (var x = 0; x <= numX; x++) {
              var thisBlockWidth = x !== numX ? blockWidth : data.width % numX;
              if (thisBlockWidth === 0) {
                continue;
              }
              var outPtr = y * data.width * blockHeight + x * blockWidth;
              var outStride = data.width - thisBlockWidth;
              var block = data.pixels.blocks[blockIdx];
              var blockData, blockPtr, constValue;
              if (block.encoding < 2) {
                if (block.encoding === 0) {
                  blockData = block.rawData;
                } else {
                  unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale2, blockDataBuffer, data.pixels.maxValue);
                  blockData = blockDataBuffer;
                }
                blockPtr = 0;
              } else if (block.encoding === 2) {
                constValue = 0;
              } else {
                constValue = block.offset;
              }
              var maskByte;
              if (maskBitset) {
                for (yy = 0; yy < thisBlockHeight; yy++) {
                  if (outPtr & 7) {
                    maskByte = maskBitset[outPtr >> 3];
                    maskByte <<= outPtr & 7;
                  }
                  for (xx = 0; xx < thisBlockWidth; xx++) {
                    if (!(outPtr & 7)) {
                      maskByte = maskBitset[outPtr >> 3];
                    }
                    if (maskByte & 128) {
                      if (resultMask) {
                        resultMask[outPtr] = 1;
                      }
                      currentValue = block.encoding < 2 ? blockData[blockPtr++] : constValue;
                      minValue = minValue > currentValue ? currentValue : minValue;
                      resultPixels[outPtr++] = currentValue;
                    } else {
                      if (resultMask) {
                        resultMask[outPtr] = 0;
                      }
                      resultPixels[outPtr++] = noDataValue;
                    }
                    maskByte <<= 1;
                  }
                  outPtr += outStride;
                }
              } else {
                if (block.encoding < 2) {
                  for (yy = 0; yy < thisBlockHeight; yy++) {
                    for (xx = 0; xx < thisBlockWidth; xx++) {
                      currentValue = blockData[blockPtr++];
                      minValue = minValue > currentValue ? currentValue : minValue;
                      resultPixels[outPtr++] = currentValue;
                    }
                    outPtr += outStride;
                  }
                } else {
                  minValue = minValue > constValue ? constValue : minValue;
                  for (yy = 0; yy < thisBlockHeight; yy++) {
                    for (xx = 0; xx < thisBlockWidth; xx++) {
                      resultPixels[outPtr++] = constValue;
                    }
                    outPtr += outStride;
                  }
                }
              }
              if (block.encoding === 1 && blockPtr !== block.numValidPixels) {
                throw "Block and Mask do not match";
              }
              blockIdx++;
            }
          }
          return {
            resultPixels,
            resultMask,
            minValue
          };
        };
        var formatFileInfo = function(data) {
          return {
            "fileIdentifierString": data.fileIdentifierString,
            "fileVersion": data.fileVersion,
            "imageType": data.imageType,
            "height": data.height,
            "width": data.width,
            "maxZError": data.maxZError,
            "eofOffset": data.eofOffset,
            "mask": data.mask ? {
              "numBlocksX": data.mask.numBlocksX,
              "numBlocksY": data.mask.numBlocksY,
              "numBytes": data.mask.numBytes,
              "maxValue": data.mask.maxValue
            } : null,
            "pixels": {
              "numBlocksX": data.pixels.numBlocksX,
              "numBlocksY": data.pixels.numBlocksY,
              "numBytes": data.pixels.numBytes,
              "maxValue": data.pixels.maxValue,
              "noDataValue": data.noDataValue
            }
          };
        };
        var computeUsedBitDepths = function(data) {
          var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;
          var bitDepths = {};
          for (var i = 0; i < numBlocks; i++) {
            var block = data.pixels.blocks[i];
            if (block.encoding === 0) {
              bitDepths.float32 = true;
            } else if (block.encoding === 1) {
              bitDepths[block.bitsPerPixel] = true;
            } else {
              bitDepths[0] = true;
            }
          }
          return Object.keys(bitDepths);
        };
        var parse2 = function(input, fp, skipMask) {
          var data = {};
          var fileIdView = new Uint8Array(input, fp, 10);
          data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
          if (data.fileIdentifierString.trim() !== "CntZImage") {
            throw "Unexpected file identifier string: " + data.fileIdentifierString;
          }
          fp += 10;
          var view = new DataView(input, fp, 24);
          data.fileVersion = view.getInt32(0, true);
          data.imageType = view.getInt32(4, true);
          data.height = view.getUint32(8, true);
          data.width = view.getUint32(12, true);
          data.maxZError = view.getFloat64(16, true);
          fp += 24;
          if (!skipMask) {
            view = new DataView(input, fp, 16);
            data.mask = {};
            data.mask.numBlocksY = view.getUint32(0, true);
            data.mask.numBlocksX = view.getUint32(4, true);
            data.mask.numBytes = view.getUint32(8, true);
            data.mask.maxValue = view.getFloat32(12, true);
            fp += 16;
            if (data.mask.numBytes > 0) {
              var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
              view = new DataView(input, fp, data.mask.numBytes);
              var cnt = view.getInt16(0, true);
              var ip = 2, op = 0;
              do {
                if (cnt > 0) {
                  while (cnt--) {
                    bitset[op++] = view.getUint8(ip++);
                  }
                } else {
                  var val = view.getUint8(ip++);
                  cnt = -cnt;
                  while (cnt--) {
                    bitset[op++] = val;
                  }
                }
                cnt = view.getInt16(ip, true);
                ip += 2;
              } while (ip < data.mask.numBytes);
              if (cnt !== -32768 || op < bitset.length) {
                throw "Unexpected end of mask RLE encoding";
              }
              data.mask.bitset = bitset;
              fp += data.mask.numBytes;
            } else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {
              data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));
            }
          }
          view = new DataView(input, fp, 16);
          data.pixels = {};
          data.pixels.numBlocksY = view.getUint32(0, true);
          data.pixels.numBlocksX = view.getUint32(4, true);
          data.pixels.numBytes = view.getUint32(8, true);
          data.pixels.maxValue = view.getFloat32(12, true);
          fp += 16;
          var numBlocksX = data.pixels.numBlocksX;
          var numBlocksY = data.pixels.numBlocksY;
          var actualNumBlocksX = numBlocksX + (data.width % numBlocksX > 0 ? 1 : 0);
          var actualNumBlocksY = numBlocksY + (data.height % numBlocksY > 0 ? 1 : 0);
          data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);
          var blockI = 0;
          for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {
            for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {
              var size = 0;
              var bytesLeft = input.byteLength - fp;
              view = new DataView(input, fp, Math.min(10, bytesLeft));
              var block = {};
              data.pixels.blocks[blockI++] = block;
              var headerByte = view.getUint8(0);
              size++;
              block.encoding = headerByte & 63;
              if (block.encoding > 3) {
                throw "Invalid block encoding (" + block.encoding + ")";
              }
              if (block.encoding === 2) {
                fp++;
                continue;
              }
              if (headerByte !== 0 && headerByte !== 2) {
                headerByte >>= 6;
                block.offsetType = headerByte;
                if (headerByte === 2) {
                  block.offset = view.getInt8(1);
                  size++;
                } else if (headerByte === 1) {
                  block.offset = view.getInt16(1, true);
                  size += 2;
                } else if (headerByte === 0) {
                  block.offset = view.getFloat32(1, true);
                  size += 4;
                } else {
                  throw "Invalid block offset type";
                }
                if (block.encoding === 1) {
                  headerByte = view.getUint8(size);
                  size++;
                  block.bitsPerPixel = headerByte & 63;
                  headerByte >>= 6;
                  block.numValidPixelsType = headerByte;
                  if (headerByte === 2) {
                    block.numValidPixels = view.getUint8(size);
                    size++;
                  } else if (headerByte === 1) {
                    block.numValidPixels = view.getUint16(size, true);
                    size += 2;
                  } else if (headerByte === 0) {
                    block.numValidPixels = view.getUint32(size, true);
                    size += 4;
                  } else {
                    throw "Invalid valid pixel count type";
                  }
                }
              }
              fp += size;
              if (block.encoding === 3) {
                continue;
              }
              var arrayBuf, store8;
              if (block.encoding === 0) {
                var numPixels = (data.pixels.numBytes - 1) / 4;
                if (numPixels !== Math.floor(numPixels)) {
                  throw "uncompressed block has invalid length";
                }
                arrayBuf = new ArrayBuffer(numPixels * 4);
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, fp, numPixels * 4));
                var rawData = new Float32Array(arrayBuf);
                block.rawData = rawData;
                fp += numPixels * 4;
              } else if (block.encoding === 1) {
                var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);
                var dataWords = Math.ceil(dataBytes / 4);
                arrayBuf = new ArrayBuffer(dataWords * 4);
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, fp, dataBytes));
                block.stuffedData = new Uint32Array(arrayBuf);
                fp += dataBytes;
              }
            }
          }
          data.eofOffset = fp;
          return data;
        };
        var unstuff = function(src, bitsPerPixel, numPixels, offset, scale2, dest, maxValue) {
          var bitMask = (1 << bitsPerPixel) - 1;
          var i = 0, o;
          var bitsLeft = 0;
          var n, buffer2;
          var nmax = Math.ceil((maxValue - offset) / scale2);
          var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
          src[src.length - 1] <<= 8 * numInvalidTailBytes;
          for (o = 0; o < numPixels; o++) {
            if (bitsLeft === 0) {
              buffer2 = src[i++];
              bitsLeft = 32;
            }
            if (bitsLeft >= bitsPerPixel) {
              n = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
              bitsLeft -= bitsPerPixel;
            } else {
              var missingBits = bitsPerPixel - bitsLeft;
              n = (buffer2 & bitMask) << missingBits & bitMask;
              buffer2 = src[i++];
              bitsLeft = 32 - missingBits;
              n += buffer2 >>> bitsLeft;
            }
            dest[o] = n < nmax ? offset + n * scale2 : maxValue;
          }
          return dest;
        };
        return CntZImage;
      }();
      var Lerc2Decode = function() {
        var BitStuffer = {
          //methods ending with 2 are for the new byte order used by Lerc2.3 and above.
          //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.
          unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale2, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i = 0, o;
            var bitsLeft = 0;
            var n, buffer2, missingBits, nmax;
            var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
            src[src.length - 1] <<= 8 * numInvalidTailBytes;
            if (lutArr) {
              for (o = 0; o < numPixels; o++) {
                if (bitsLeft === 0) {
                  buffer2 = src[i++];
                  bitsLeft = 32;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
                  bitsLeft -= bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n = (buffer2 & bitMask) << missingBits & bitMask;
                  buffer2 = src[i++];
                  bitsLeft = 32 - missingBits;
                  n += buffer2 >>> bitsLeft;
                }
                dest[o] = lutArr[n];
              }
            } else {
              nmax = Math.ceil((maxValue - offset) / scale2);
              for (o = 0; o < numPixels; o++) {
                if (bitsLeft === 0) {
                  buffer2 = src[i++];
                  bitsLeft = 32;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
                  bitsLeft -= bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n = (buffer2 & bitMask) << missingBits & bitMask;
                  buffer2 = src[i++];
                  bitsLeft = 32 - missingBits;
                  n += buffer2 >>> bitsLeft;
                }
                dest[o] = n < nmax ? offset + n * scale2 : maxValue;
              }
            }
          },
          unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale2, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;
            var buffer2;
            var dest = [];
            var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
            src[src.length - 1] <<= 8 * numInvalidTailBytes;
            var nmax = Math.ceil((maxValue - offset) / scale2);
            for (o = 0; o < numPixels; o++) {
              if (bitsLeft === 0) {
                buffer2 = src[i++];
                bitsLeft = 32;
              }
              if (bitsLeft >= bitsPerPixel) {
                n = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
                bitsLeft -= bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n = (buffer2 & bitMask) << missingBits & bitMask;
                buffer2 = src[i++];
                bitsLeft = 32 - missingBits;
                n += buffer2 >>> bitsLeft;
              }
              dest[o] = n < nmax ? offset + n * scale2 : maxValue;
            }
            dest.unshift(offset);
            return dest;
          },
          unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale2, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i = 0, o;
            var bitsLeft = 0, bitPos = 0;
            var n, buffer2, missingBits;
            if (lutArr) {
              for (o = 0; o < numPixels; o++) {
                if (bitsLeft === 0) {
                  buffer2 = src[i++];
                  bitsLeft = 32;
                  bitPos = 0;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n = buffer2 >>> bitPos & bitMask;
                  bitsLeft -= bitsPerPixel;
                  bitPos += bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n = buffer2 >>> bitPos & bitMask;
                  buffer2 = src[i++];
                  bitsLeft = 32 - missingBits;
                  n |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                  bitPos = missingBits;
                }
                dest[o] = lutArr[n];
              }
            } else {
              var nmax = Math.ceil((maxValue - offset) / scale2);
              for (o = 0; o < numPixels; o++) {
                if (bitsLeft === 0) {
                  buffer2 = src[i++];
                  bitsLeft = 32;
                  bitPos = 0;
                }
                if (bitsLeft >= bitsPerPixel) {
                  n = buffer2 >>> bitPos & bitMask;
                  bitsLeft -= bitsPerPixel;
                  bitPos += bitsPerPixel;
                } else {
                  missingBits = bitsPerPixel - bitsLeft;
                  n = buffer2 >>> bitPos & bitMask;
                  buffer2 = src[i++];
                  bitsLeft = 32 - missingBits;
                  n |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                  bitPos = missingBits;
                }
                dest[o] = n < nmax ? offset + n * scale2 : maxValue;
              }
            }
            return dest;
          },
          unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale2, maxValue) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;
            var buffer2;
            var dest = [];
            var nmax = Math.ceil((maxValue - offset) / scale2);
            for (o = 0; o < numPixels; o++) {
              if (bitsLeft === 0) {
                buffer2 = src[i++];
                bitsLeft = 32;
                bitPos = 0;
              }
              if (bitsLeft >= bitsPerPixel) {
                n = buffer2 >>> bitPos & bitMask;
                bitsLeft -= bitsPerPixel;
                bitPos += bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n = buffer2 >>> bitPos & bitMask;
                buffer2 = src[i++];
                bitsLeft = 32 - missingBits;
                n |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                bitPos = missingBits;
              }
              dest[o] = n < nmax ? offset + n * scale2 : maxValue;
            }
            dest.unshift(offset);
            return dest;
          },
          originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i = 0, o;
            var bitsLeft = 0;
            var n, buffer2, missingBits;
            var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);
            src[src.length - 1] <<= 8 * numInvalidTailBytes;
            for (o = 0; o < numPixels; o++) {
              if (bitsLeft === 0) {
                buffer2 = src[i++];
                bitsLeft = 32;
              }
              if (bitsLeft >= bitsPerPixel) {
                n = buffer2 >>> bitsLeft - bitsPerPixel & bitMask;
                bitsLeft -= bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n = (buffer2 & bitMask) << missingBits & bitMask;
                buffer2 = src[i++];
                bitsLeft = 32 - missingBits;
                n += buffer2 >>> bitsLeft;
              }
              dest[o] = n;
            }
            return dest;
          },
          originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {
            var bitMask = (1 << bitsPerPixel) - 1;
            var i = 0, o;
            var bitsLeft = 0, bitPos = 0;
            var n, buffer2, missingBits;
            for (o = 0; o < numPixels; o++) {
              if (bitsLeft === 0) {
                buffer2 = src[i++];
                bitsLeft = 32;
                bitPos = 0;
              }
              if (bitsLeft >= bitsPerPixel) {
                n = buffer2 >>> bitPos & bitMask;
                bitsLeft -= bitsPerPixel;
                bitPos += bitsPerPixel;
              } else {
                missingBits = bitsPerPixel - bitsLeft;
                n = buffer2 >>> bitPos & bitMask;
                buffer2 = src[i++];
                bitsLeft = 32 - missingBits;
                n |= (buffer2 & (1 << missingBits) - 1) << bitsPerPixel - missingBits;
                bitPos = missingBits;
              }
              dest[o] = n;
            }
            return dest;
          }
        };
        var Lerc2Helpers = {
          HUFFMAN_LUT_BITS_MAX: 12,
          //use 2^12 lut, treat it like constant
          computeChecksumFletcher32: function(input) {
            var sum1 = 65535, sum2 = 65535;
            var len = input.length;
            var words = Math.floor(len / 2);
            var i = 0;
            while (words) {
              var tlen = words >= 359 ? 359 : words;
              words -= tlen;
              do {
                sum1 += input[i++] << 8;
                sum2 += sum1 += input[i++];
              } while (--tlen);
              sum1 = (sum1 & 65535) + (sum1 >>> 16);
              sum2 = (sum2 & 65535) + (sum2 >>> 16);
            }
            if (len & 1) {
              sum2 += sum1 += input[i] << 8;
            }
            sum1 = (sum1 & 65535) + (sum1 >>> 16);
            sum2 = (sum2 & 65535) + (sum2 >>> 16);
            return (sum2 << 16 | sum1) >>> 0;
          },
          readHeaderInfo: function(input, data) {
            var ptr = data.ptr;
            var fileIdView = new Uint8Array(input, ptr, 6);
            var headerInfo = {};
            headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
            if (headerInfo.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) {
              throw "Unexpected file identifier string (expect Lerc2 ): " + headerInfo.fileIdentifierString;
            }
            ptr += 6;
            var view = new DataView(input, ptr, 8);
            var fileVersion = view.getInt32(0, true);
            headerInfo.fileVersion = fileVersion;
            ptr += 4;
            if (fileVersion >= 3) {
              headerInfo.checksum = view.getUint32(4, true);
              ptr += 4;
            }
            view = new DataView(input, ptr, 12);
            headerInfo.height = view.getUint32(0, true);
            headerInfo.width = view.getUint32(4, true);
            ptr += 8;
            if (fileVersion >= 4) {
              headerInfo.numDims = view.getUint32(8, true);
              ptr += 4;
            } else {
              headerInfo.numDims = 1;
            }
            view = new DataView(input, ptr, 40);
            headerInfo.numValidPixel = view.getUint32(0, true);
            headerInfo.microBlockSize = view.getInt32(4, true);
            headerInfo.blobSize = view.getInt32(8, true);
            headerInfo.imageType = view.getInt32(12, true);
            headerInfo.maxZError = view.getFloat64(16, true);
            headerInfo.zMin = view.getFloat64(24, true);
            headerInfo.zMax = view.getFloat64(32, true);
            ptr += 40;
            data.headerInfo = headerInfo;
            data.ptr = ptr;
            var checksum, keyLength;
            if (fileVersion >= 3) {
              keyLength = fileVersion >= 4 ? 52 : 48;
              checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));
              if (checksum !== headerInfo.checksum) {
                throw "Checksum failed.";
              }
            }
            return true;
          },
          checkMinMaxRanges: function(input, data) {
            var headerInfo = data.headerInfo;
            var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);
            var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);
            var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);
            var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);
            data.ptr += 2 * rangeBytes;
            var i, equal = true;
            for (i = 0; i < headerInfo.numDims; i++) {
              if (minValues[i] !== maxValues[i]) {
                equal = false;
                break;
              }
            }
            headerInfo.minValues = minValues;
            headerInfo.maxValues = maxValues;
            return equal;
          },
          readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {
            var rawData;
            if (OutPixelTypeArray === Uint8Array) {
              rawData = new Uint8Array(input, ptr, numBytes);
            } else {
              var arrayBuf = new ArrayBuffer(numBytes);
              var store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, ptr, numBytes));
              rawData = new OutPixelTypeArray(arrayBuf);
            }
            return rawData;
          },
          readMask: function(input, data) {
            var ptr = data.ptr;
            var headerInfo = data.headerInfo;
            var numPixels = headerInfo.width * headerInfo.height;
            var numValidPixel = headerInfo.numValidPixel;
            var view = new DataView(input, ptr, 4);
            var mask = {};
            mask.numBytes = view.getUint32(0, true);
            ptr += 4;
            if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {
              throw "invalid mask";
            }
            var bitset, resultMask;
            if (numValidPixel === 0) {
              bitset = new Uint8Array(Math.ceil(numPixels / 8));
              mask.bitset = bitset;
              resultMask = new Uint8Array(numPixels);
              data.pixels.resultMask = resultMask;
              ptr += mask.numBytes;
            } else if (mask.numBytes > 0) {
              bitset = new Uint8Array(Math.ceil(numPixels / 8));
              view = new DataView(input, ptr, mask.numBytes);
              var cnt = view.getInt16(0, true);
              var ip = 2, op = 0, val = 0;
              do {
                if (cnt > 0) {
                  while (cnt--) {
                    bitset[op++] = view.getUint8(ip++);
                  }
                } else {
                  val = view.getUint8(ip++);
                  cnt = -cnt;
                  while (cnt--) {
                    bitset[op++] = val;
                  }
                }
                cnt = view.getInt16(ip, true);
                ip += 2;
              } while (ip < mask.numBytes);
              if (cnt !== -32768 || op < bitset.length) {
                throw "Unexpected end of mask RLE encoding";
              }
              resultMask = new Uint8Array(numPixels);
              var mb = 0, k = 0;
              for (k = 0; k < numPixels; k++) {
                if (k & 7) {
                  mb = bitset[k >> 3];
                  mb <<= k & 7;
                } else {
                  mb = bitset[k >> 3];
                }
                if (mb & 128) {
                  resultMask[k] = 1;
                }
              }
              data.pixels.resultMask = resultMask;
              mask.bitset = bitset;
              ptr += mask.numBytes;
            }
            data.ptr = ptr;
            data.mask = mask;
            return true;
          },
          readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
            var ptr = data.ptr;
            var headerInfo = data.headerInfo;
            var numDims = headerInfo.numDims;
            var numPixels = headerInfo.width * headerInfo.height;
            var imageType = headerInfo.imageType;
            var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;
            var rawData;
            var mask = data.pixels.resultMask;
            if (OutPixelTypeArray === Uint8Array) {
              rawData = new Uint8Array(input, ptr, numBytes);
            } else {
              var arrayBuf = new ArrayBuffer(numBytes);
              var store8 = new Uint8Array(arrayBuf);
              store8.set(new Uint8Array(input, ptr, numBytes));
              rawData = new OutPixelTypeArray(arrayBuf);
            }
            if (rawData.length === numPixels * numDims) {
              if (useBSQForOutputDim) {
                data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);
              } else {
                data.pixels.resultPixels = rawData;
              }
            } else {
              data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);
              var z = 0, k = 0, i = 0, nStart = 0;
              if (numDims > 1) {
                if (useBSQForOutputDim) {
                  for (k = 0; k < numPixels; k++) {
                    if (mask[k]) {
                      nStart = k;
                      for (i = 0; i < numDims; i++, nStart += numPixels) {
                        data.pixels.resultPixels[nStart] = rawData[z++];
                      }
                    }
                  }
                } else {
                  for (k = 0; k < numPixels; k++) {
                    if (mask[k]) {
                      nStart = k * numDims;
                      for (i = 0; i < numDims; i++) {
                        data.pixels.resultPixels[nStart + i] = rawData[z++];
                      }
                    }
                  }
                }
              } else {
                for (k = 0; k < numPixels; k++) {
                  if (mask[k]) {
                    data.pixels.resultPixels[k] = rawData[z++];
                  }
                }
              }
            }
            ptr += numBytes;
            data.ptr = ptr;
            return true;
          },
          readHuffmanTree: function(input, data) {
            var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX;
            var view = new DataView(input, data.ptr, 16);
            data.ptr += 16;
            var version = view.getInt32(0, true);
            if (version < 2) {
              throw "unsupported Huffman version";
            }
            var size = view.getInt32(4, true);
            var i0 = view.getInt32(8, true);
            var i1 = view.getInt32(12, true);
            if (i0 >= i1) {
              return false;
            }
            var blockDataBuffer = new Uint32Array(i1 - i0);
            Lerc2Helpers.decodeBits(input, data, blockDataBuffer);
            var codeTable = [];
            var i, j, k, len;
            for (i = i0; i < i1; i++) {
              j = i - (i < size ? 0 : size);
              codeTable[j] = { first: blockDataBuffer[i - i0], second: null };
            }
            var dataBytes = input.byteLength - data.ptr;
            var dataWords = Math.ceil(dataBytes / 4);
            var arrayBuf = new ArrayBuffer(dataWords * 4);
            var store8 = new Uint8Array(arrayBuf);
            store8.set(new Uint8Array(input, data.ptr, dataBytes));
            var stuffedData = new Uint32Array(arrayBuf);
            var bitPos = 0, word, srcPtr = 0;
            word = stuffedData[0];
            for (i = i0; i < i1; i++) {
              j = i - (i < size ? 0 : size);
              len = codeTable[j].first;
              if (len > 0) {
                codeTable[j].second = word << bitPos >>> 32 - len;
                if (32 - bitPos >= len) {
                  bitPos += len;
                  if (bitPos === 32) {
                    bitPos = 0;
                    srcPtr++;
                    word = stuffedData[srcPtr];
                  }
                } else {
                  bitPos += len - 32;
                  srcPtr++;
                  word = stuffedData[srcPtr];
                  codeTable[j].second |= word >>> 32 - bitPos;
                }
              }
            }
            var numBitsLUT = 0, numBitsLUTQick = 0;
            var tree = new TreeNode();
            for (i = 0; i < codeTable.length; i++) {
              if (codeTable[i] !== void 0) {
                numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);
              }
            }
            if (numBitsLUT >= BITS_MAX) {
              numBitsLUTQick = BITS_MAX;
            } else {
              numBitsLUTQick = numBitsLUT;
            }
            var decodeLut = [], entry, code, numEntries, jj, currentBit, node;
            for (i = i0; i < i1; i++) {
              j = i - (i < size ? 0 : size);
              len = codeTable[j].first;
              if (len > 0) {
                entry = [len, j];
                if (len <= numBitsLUTQick) {
                  code = codeTable[j].second << numBitsLUTQick - len;
                  numEntries = 1 << numBitsLUTQick - len;
                  for (k = 0; k < numEntries; k++) {
                    decodeLut[code | k] = entry;
                  }
                } else {
                  code = codeTable[j].second;
                  node = tree;
                  for (jj = len - 1; jj >= 0; jj--) {
                    currentBit = code >>> jj & 1;
                    if (currentBit) {
                      if (!node.right) {
                        node.right = new TreeNode();
                      }
                      node = node.right;
                    } else {
                      if (!node.left) {
                        node.left = new TreeNode();
                      }
                      node = node.left;
                    }
                    if (jj === 0 && !node.val) {
                      node.val = entry[1];
                    }
                  }
                }
              }
            }
            return {
              decodeLut,
              numBitsLUTQick,
              numBitsLUT,
              tree,
              stuffedData,
              srcPtr,
              bitPos
            };
          },
          readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
            var headerInfo = data.headerInfo;
            var numDims = headerInfo.numDims;
            var height = data.headerInfo.height;
            var width = data.headerInfo.width;
            var numPixels = width * height;
            var huffmanInfo = this.readHuffmanTree(input, data);
            var decodeLut = huffmanInfo.decodeLut;
            var tree = huffmanInfo.tree;
            var stuffedData = huffmanInfo.stuffedData;
            var srcPtr = huffmanInfo.srcPtr;
            var bitPos = huffmanInfo.bitPos;
            var numBitsLUTQick = huffmanInfo.numBitsLUTQick;
            var numBitsLUT = huffmanInfo.numBitsLUT;
            var offset = data.headerInfo.imageType === 0 ? 128 : 0;
            var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;
            var i, j, k, ii;
            var prevVal = 0;
            if (bitPos > 0) {
              srcPtr++;
              bitPos = 0;
            }
            var word = stuffedData[srcPtr];
            var deltaEncode = data.encodeMode === 1;
            var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);
            var resultPixels = resultPixelsAllDim;
            var iDim;
            if (numDims < 2 || deltaEncode) {
              for (iDim = 0; iDim < numDims; iDim++) {
                if (numDims > 1) {
                  resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);
                  prevVal = 0;
                }
                if (data.headerInfo.numValidPixel === width * height) {
                  for (k = 0, i = 0; i < height; i++) {
                    for (j = 0; j < width; j++, k++) {
                      val = 0;
                      valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                      valTmpQuick = valTmp;
                      if (32 - bitPos < numBitsLUTQick) {
                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                        valTmpQuick = valTmp;
                      }
                      if (decodeLut[valTmpQuick]) {
                        val = decodeLut[valTmpQuick][1];
                        bitPos += decodeLut[valTmpQuick][0];
                      } else {
                        valTmp = word << bitPos >>> 32 - numBitsLUT;
                        valTmpQuick = valTmp;
                        if (32 - bitPos < numBitsLUT) {
                          valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                          valTmpQuick = valTmp;
                        }
                        node = tree;
                        for (ii = 0; ii < numBitsLUT; ii++) {
                          currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                          node = currentBit ? node.right : node.left;
                          if (!(node.left || node.right)) {
                            val = node.val;
                            bitPos = bitPos + ii + 1;
                            break;
                          }
                        }
                      }
                      if (bitPos >= 32) {
                        bitPos -= 32;
                        srcPtr++;
                        word = stuffedData[srcPtr];
                      }
                      delta = val - offset;
                      if (deltaEncode) {
                        if (j > 0) {
                          delta += prevVal;
                        } else if (i > 0) {
                          delta += resultPixels[k - width];
                        } else {
                          delta += prevVal;
                        }
                        delta &= 255;
                        resultPixels[k] = delta;
                        prevVal = delta;
                      } else {
                        resultPixels[k] = delta;
                      }
                    }
                  }
                } else {
                  for (k = 0, i = 0; i < height; i++) {
                    for (j = 0; j < width; j++, k++) {
                      if (mask[k]) {
                        val = 0;
                        valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                        valTmpQuick = valTmp;
                        if (32 - bitPos < numBitsLUTQick) {
                          valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                          valTmpQuick = valTmp;
                        }
                        if (decodeLut[valTmpQuick]) {
                          val = decodeLut[valTmpQuick][1];
                          bitPos += decodeLut[valTmpQuick][0];
                        } else {
                          valTmp = word << bitPos >>> 32 - numBitsLUT;
                          valTmpQuick = valTmp;
                          if (32 - bitPos < numBitsLUT) {
                            valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                            valTmpQuick = valTmp;
                          }
                          node = tree;
                          for (ii = 0; ii < numBitsLUT; ii++) {
                            currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                            node = currentBit ? node.right : node.left;
                            if (!(node.left || node.right)) {
                              val = node.val;
                              bitPos = bitPos + ii + 1;
                              break;
                            }
                          }
                        }
                        if (bitPos >= 32) {
                          bitPos -= 32;
                          srcPtr++;
                          word = stuffedData[srcPtr];
                        }
                        delta = val - offset;
                        if (deltaEncode) {
                          if (j > 0 && mask[k - 1]) {
                            delta += prevVal;
                          } else if (i > 0 && mask[k - width]) {
                            delta += resultPixels[k - width];
                          } else {
                            delta += prevVal;
                          }
                          delta &= 255;
                          resultPixels[k] = delta;
                          prevVal = delta;
                        } else {
                          resultPixels[k] = delta;
                        }
                      }
                    }
                  }
                }
              }
            } else {
              for (k = 0, i = 0; i < height; i++) {
                for (j = 0; j < width; j++) {
                  k = i * width + j;
                  if (!mask || mask[k]) {
                    for (iDim = 0; iDim < numDims; iDim++, k += numPixels) {
                      val = 0;
                      valTmp = word << bitPos >>> 32 - numBitsLUTQick;
                      valTmpQuick = valTmp;
                      if (32 - bitPos < numBitsLUTQick) {
                        valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUTQick;
                        valTmpQuick = valTmp;
                      }
                      if (decodeLut[valTmpQuick]) {
                        val = decodeLut[valTmpQuick][1];
                        bitPos += decodeLut[valTmpQuick][0];
                      } else {
                        valTmp = word << bitPos >>> 32 - numBitsLUT;
                        valTmpQuick = valTmp;
                        if (32 - bitPos < numBitsLUT) {
                          valTmp |= stuffedData[srcPtr + 1] >>> 64 - bitPos - numBitsLUT;
                          valTmpQuick = valTmp;
                        }
                        node = tree;
                        for (ii = 0; ii < numBitsLUT; ii++) {
                          currentBit = valTmp >>> numBitsLUT - ii - 1 & 1;
                          node = currentBit ? node.right : node.left;
                          if (!(node.left || node.right)) {
                            val = node.val;
                            bitPos = bitPos + ii + 1;
                            break;
                          }
                        }
                      }
                      if (bitPos >= 32) {
                        bitPos -= 32;
                        srcPtr++;
                        word = stuffedData[srcPtr];
                      }
                      delta = val - offset;
                      resultPixels[k] = delta;
                    }
                  }
                }
              }
            }
            data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);
            data.pixels.resultPixels = resultPixelsAllDim;
            if (numDims > 1 && !useBSQForOutputDim) {
              data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);
            }
          },
          decodeBits: function(input, data, blockDataBuffer, offset, iDim) {
            {
              var headerInfo = data.headerInfo;
              var fileVersion = headerInfo.fileVersion;
              var blockPtr = 0;
              var viewByteLength = input.byteLength - data.ptr >= 5 ? 5 : input.byteLength - data.ptr;
              var view = new DataView(input, data.ptr, viewByteLength);
              var headerByte = view.getUint8(0);
              blockPtr++;
              var bits67 = headerByte >> 6;
              var n = bits67 === 0 ? 4 : 3 - bits67;
              var doLut = (headerByte & 32) > 0 ? true : false;
              var numBits = headerByte & 31;
              var numElements = 0;
              if (n === 1) {
                numElements = view.getUint8(blockPtr);
                blockPtr++;
              } else if (n === 2) {
                numElements = view.getUint16(blockPtr, true);
                blockPtr += 2;
              } else if (n === 4) {
                numElements = view.getUint32(blockPtr, true);
                blockPtr += 4;
              } else {
                throw "Invalid valid pixel count type";
              }
              var scale2 = 2 * headerInfo.maxZError;
              var stuffedData, arrayBuf, store8, dataBytes, dataWords;
              var lutArr, lutData, lutBytes, bitsPerPixel;
              var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;
              if (doLut) {
                data.counter.lut++;
                lutBytes = view.getUint8(blockPtr);
                blockPtr++;
                dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);
                dataWords = Math.ceil(dataBytes / 4);
                arrayBuf = new ArrayBuffer(dataWords * 4);
                store8 = new Uint8Array(arrayBuf);
                data.ptr += blockPtr;
                store8.set(new Uint8Array(input, data.ptr, dataBytes));
                lutData = new Uint32Array(arrayBuf);
                data.ptr += dataBytes;
                bitsPerPixel = 0;
                while (lutBytes - 1 >>> bitsPerPixel) {
                  bitsPerPixel++;
                }
                dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
                dataWords = Math.ceil(dataBytes / 4);
                arrayBuf = new ArrayBuffer(dataWords * 4);
                store8 = new Uint8Array(arrayBuf);
                store8.set(new Uint8Array(input, data.ptr, dataBytes));
                stuffedData = new Uint32Array(arrayBuf);
                data.ptr += dataBytes;
                if (fileVersion >= 3) {
                  lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale2, zMax);
                } else {
                  lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale2, zMax);
                }
                if (fileVersion >= 3) {
                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
                } else {
                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);
                }
              } else {
                data.counter.bitstuffer++;
                bitsPerPixel = numBits;
                data.ptr += blockPtr;
                if (bitsPerPixel > 0) {
                  dataBytes = Math.ceil(numElements * bitsPerPixel / 8);
                  dataWords = Math.ceil(dataBytes / 4);
                  arrayBuf = new ArrayBuffer(dataWords * 4);
                  store8 = new Uint8Array(arrayBuf);
                  store8.set(new Uint8Array(input, data.ptr, dataBytes));
                  stuffedData = new Uint32Array(arrayBuf);
                  data.ptr += dataBytes;
                  if (fileVersion >= 3) {
                    if (offset == null) {
                      BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                    } else {
                      BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale2, zMax);
                    }
                  } else {
                    if (offset == null) {
                      BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);
                    } else {
                      BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale2, zMax);
                    }
                  }
                }
              }
            }
          },
          readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {
            var headerInfo = data.headerInfo;
            var width = headerInfo.width;
            var height = headerInfo.height;
            var numPixels = width * height;
            var microBlockSize = headerInfo.microBlockSize;
            var imageType = headerInfo.imageType;
            var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);
            var numBlocksX = Math.ceil(width / microBlockSize);
            var numBlocksY = Math.ceil(height / microBlockSize);
            data.pixels.numBlocksY = numBlocksY;
            data.pixels.numBlocksX = numBlocksX;
            data.pixels.ptr = 0;
            var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;
            var view, block, arrayBuf, store8, rawData;
            var blockEncoding;
            var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);
            var lastBlockHeight = height % microBlockSize || microBlockSize;
            var lastBlockWidth = width % microBlockSize || microBlockSize;
            var offsetType, offset;
            var numDims = headerInfo.numDims, iDim;
            var mask = data.pixels.resultMask;
            var resultPixels = data.pixels.resultPixels;
            var fileVersion = headerInfo.fileVersion;
            var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;
            var isDiffEncoding;
            var zMax = headerInfo.zMax;
            var resultPixelsPrevDim;
            for (blockY = 0; blockY < numBlocksY; blockY++) {
              thisBlockHeight = blockY !== numBlocksY - 1 ? microBlockSize : lastBlockHeight;
              for (blockX = 0; blockX < numBlocksX; blockX++) {
                thisBlockWidth = blockX !== numBlocksX - 1 ? microBlockSize : lastBlockWidth;
                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                outStride = width - thisBlockWidth;
                for (iDim = 0; iDim < numDims; iDim++) {
                  if (numDims > 1) {
                    resultPixelsPrevDim = resultPixels;
                    outPtr = blockY * width * microBlockSize + blockX * microBlockSize;
                    resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);
                    zMax = headerInfo.maxValues[iDim];
                  } else {
                    resultPixelsPrevDim = null;
                  }
                  bytesLeft = input.byteLength - data.ptr;
                  view = new DataView(input, data.ptr, Math.min(10, bytesLeft));
                  block = {};
                  blockPtr = 0;
                  headerByte = view.getUint8(0);
                  blockPtr++;
                  isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;
                  bits67 = headerByte >> 6 & 255;
                  testCode = headerByte >> 2 & fileVersionCheckNum;
                  if (testCode !== (blockX * microBlockSize >> 3 & fileVersionCheckNum)) {
                    throw "integrity issue";
                  }
                  if (isDiffEncoding && iDim === 0) {
                    throw "integrity issue";
                  }
                  blockEncoding = headerByte & 3;
                  if (blockEncoding > 3) {
                    data.ptr += blockPtr;
                    throw "Invalid block encoding (" + blockEncoding + ")";
                  } else if (blockEncoding === 2) {
                    if (isDiffEncoding) {
                      if (mask) {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            if (mask[outPtr]) {
                              resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                            }
                            outPtr++;
                          }
                        }
                      } else {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            resultPixels[outPtr] = resultPixelsPrevDim[outPtr];
                            outPtr++;
                          }
                        }
                      }
                    }
                    data.counter.constant++;
                    data.ptr += blockPtr;
                    continue;
                  } else if (blockEncoding === 0) {
                    if (isDiffEncoding) {
                      throw "integrity issue";
                    }
                    data.counter.uncompressed++;
                    data.ptr += blockPtr;
                    numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;
                    bytesleft = input.byteLength - data.ptr;
                    numBytes = numBytes < bytesleft ? numBytes : bytesleft;
                    arrayBuf = new ArrayBuffer(numBytes % dataTypeSize === 0 ? numBytes : numBytes + dataTypeSize - numBytes % dataTypeSize);
                    store8 = new Uint8Array(arrayBuf);
                    store8.set(new Uint8Array(input, data.ptr, numBytes));
                    rawData = new OutPixelTypeArray(arrayBuf);
                    z = 0;
                    if (mask) {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          if (mask[outPtr]) {
                            resultPixels[outPtr] = rawData[z++];
                          }
                          outPtr++;
                        }
                        outPtr += outStride;
                      }
                    } else {
                      for (row = 0; row < thisBlockHeight; row++) {
                        for (col = 0; col < thisBlockWidth; col++) {
                          resultPixels[outPtr++] = rawData[z++];
                        }
                        outPtr += outStride;
                      }
                    }
                    data.ptr += z * dataTypeSize;
                  } else {
                    offsetType = Lerc2Helpers.getDataTypeUsed(isDiffEncoding && imageType < 6 ? 4 : imageType, bits67);
                    offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);
                    blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);
                    if (blockEncoding === 3) {
                      data.ptr += blockPtr;
                      data.counter.constantoffset++;
                      if (mask) {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            if (mask[outPtr]) {
                              resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                            }
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      } else {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      }
                    } else {
                      data.ptr += blockPtr;
                      Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);
                      blockPtr = 0;
                      if (isDiffEncoding) {
                        if (mask) {
                          for (row = 0; row < thisBlockHeight; row++) {
                            for (col = 0; col < thisBlockWidth; col++) {
                              if (mask[outPtr]) {
                                resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                              }
                              outPtr++;
                            }
                            outPtr += outStride;
                          }
                        } else {
                          for (row = 0; row < thisBlockHeight; row++) {
                            for (col = 0; col < thisBlockWidth; col++) {
                              resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];
                              outPtr++;
                            }
                            outPtr += outStride;
                          }
                        }
                      } else if (mask) {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            if (mask[outPtr]) {
                              resultPixels[outPtr] = blockDataBuffer[blockPtr++];
                            }
                            outPtr++;
                          }
                          outPtr += outStride;
                        }
                      } else {
                        for (row = 0; row < thisBlockHeight; row++) {
                          for (col = 0; col < thisBlockWidth; col++) {
                            resultPixels[outPtr++] = blockDataBuffer[blockPtr++];
                          }
                          outPtr += outStride;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (numDims > 1 && !useBSQForOutputDim) {
              data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);
            }
          },
          /*****************
          *  private methods (helper methods)
          *****************/
          formatFileInfo: function(data) {
            return {
              "fileIdentifierString": data.headerInfo.fileIdentifierString,
              "fileVersion": data.headerInfo.fileVersion,
              "imageType": data.headerInfo.imageType,
              "height": data.headerInfo.height,
              "width": data.headerInfo.width,
              "numValidPixel": data.headerInfo.numValidPixel,
              "microBlockSize": data.headerInfo.microBlockSize,
              "blobSize": data.headerInfo.blobSize,
              "maxZError": data.headerInfo.maxZError,
              "pixelType": Lerc2Helpers.getPixelType(data.headerInfo.imageType),
              "eofOffset": data.eofOffset,
              "mask": data.mask ? {
                "numBytes": data.mask.numBytes
              } : null,
              "pixels": {
                "numBlocksX": data.pixels.numBlocksX,
                "numBlocksY": data.pixels.numBlocksY,
                //"numBytes": data.pixels.numBytes,
                "maxValue": data.headerInfo.zMax,
                "minValue": data.headerInfo.zMin,
                "noDataValue": data.noDataValue
              }
            };
          },
          constructConstantSurface: function(data, useBSQForOutputDim) {
            var val = data.headerInfo.zMax;
            var valMin = data.headerInfo.zMin;
            var maxValues = data.headerInfo.maxValues;
            var numDims = data.headerInfo.numDims;
            var numPixels = data.headerInfo.height * data.headerInfo.width;
            var i = 0, k = 0, nStart = 0;
            var mask = data.pixels.resultMask;
            var resultPixels = data.pixels.resultPixels;
            if (mask) {
              if (numDims > 1) {
                if (useBSQForOutputDim) {
                  for (i = 0; i < numDims; i++) {
                    nStart = i * numPixels;
                    val = maxValues[i];
                    for (k = 0; k < numPixels; k++) {
                      if (mask[k]) {
                        resultPixels[nStart + k] = val;
                      }
                    }
                  }
                } else {
                  for (k = 0; k < numPixels; k++) {
                    if (mask[k]) {
                      nStart = k * numDims;
                      for (i = 0; i < numDims; i++) {
                        resultPixels[nStart + numDims] = maxValues[i];
                      }
                    }
                  }
                }
              } else {
                for (k = 0; k < numPixels; k++) {
                  if (mask[k]) {
                    resultPixels[k] = val;
                  }
                }
              }
            } else {
              if (numDims > 1 && valMin !== val) {
                if (useBSQForOutputDim) {
                  for (i = 0; i < numDims; i++) {
                    nStart = i * numPixels;
                    val = maxValues[i];
                    for (k = 0; k < numPixels; k++) {
                      resultPixels[nStart + k] = val;
                    }
                  }
                } else {
                  for (k = 0; k < numPixels; k++) {
                    nStart = k * numDims;
                    for (i = 0; i < numDims; i++) {
                      resultPixels[nStart + i] = maxValues[i];
                    }
                  }
                }
              } else {
                for (k = 0; k < numPixels * numDims; k++) {
                  resultPixels[k] = val;
                }
              }
            }
            return;
          },
          getDataTypeArray: function(t) {
            var tp;
            switch (t) {
              case 0:
                tp = Int8Array;
                break;
              case 1:
                tp = Uint8Array;
                break;
              case 2:
                tp = Int16Array;
                break;
              case 3:
                tp = Uint16Array;
                break;
              case 4:
                tp = Int32Array;
                break;
              case 5:
                tp = Uint32Array;
                break;
              case 6:
                tp = Float32Array;
                break;
              case 7:
                tp = Float64Array;
                break;
              default:
                tp = Float32Array;
            }
            return tp;
          },
          getPixelType: function(t) {
            var tp;
            switch (t) {
              case 0:
                tp = "S8";
                break;
              case 1:
                tp = "U8";
                break;
              case 2:
                tp = "S16";
                break;
              case 3:
                tp = "U16";
                break;
              case 4:
                tp = "S32";
                break;
              case 5:
                tp = "U32";
                break;
              case 6:
                tp = "F32";
                break;
              case 7:
                tp = "F64";
                break;
              default:
                tp = "F32";
            }
            return tp;
          },
          isValidPixelValue: function(t, val) {
            if (val == null) {
              return false;
            }
            var isValid;
            switch (t) {
              case 0:
                isValid = val >= -128 && val <= 127;
                break;
              case 1:
                isValid = val >= 0 && val <= 255;
                break;
              case 2:
                isValid = val >= -32768 && val <= 32767;
                break;
              case 3:
                isValid = val >= 0 && val <= 65536;
                break;
              case 4:
                isValid = val >= -2147483648 && val <= 2147483647;
                break;
              case 5:
                isValid = val >= 0 && val <= 4294967296;
                break;
              case 6:
                isValid = val >= -34027999387901484e22 && val <= 34027999387901484e22;
                break;
              case 7:
                isValid = val >= -17976931348623157e292 && val <= 17976931348623157e292;
                break;
              default:
                isValid = false;
            }
            return isValid;
          },
          getDataTypeSize: function(t) {
            var s = 0;
            switch (t) {
              case 0:
              case 1:
                s = 1;
                break;
              case 2:
              case 3:
                s = 2;
                break;
              case 4:
              case 5:
              case 6:
                s = 4;
                break;
              case 7:
                s = 8;
                break;
              default:
                s = t;
            }
            return s;
          },
          getDataTypeUsed: function(dt, tc) {
            var t = dt;
            switch (dt) {
              case 2:
              case 4:
                t = dt - tc;
                break;
              case 3:
              case 5:
                t = dt - 2 * tc;
                break;
              case 6:
                if (0 === tc) {
                  t = dt;
                } else if (1 === tc) {
                  t = 2;
                } else {
                  t = 1;
                }
                break;
              case 7:
                if (0 === tc) {
                  t = dt;
                } else {
                  t = dt - 2 * tc + 1;
                }
                break;
              default:
                t = dt;
                break;
            }
            return t;
          },
          getOnePixel: function(block, blockPtr, offsetType, view) {
            var temp = 0;
            switch (offsetType) {
              case 0:
                temp = view.getInt8(blockPtr);
                break;
              case 1:
                temp = view.getUint8(blockPtr);
                break;
              case 2:
                temp = view.getInt16(blockPtr, true);
                break;
              case 3:
                temp = view.getUint16(blockPtr, true);
                break;
              case 4:
                temp = view.getInt32(blockPtr, true);
                break;
              case 5:
                temp = view.getUInt32(blockPtr, true);
                break;
              case 6:
                temp = view.getFloat32(blockPtr, true);
                break;
              case 7:
                temp = view.getFloat64(blockPtr, true);
                break;
              default:
                throw "the decoder does not understand this pixel type";
            }
            return temp;
          },
          swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {
            var i = 0, j = 0, iDim = 0, temp = 0, swap2 = pixels;
            if (numDims > 1) {
              swap2 = new OutPixelTypeArray(numPixels * numDims);
              if (inputIsBIP) {
                for (i = 0; i < numPixels; i++) {
                  temp = i;
                  for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {
                    swap2[temp] = pixels[j++];
                  }
                }
              } else {
                for (i = 0; i < numPixels; i++) {
                  temp = i;
                  for (iDim = 0; iDim < numDims; iDim++, temp += numPixels) {
                    swap2[j++] = pixels[temp];
                  }
                }
              }
            }
            return swap2;
          }
        };
        var TreeNode = function(val, left, right) {
          this.val = val;
          this.left = left;
          this.right = right;
        };
        var Lerc2Decode2 = {
          /*
          * ********removed options compared to LERC1. We can bring some of them back if needed.
           * removed pixel type. LERC2 is typed and doesn't require user to give pixel type
           * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.
           * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.
           * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,
           *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.
           *       We can add it back later if their's a clear requirement.
           * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)
           * removed computeUsedBitDepths.
           *
           *
           * response changes compared to LERC1
           * 1. encodedMaskData is not available
           * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)
           * 3. maskData is always available
          */
          /*****************
          *  public properties
          ******************/
          //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable
          /*****************
          *  public methods
          *****************/
          /**
           * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.
           *
           * @param {ArrayBuffer} input The LERC input byte stream
           * @param {object} [options] options Decoding options
           * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position
           * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process
           * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
           */
          decode: function(input, options) {
            options = options || {};
            var noDataValue = options.noDataValue;
            var i = 0, data = {};
            data.ptr = options.inputOffset || 0;
            data.pixels = {};
            if (!Lerc2Helpers.readHeaderInfo(input, data))
              ;
            var headerInfo = data.headerInfo;
            var fileVersion = headerInfo.fileVersion;
            var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);
            if (fileVersion > 5) {
              throw "unsupported lerc version 2." + fileVersion;
            }
            Lerc2Helpers.readMask(input, data);
            if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {
              data.pixels.resultMask = options.maskData;
            }
            var numPixels = headerInfo.width * headerInfo.height;
            data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);
            data.counter = {
              onesweep: 0,
              uncompressed: 0,
              lut: 0,
              bitstuffer: 0,
              constant: 0,
              constantoffset: 0
            };
            var useBSQForOutputDim = !options.returnPixelInterleavedDims;
            if (headerInfo.numValidPixel !== 0) {
              if (headerInfo.zMax === headerInfo.zMin) {
                Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
              } else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {
                Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);
              } else {
                var view = new DataView(input, data.ptr, 2);
                var bReadDataOneSweep = view.getUint8(0);
                data.ptr++;
                if (bReadDataOneSweep) {
                  Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);
                } else {
                  if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 1e-5) {
                    var flagHuffman = view.getUint8(1);
                    data.ptr++;
                    data.encodeMode = flagHuffman;
                    if (flagHuffman > 2 || fileVersion < 4 && flagHuffman > 1) {
                      throw "Invalid Huffman flag " + flagHuffman;
                    }
                    if (flagHuffman) {
                      Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);
                    } else {
                      Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
                    }
                  } else {
                    Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);
                  }
                }
              }
            }
            data.eofOffset = data.ptr;
            var diff;
            if (options.inputOffset) {
              diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;
              if (Math.abs(diff) >= 1) {
                data.eofOffset = options.inputOffset + data.headerInfo.blobSize;
              }
            } else {
              diff = data.headerInfo.blobSize - data.ptr;
              if (Math.abs(diff) >= 1) {
                data.eofOffset = data.headerInfo.blobSize;
              }
            }
            var result = {
              width: headerInfo.width,
              height: headerInfo.height,
              pixelData: data.pixels.resultPixels,
              minValue: headerInfo.zMin,
              maxValue: headerInfo.zMax,
              validPixelCount: headerInfo.numValidPixel,
              dimCount: headerInfo.numDims,
              dimStats: {
                minValues: headerInfo.minValues,
                maxValues: headerInfo.maxValues
              },
              maskData: data.pixels.resultMask
              //noDataValue: noDataValue
            };
            if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {
              var mask = data.pixels.resultMask;
              for (i = 0; i < numPixels; i++) {
                if (!mask[i]) {
                  result.pixelData[i] = noDataValue;
                }
              }
              result.noDataValue = noDataValue;
            }
            data.noDataValue = noDataValue;
            if (options.returnFileInfo) {
              result.fileInfo = Lerc2Helpers.formatFileInfo(data);
            }
            return result;
          },
          getBandCount: function(input) {
            var count = 0;
            var i = 0;
            var temp = {};
            temp.ptr = 0;
            temp.pixels = {};
            while (i < input.byteLength - 58) {
              Lerc2Helpers.readHeaderInfo(input, temp);
              i += temp.headerInfo.blobSize;
              count++;
              temp.ptr = i;
            }
            return count;
          }
        };
        return Lerc2Decode2;
      }();
      var isPlatformLittleEndian = function() {
        var a = new ArrayBuffer(4);
        var b = new Uint8Array(a);
        var c = new Uint32Array(a);
        c[0] = 1;
        return b[0] === 1;
      }();
      var Lerc = {
        /************wrapper**********************************************/
        /**
         * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.
         *
         * @alias module:Lerc
         * @param {ArrayBuffer} input The LERC input byte stream
         * @param {object} [options] The decoding options below are optional.
         * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.
         * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.
         * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.
         * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]
         * @returns {{width, height, pixels, pixelType, mask, statistics}}
           * @property {number} width Width of decoded image.
           * @property {number} height Height of decoded image.
           * @property {array} pixels [band1, band2, ] Each band is a typed array of width*height.
           * @property {string} pixelType The type of pixels represented in the output.
           * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.
           * @property {array} statistics [statistics_band1, statistics_band2, ] Each element is a statistics object representing min and max values
        **/
        decode: function(encodedData, options) {
          if (!isPlatformLittleEndian) {
            throw "Big endian system is not supported.";
          }
          options = options || {};
          var inputOffset = options.inputOffset || 0;
          var fileIdView = new Uint8Array(encodedData, inputOffset, 10);
          var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);
          var lerc2, majorVersion;
          if (fileIdentifierString.trim() === "CntZImage") {
            lerc2 = LercDecode2;
            majorVersion = 1;
          } else if (fileIdentifierString.substring(0, 5) === "Lerc2") {
            lerc2 = Lerc2Decode;
            majorVersion = 2;
          } else {
            throw "Unexpected file identifier string: " + fileIdentifierString;
          }
          var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;
          var decodedPixelBlock = {
            width: 0,
            height: 0,
            pixels: [],
            pixelType: options.pixelType,
            mask: null,
            statistics: []
          };
          var uniqueBandMaskCount = 0;
          while (inputOffset < eof) {
            var result = lerc2.decode(encodedData, {
              inputOffset,
              //for both lerc1 and lerc2
              encodedMaskData,
              //lerc1 only
              maskData,
              //lerc2 only
              returnMask: iPlane === 0 ? true : false,
              //lerc1 only
              returnEncodedMask: iPlane === 0 ? true : false,
              //lerc1 only
              returnFileInfo: true,
              //for both lerc1 and lerc2
              returnPixelInterleavedDims: options.returnPixelInterleavedDims,
              //for ndim lerc2 only
              pixelType: options.pixelType || null,
              //lerc1 only
              noDataValue: options.noDataValue || null
              //lerc1 only
            });
            inputOffset = result.fileInfo.eofOffset;
            maskData = result.maskData;
            if (iPlane === 0) {
              encodedMaskData = result.encodedMaskData;
              decodedPixelBlock.width = result.width;
              decodedPixelBlock.height = result.height;
              decodedPixelBlock.dimCount = result.dimCount || 1;
              decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;
              decodedPixelBlock.mask = maskData;
            }
            if (majorVersion > 1) {
              if (maskData) {
                bandMasks.push(maskData);
              }
              if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {
                uniqueBandMaskCount++;
              }
            }
            iPlane++;
            decodedPixelBlock.pixels.push(result.pixelData);
            decodedPixelBlock.statistics.push({
              minValue: result.minValue,
              maxValue: result.maxValue,
              noDataValue: result.noDataValue,
              dimStats: result.dimStats
            });
          }
          var i, j, numPixels;
          if (majorVersion > 1 && uniqueBandMaskCount > 1) {
            numPixels = decodedPixelBlock.width * decodedPixelBlock.height;
            decodedPixelBlock.bandMasks = bandMasks;
            maskData = new Uint8Array(numPixels);
            maskData.set(bandMasks[0]);
            for (i = 1; i < bandMasks.length; i++) {
              bandMask = bandMasks[i];
              for (j = 0; j < numPixels; j++) {
                maskData[j] = maskData[j] & bandMask[j];
              }
            }
            decodedPixelBlock.maskData = maskData;
          }
          return decodedPixelBlock;
        }
      };
      if (module.exports) {
        module.exports = Lerc;
      } else {
        this.Lerc = Lerc;
      }
    })();
  })(LercDecode);
  return LercDecodeExports;
}
var hasRequiredLerc;
function requireLerc() {
  if (hasRequiredLerc)
    return lerc;
  hasRequiredLerc = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(lerc, "__esModule", { value: true });
  const pako_1 = requirePako();
  const lerc_1 = __importDefault(requireLercDecode());
  const basedecoder_js_1 = __importDefault(requireBasedecoder());
  const globals_js_1 = requireGlobals();
  class LercDecoder extends basedecoder_js_1.default {
    constructor(fileDirectory) {
      super();
      this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== "undefined" ? fileDirectory.PlanarConfiguration : 1;
      this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== "undefined" ? fileDirectory.SamplesPerPixel : 1;
      this.addCompression = fileDirectory.LercParameters[globals_js_1.LercParameters.AddCompression];
    }
    decodeBlock(buffer2) {
      switch (this.addCompression) {
        case globals_js_1.LercAddCompression.None:
          break;
        case globals_js_1.LercAddCompression.Deflate:
          buffer2 = (0, pako_1.inflate)(new Uint8Array(buffer2)).buffer;
          break;
        default:
          throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);
      }
      const lercResult = lerc_1.default.decode(buffer2, { returnPixelInterleavedDims: this.planarConfiguration === 1 });
      const lercData = lercResult.pixels[0];
      return lercData.buffer;
    }
  }
  lerc.default = LercDecoder;
  return lerc;
}
var webimage = {};
var hasRequiredWebimage;
function requireWebimage() {
  if (hasRequiredWebimage)
    return webimage;
  hasRequiredWebimage = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(webimage, "__esModule", { value: true });
  const basedecoder_js_1 = __importDefault(requireBasedecoder());
  class WebImageDecoder extends basedecoder_js_1.default {
    constructor() {
      super();
      if (typeof createImageBitmap === "undefined") {
        throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");
      } else if (typeof document === "undefined" && typeof OffscreenCanvas === "undefined") {
        throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");
      }
    }
    async decode(fileDirectory, buffer2) {
      const blob = new Blob([buffer2]);
      const imageBitmap = await createImageBitmap(blob);
      let canvas;
      if (typeof document !== "undefined") {
        canvas = document.createElement("canvas");
        canvas.width = imageBitmap.width;
        canvas.height = imageBitmap.height;
      } else {
        canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
      }
      const ctx = canvas.getContext("2d");
      ctx.drawImage(imageBitmap, 0, 0);
      return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;
    }
  }
  webimage.default = WebImageDecoder;
  return webimage;
}
var hasRequiredCompression;
function requireCompression() {
  if (hasRequiredCompression)
    return compression;
  hasRequiredCompression = 1;
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(compression, "__esModule", { value: true });
  compression.getDecoder = compression.addDecoder = void 0;
  const registry = /* @__PURE__ */ new Map();
  function addDecoder(cases, importFn) {
    if (!Array.isArray(cases)) {
      cases = [cases];
    }
    cases.forEach((c) => registry.set(c, importFn));
  }
  compression.addDecoder = addDecoder;
  async function getDecoder(fileDirectory) {
    const importFn = registry.get(fileDirectory.Compression);
    if (!importFn) {
      throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);
    }
    const Decoder = await importFn();
    return new Decoder(fileDirectory);
  }
  compression.getDecoder = getDecoder;
  addDecoder([void 0, 1], () => Promise.resolve().then(() => __importStar(requireRaw())).then((m) => m.default));
  addDecoder(5, () => Promise.resolve().then(() => __importStar(requireLzw())).then((m) => m.default));
  addDecoder(6, () => {
    throw new Error("old style JPEG compression is not supported.");
  });
  addDecoder(7, () => Promise.resolve().then(() => __importStar(requireJpeg())).then((m) => m.default));
  addDecoder([8, 32946], () => Promise.resolve().then(() => __importStar(requireDeflate())).then((m) => m.default));
  addDecoder(32773, () => Promise.resolve().then(() => __importStar(requirePackbits())).then((m) => m.default));
  addDecoder(34887, () => Promise.resolve().then(() => __importStar(requireLerc())).then((m) => m.default));
  addDecoder(50001, () => Promise.resolve().then(() => __importStar(requireWebimage())).then((m) => m.default));
  return compression;
}
var resample = {};
var hasRequiredResample;
function requireResample() {
  if (hasRequiredResample)
    return resample;
  hasRequiredResample = 1;
  Object.defineProperty(resample, "__esModule", { value: true });
  resample.resampleInterleaved = resample.resampleBilinearInterleaved = resample.resampleNearestInterleaved = resample.resample = resample.resampleBilinear = resample.resampleNearest = void 0;
  function copyNewSize(array, width, height, samplesPerPixel = 1) {
    return new (Object.getPrototypeOf(array)).constructor(width * height * samplesPerPixel);
  }
  function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    return valueArrays.map((array) => {
      const newArray = copyNewSize(array, outWidth, outHeight);
      for (let y = 0; y < outHeight; ++y) {
        const cy = Math.min(Math.round(relY * y), inHeight - 1);
        for (let x = 0; x < outWidth; ++x) {
          const cx = Math.min(Math.round(relX * x), inWidth - 1);
          const value = array[cy * inWidth + cx];
          newArray[y * outWidth + x] = value;
        }
      }
      return newArray;
    });
  }
  resample.resampleNearest = resampleNearest;
  function lerp2(v0, v1, t) {
    return (1 - t) * v0 + t * v1;
  }
  function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    return valueArrays.map((array) => {
      const newArray = copyNewSize(array, outWidth, outHeight);
      for (let y = 0; y < outHeight; ++y) {
        const rawY = relY * y;
        const yl = Math.floor(rawY);
        const yh = Math.min(Math.ceil(rawY), inHeight - 1);
        for (let x = 0; x < outWidth; ++x) {
          const rawX = relX * x;
          const tx = rawX % 1;
          const xl = Math.floor(rawX);
          const xh = Math.min(Math.ceil(rawX), inWidth - 1);
          const ll = array[yl * inWidth + xl];
          const hl = array[yl * inWidth + xh];
          const lh = array[yh * inWidth + xl];
          const hh = array[yh * inWidth + xh];
          const value = lerp2(lerp2(ll, hl, tx), lerp2(lh, hh, tx), rawY % 1);
          newArray[y * outWidth + x] = value;
        }
      }
      return newArray;
    });
  }
  resample.resampleBilinear = resampleBilinear;
  function resample$1(valueArrays, inWidth, inHeight, outWidth, outHeight, method = "nearest") {
    switch (method.toLowerCase()) {
      case "nearest":
        return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);
      case "bilinear":
      case "linear":
        return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);
      default:
        throw new Error(`Unsupported resampling method: '${method}'`);
    }
  }
  resample.resample = resample$1;
  function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
    for (let y = 0; y < outHeight; ++y) {
      const cy = Math.min(Math.round(relY * y), inHeight - 1);
      for (let x = 0; x < outWidth; ++x) {
        const cx = Math.min(Math.round(relX * x), inWidth - 1);
        for (let i = 0; i < samples; ++i) {
          const value = valueArray[cy * inWidth * samples + cx * samples + i];
          newArray[y * outWidth * samples + x * samples + i] = value;
        }
      }
    }
    return newArray;
  }
  resample.resampleNearestInterleaved = resampleNearestInterleaved;
  function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
    for (let y = 0; y < outHeight; ++y) {
      const rawY = relY * y;
      const yl = Math.floor(rawY);
      const yh = Math.min(Math.ceil(rawY), inHeight - 1);
      for (let x = 0; x < outWidth; ++x) {
        const rawX = relX * x;
        const tx = rawX % 1;
        const xl = Math.floor(rawX);
        const xh = Math.min(Math.ceil(rawX), inWidth - 1);
        for (let i = 0; i < samples; ++i) {
          const ll = valueArray[yl * inWidth * samples + xl * samples + i];
          const hl = valueArray[yl * inWidth * samples + xh * samples + i];
          const lh = valueArray[yh * inWidth * samples + xl * samples + i];
          const hh = valueArray[yh * inWidth * samples + xh * samples + i];
          const value = lerp2(lerp2(ll, hl, tx), lerp2(lh, hh, tx), rawY % 1);
          newArray[y * outWidth * samples + x * samples + i] = value;
        }
      }
    }
    return newArray;
  }
  resample.resampleBilinearInterleaved = resampleBilinearInterleaved;
  function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = "nearest") {
    switch (method.toLowerCase()) {
      case "nearest":
        return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
      case "bilinear":
      case "linear":
        return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
      default:
        throw new Error(`Unsupported resampling method: '${method}'`);
    }
  }
  resample.resampleInterleaved = resampleInterleaved;
  return resample;
}
var hasRequiredGeotiffimage;
function requireGeotiffimage() {
  if (hasRequiredGeotiffimage)
    return geotiffimage;
  hasRequiredGeotiffimage = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(geotiffimage, "__esModule", { value: true });
  const float16_1 = requireLib();
  const get_attribute_js_1 = __importDefault(requireGetAttribute());
  const find_tags_by_name_js_1 = __importDefault(requireFindTagsByName());
  const globals_js_1 = requireGlobals();
  const rgb_js_1 = requireRgb();
  const index_js_1 = requireCompression();
  const resample_js_1 = requireResample();
  function sum(array, start2, end) {
    let s = 0;
    for (let i = start2; i < end; ++i) {
      s += array[i];
    }
    return s;
  }
  function arrayForType(format, bitsPerSample, size) {
    switch (format) {
      case 1:
        if (bitsPerSample <= 8) {
          return new Uint8Array(size);
        } else if (bitsPerSample <= 16) {
          return new Uint16Array(size);
        } else if (bitsPerSample <= 32) {
          return new Uint32Array(size);
        }
        break;
      case 2:
        if (bitsPerSample === 8) {
          return new Int8Array(size);
        } else if (bitsPerSample === 16) {
          return new Int16Array(size);
        } else if (bitsPerSample === 32) {
          return new Int32Array(size);
        }
        break;
      case 3:
        switch (bitsPerSample) {
          case 16:
          case 32:
            return new Float32Array(size);
          case 64:
            return new Float64Array(size);
        }
        break;
    }
    throw Error("Unsupported data format/bitsPerSample");
  }
  function needsNormalization(format, bitsPerSample) {
    if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {
      return false;
    } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {
      return false;
    }
    return true;
  }
  function normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {
    const view = new DataView(inBuffer);
    const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;
    const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;
    const outArray = arrayForType(format, bitsPerSample, outSize);
    const bitMask = parseInt("1".repeat(bitsPerSample), 2);
    if (format === 1) {
      let pixelBitSkip;
      if (planarConfiguration === 1) {
        pixelBitSkip = samplesPerPixel * bitsPerSample;
      } else {
        pixelBitSkip = bitsPerSample;
      }
      let bitsPerLine = tileWidth * pixelBitSkip;
      if ((bitsPerLine & 7) !== 0) {
        bitsPerLine = bitsPerLine + 7 & ~7;
      }
      for (let y = 0; y < tileHeight; ++y) {
        const lineBitOffset = y * bitsPerLine;
        for (let x = 0; x < tileWidth; ++x) {
          const pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;
          for (let i = 0; i < samplesToTransfer; ++i) {
            const bitOffset = pixelBitOffset + i * bitsPerSample;
            const outIndex = (y * tileWidth + x) * samplesToTransfer + i;
            const byteOffset = Math.floor(bitOffset / 8);
            const innerBitOffset = bitOffset % 8;
            if (innerBitOffset + bitsPerSample <= 8) {
              outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;
            } else if (innerBitOffset + bitsPerSample <= 16) {
              outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;
            } else if (innerBitOffset + bitsPerSample <= 24) {
              const raw2 = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);
              outArray[outIndex] = raw2 >> 24 - bitsPerSample - innerBitOffset & bitMask;
            } else {
              outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;
            }
          }
        }
      }
    }
    return outArray.buffer;
  }
  class GeoTIFFImage {
    /**
     * @constructor
     * @param {Object} fileDirectory The parsed file directory
     * @param {Object} geoKeys The parsed geo-keys
     * @param {DataView} dataView The DataView for the underlying file.
     * @param {Boolean} littleEndian Whether the file is encoded in little or big endian
     * @param {Boolean} cache Whether or not decoded tiles shall be cached
     * @param {Source} source The datasource to read from
     */
    constructor(fileDirectory, geoKeys, dataView, littleEndian, cache2, source) {
      this.fileDirectory = fileDirectory;
      this.geoKeys = geoKeys;
      this.dataView = dataView;
      this.littleEndian = littleEndian;
      this.tiles = cache2 ? {} : null;
      this.isTiled = !fileDirectory.StripOffsets;
      const planarConfiguration = fileDirectory.PlanarConfiguration;
      this.planarConfiguration = typeof planarConfiguration === "undefined" ? 1 : planarConfiguration;
      if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {
        throw new Error("Invalid planar configuration.");
      }
      this.source = source;
    }
    /**
     * Returns the associated parsed file directory.
     * @returns {Object} the parsed file directory
     */
    getFileDirectory() {
      return this.fileDirectory;
    }
    /**
     * Returns the associated parsed geo keys.
     * @returns {Object} the parsed geo keys
     */
    getGeoKeys() {
      return this.geoKeys;
    }
    /**
     * Returns the width of the image.
     * @returns {Number} the width of the image
     */
    getWidth() {
      return this.fileDirectory.ImageWidth;
    }
    /**
     * Returns the height of the image.
     * @returns {Number} the height of the image
     */
    getHeight() {
      return this.fileDirectory.ImageLength;
    }
    /**
     * Returns the number of samples per pixel.
     * @returns {Number} the number of samples per pixel
     */
    getSamplesPerPixel() {
      return typeof this.fileDirectory.SamplesPerPixel !== "undefined" ? this.fileDirectory.SamplesPerPixel : 1;
    }
    /**
     * Returns the width of each tile.
     * @returns {Number} the width of each tile
     */
    getTileWidth() {
      return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
    }
    /**
     * Returns the height of each tile.
     * @returns {Number} the height of each tile
     */
    getTileHeight() {
      if (this.isTiled) {
        return this.fileDirectory.TileLength;
      }
      if (typeof this.fileDirectory.RowsPerStrip !== "undefined") {
        return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());
      }
      return this.getHeight();
    }
    getBlockWidth() {
      return this.getTileWidth();
    }
    getBlockHeight(y) {
      if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {
        return this.getTileHeight();
      } else {
        return this.getHeight() - y * this.getTileHeight();
      }
    }
    /**
     * Calculates the number of bytes for each pixel across all samples. Only full
     * bytes are supported, an exception is thrown when this is not the case.
     * @returns {Number} the bytes per pixel
     */
    getBytesPerPixel() {
      let bytes = 0;
      for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {
        bytes += this.getSampleByteSize(i);
      }
      return bytes;
    }
    getSampleByteSize(i) {
      if (i >= this.fileDirectory.BitsPerSample.length) {
        throw new RangeError(`Sample index ${i} is out of range.`);
      }
      return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);
    }
    getReaderForSample(sampleIndex) {
      const format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
      const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];
      switch (format) {
        case 1:
          if (bitsPerSample <= 8) {
            return DataView.prototype.getUint8;
          } else if (bitsPerSample <= 16) {
            return DataView.prototype.getUint16;
          } else if (bitsPerSample <= 32) {
            return DataView.prototype.getUint32;
          }
          break;
        case 2:
          if (bitsPerSample <= 8) {
            return DataView.prototype.getInt8;
          } else if (bitsPerSample <= 16) {
            return DataView.prototype.getInt16;
          } else if (bitsPerSample <= 32) {
            return DataView.prototype.getInt32;
          }
          break;
        case 3:
          switch (bitsPerSample) {
            case 16:
              return function(offset, littleEndian) {
                return (0, float16_1.getFloat16)(this, offset, littleEndian);
              };
            case 32:
              return DataView.prototype.getFloat32;
            case 64:
              return DataView.prototype.getFloat64;
          }
          break;
      }
      throw Error("Unsupported data format/bitsPerSample");
    }
    getSampleFormat(sampleIndex = 0) {
      return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
    }
    getBitsPerSample(sampleIndex = 0) {
      return this.fileDirectory.BitsPerSample[sampleIndex];
    }
    getArrayForSample(sampleIndex, size) {
      const format = this.getSampleFormat(sampleIndex);
      const bitsPerSample = this.getBitsPerSample(sampleIndex);
      return arrayForType(format, bitsPerSample, size);
    }
    /**
     * Returns the decoded strip or tile.
     * @param {Number} x the strip or tile x-offset
     * @param {Number} y the tile y-offset (0 for stripped images)
     * @param {Number} sample the sample to get for separated samples
     * @param {import("./geotiff").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise.<ArrayBuffer>}
     */
    async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {
      const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());
      const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());
      let index;
      const { tiles } = this;
      if (this.planarConfiguration === 1) {
        index = y * numTilesPerRow + x;
      } else if (this.planarConfiguration === 2) {
        index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;
      }
      let offset;
      let byteCount;
      if (this.isTiled) {
        offset = this.fileDirectory.TileOffsets[index];
        byteCount = this.fileDirectory.TileByteCounts[index];
      } else {
        offset = this.fileDirectory.StripOffsets[index];
        byteCount = this.fileDirectory.StripByteCounts[index];
      }
      const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];
      let request;
      if (tiles === null || !tiles[index]) {
        request = (async () => {
          let data = await poolOrDecoder.decode(this.fileDirectory, slice);
          const sampleFormat = this.getSampleFormat();
          const bitsPerSample = this.getBitsPerSample();
          if (needsNormalization(sampleFormat, bitsPerSample)) {
            data = normalizeArray(data, sampleFormat, this.planarConfiguration, this.getSamplesPerPixel(), bitsPerSample, this.getTileWidth(), this.getBlockHeight(y));
          }
          return data;
        })();
        if (tiles !== null) {
          tiles[index] = request;
        }
      } else {
        request = tiles[index];
      }
      return { x, y, sample, data: await request };
    }
    /**
     * Internal read function.
     * @private
     * @param {Array} imageWindow The image window in pixel coordinates
     * @param {Array} samples The selected samples (0-based indices)
     * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into
     * @param {Boolean} interleave Whether or not to write in an interleaved manner
     * @param {import("./geotiff").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
     * @param {number} width the width of window to be read into
     * @param {number} height the height of window to be read into
     * @param {number} resampleMethod the resampling method to be used when interpolating
     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
     *                               to be aborted
     * @returns {Promise<TypedArray[]>|Promise<TypedArray>}
     */
    async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {
      const tileWidth = this.getTileWidth();
      const tileHeight = this.getTileHeight();
      const imageWidth = this.getWidth();
      const imageHeight = this.getHeight();
      const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);
      const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));
      const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);
      const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));
      const windowWidth = imageWindow[2] - imageWindow[0];
      let bytesPerPixel = this.getBytesPerPixel();
      const srcSampleOffsets = [];
      const sampleReaders = [];
      for (let i = 0; i < samples.length; ++i) {
        if (this.planarConfiguration === 1) {
          srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);
        } else {
          srcSampleOffsets.push(0);
        }
        sampleReaders.push(this.getReaderForSample(samples[i]));
      }
      const promises = [];
      const { littleEndian } = this;
      for (let yTile = minYTile; yTile < maxYTile; ++yTile) {
        for (let xTile = minXTile; xTile < maxXTile; ++xTile) {
          for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {
            const si = sampleIndex;
            const sample = samples[sampleIndex];
            if (this.planarConfiguration === 2) {
              bytesPerPixel = this.getSampleByteSize(sampleIndex);
            }
            const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then((tile) => {
              const buffer2 = tile.data;
              const dataView = new DataView(buffer2);
              const blockHeight = this.getBlockHeight(tile.y);
              const firstLine = tile.y * tileHeight;
              const firstCol = tile.x * tileWidth;
              const lastLine = firstLine + blockHeight;
              const lastCol = (tile.x + 1) * tileWidth;
              const reader = sampleReaders[si];
              const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);
              const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);
              for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {
                for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {
                  const pixelOffset = (y * tileWidth + x) * bytesPerPixel;
                  const value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);
                  let windowCoordinate;
                  if (interleave) {
                    windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;
                    valueArrays[windowCoordinate] = value;
                  } else {
                    windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];
                    valueArrays[si][windowCoordinate] = value;
                  }
                }
              }
            });
            promises.push(promise);
          }
        }
      }
      await Promise.all(promises);
      if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {
        let resampled;
        if (interleave) {
          resampled = (0, resample_js_1.resampleInterleaved)(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);
        } else {
          resampled = (0, resample_js_1.resample)(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);
        }
        resampled.width = width;
        resampled.height = height;
        return resampled;
      }
      valueArrays.width = width || imageWindow[2] - imageWindow[0];
      valueArrays.height = height || imageWindow[3] - imageWindow[1];
      return valueArrays;
    }
    /**
     * Reads raster data from the image. This function reads all selected samples
     * into separate arrays of the correct type for that sample or into a single
     * combined array when `interleave` is set. When provided, only a subset
     * of the raster is read for each sample.
     *
     * @param {ReadRasterOptions} [options={}] optional parameters
     * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise
     */
    async readRasters({ window: wnd, samples = [], interleave, pool: pool2 = null, width, height, resampleMethod, fillValue, signal } = {}) {
      const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];
      if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {
        throw new Error("Invalid subsets");
      }
      const imageWindowWidth = imageWindow[2] - imageWindow[0];
      const imageWindowHeight = imageWindow[3] - imageWindow[1];
      const numPixels = imageWindowWidth * imageWindowHeight;
      const samplesPerPixel = this.getSamplesPerPixel();
      if (!samples || !samples.length) {
        for (let i = 0; i < samplesPerPixel; ++i) {
          samples.push(i);
        }
      } else {
        for (let i = 0; i < samples.length; ++i) {
          if (samples[i] >= samplesPerPixel) {
            return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));
          }
        }
      }
      let valueArrays;
      if (interleave) {
        const format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;
        const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);
        valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);
        if (fillValue) {
          valueArrays.fill(fillValue);
        }
      } else {
        valueArrays = [];
        for (let i = 0; i < samples.length; ++i) {
          const valueArray = this.getArrayForSample(samples[i], numPixels);
          if (Array.isArray(fillValue) && i < fillValue.length) {
            valueArray.fill(fillValue[i]);
          } else if (fillValue && !Array.isArray(fillValue)) {
            valueArray.fill(fillValue);
          }
          valueArrays.push(valueArray);
        }
      }
      const poolOrDecoder = pool2 || await (0, index_js_1.getDecoder)(this.fileDirectory);
      const result = await this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);
      return result;
    }
    /**
     * Reads raster data from the image as RGB. The result is always an
     * interleaved typed array.
     * Colorspaces other than RGB will be transformed to RGB, color maps expanded.
     * When no other method is applicable, the first sample is used to produce a
     * greayscale image.
     * When provided, only a subset of the raster is read for each sample.
     *
     * @param {Object} [options] optional parameters
     * @param {Array<number>} [options.window] the subset to read data from in pixels.
     * @param {boolean} [options.interleave=true] whether the data shall be read
     *                                             in one single array or separate
     *                                             arrays.
     * @param {import("./geotiff").Pool} [options.pool=null] The optional decoder pool to use.
     * @param {number} [options.width] The desired width of the output. When the width is no the
     *                                 same as the images, resampling will be performed.
     * @param {number} [options.height] The desired height of the output. When the width is no the
     *                                  same as the images, resampling will be performed.
     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.
     * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.
     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
     *                                       to be aborted
     * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise
     */
    async readRGB({ window: window2, interleave = true, pool: pool2 = null, width, height, resampleMethod, enableAlpha = false, signal } = {}) {
      const imageWindow = window2 || [0, 0, this.getWidth(), this.getHeight()];
      if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {
        throw new Error("Invalid subsets");
      }
      const pi = this.fileDirectory.PhotometricInterpretation;
      if (pi === globals_js_1.photometricInterpretations.RGB) {
        let s = [0, 1, 2];
        if (!(this.fileDirectory.ExtraSamples === globals_js_1.ExtraSamplesValues.Unspecified) && enableAlpha) {
          s = [];
          for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {
            s.push(i);
          }
        }
        return this.readRasters({
          window: window2,
          interleave,
          samples: s,
          pool: pool2,
          width,
          height,
          resampleMethod,
          signal
        });
      }
      let samples;
      switch (pi) {
        case globals_js_1.photometricInterpretations.WhiteIsZero:
        case globals_js_1.photometricInterpretations.BlackIsZero:
        case globals_js_1.photometricInterpretations.Palette:
          samples = [0];
          break;
        case globals_js_1.photometricInterpretations.CMYK:
          samples = [0, 1, 2, 3];
          break;
        case globals_js_1.photometricInterpretations.YCbCr:
        case globals_js_1.photometricInterpretations.CIELab:
          samples = [0, 1, 2];
          break;
        default:
          throw new Error("Invalid or unsupported photometric interpretation.");
      }
      const subOptions = {
        window: imageWindow,
        interleave: true,
        samples,
        pool: pool2,
        width,
        height,
        resampleMethod,
        signal
      };
      const { fileDirectory } = this;
      const raster = await this.readRasters(subOptions);
      const max = 2 ** this.fileDirectory.BitsPerSample[0];
      let data;
      switch (pi) {
        case globals_js_1.photometricInterpretations.WhiteIsZero:
          data = (0, rgb_js_1.fromWhiteIsZero)(raster, max);
          break;
        case globals_js_1.photometricInterpretations.BlackIsZero:
          data = (0, rgb_js_1.fromBlackIsZero)(raster, max);
          break;
        case globals_js_1.photometricInterpretations.Palette:
          data = (0, rgb_js_1.fromPalette)(raster, fileDirectory.ColorMap);
          break;
        case globals_js_1.photometricInterpretations.CMYK:
          data = (0, rgb_js_1.fromCMYK)(raster);
          break;
        case globals_js_1.photometricInterpretations.YCbCr:
          data = (0, rgb_js_1.fromYCbCr)(raster);
          break;
        case globals_js_1.photometricInterpretations.CIELab:
          data = (0, rgb_js_1.fromCIELab)(raster);
          break;
        default:
          throw new Error("Unsupported photometric interpretation.");
      }
      if (!interleave) {
        const red = new Uint8Array(data.length / 3);
        const green = new Uint8Array(data.length / 3);
        const blue = new Uint8Array(data.length / 3);
        for (let i = 0, j = 0; i < data.length; i += 3, ++j) {
          red[j] = data[i];
          green[j] = data[i + 1];
          blue[j] = data[i + 2];
        }
        data = [red, green, blue];
      }
      data.width = raster.width;
      data.height = raster.height;
      return data;
    }
    /**
     * Returns an array of tiepoints.
     * @returns {Object[]}
     */
    getTiePoints() {
      if (!this.fileDirectory.ModelTiepoint) {
        return [];
      }
      const tiePoints = [];
      for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {
        tiePoints.push({
          i: this.fileDirectory.ModelTiepoint[i],
          j: this.fileDirectory.ModelTiepoint[i + 1],
          k: this.fileDirectory.ModelTiepoint[i + 2],
          x: this.fileDirectory.ModelTiepoint[i + 3],
          y: this.fileDirectory.ModelTiepoint[i + 4],
          z: this.fileDirectory.ModelTiepoint[i + 5]
        });
      }
      return tiePoints;
    }
    /**
     * Returns the parsed GDAL metadata items.
     *
     * If sample is passed to null, dataset-level metadata will be returned.
     * Otherwise only metadata specific to the provided sample will be returned.
     *
     * @param {number} [sample=null] The sample index.
     * @returns {Object}
     */
    getGDALMetadata(sample = null) {
      const metadata = {};
      if (!this.fileDirectory.GDAL_METADATA) {
        return null;
      }
      const string = this.fileDirectory.GDAL_METADATA;
      let items = (0, find_tags_by_name_js_1.default)(string, "Item");
      if (sample === null) {
        items = items.filter((item) => (0, get_attribute_js_1.default)(item, "sample") === void 0);
      } else {
        items = items.filter((item) => Number((0, get_attribute_js_1.default)(item, "sample")) === sample);
      }
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        metadata[(0, get_attribute_js_1.default)(item, "name")] = item.inner;
      }
      return metadata;
    }
    /**
     * Returns the GDAL nodata value
     * @returns {number|null}
     */
    getGDALNoData() {
      if (!this.fileDirectory.GDAL_NODATA) {
        return null;
      }
      const string = this.fileDirectory.GDAL_NODATA;
      return Number(string.substring(0, string.length - 1));
    }
    /**
     * Returns the image origin as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @returns {Array<number>} The origin as a vector
     */
    getOrigin() {
      const tiePoints = this.fileDirectory.ModelTiepoint;
      const modelTransformation = this.fileDirectory.ModelTransformation;
      if (tiePoints && tiePoints.length === 6) {
        return [
          tiePoints[3],
          tiePoints[4],
          tiePoints[5]
        ];
      }
      if (modelTransformation) {
        return [
          modelTransformation[3],
          modelTransformation[7],
          modelTransformation[11]
        ];
      }
      throw new Error("The image does not have an affine transformation.");
    }
    /**
     * Returns the image resolution as a XYZ-vector. When the image has no affine
     * transformation, then an exception is thrown.
     * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from
     *                                             in cases when the current image does not have the
     *                                             required tags on its own.
     * @returns {Array<number>} The resolution as a vector
     */
    getResolution(referenceImage = null) {
      const modelPixelScale = this.fileDirectory.ModelPixelScale;
      const modelTransformation = this.fileDirectory.ModelTransformation;
      if (modelPixelScale) {
        return [
          modelPixelScale[0],
          -modelPixelScale[1],
          modelPixelScale[2]
        ];
      }
      if (modelTransformation) {
        return [
          modelTransformation[0],
          modelTransformation[5],
          modelTransformation[10]
        ];
      }
      if (referenceImage) {
        const [refResX, refResY, refResZ] = referenceImage.getResolution();
        return [
          refResX * referenceImage.getWidth() / this.getWidth(),
          refResY * referenceImage.getHeight() / this.getHeight(),
          refResZ * referenceImage.getWidth() / this.getWidth()
        ];
      }
      throw new Error("The image does not have an affine transformation.");
    }
    /**
     * Returns whether or not the pixels of the image depict an area (or point).
     * @returns {Boolean} Whether the pixels are a point
     */
    pixelIsArea() {
      return this.geoKeys.GTRasterTypeGeoKey === 1;
    }
    /**
     * Returns the image bounding box as an array of 4 values: min-x, min-y,
     * max-x and max-y. When the image has no affine transformation, then an
     * exception is thrown.
     * @returns {Array<number>} The bounding box
     */
    getBoundingBox() {
      const origin = this.getOrigin();
      const resolution = this.getResolution();
      const x1 = origin[0];
      const y1 = origin[1];
      const x2 = x1 + resolution[0] * this.getWidth();
      const y2 = y1 + resolution[1] * this.getHeight();
      return [
        Math.min(x1, x2),
        Math.min(y1, y2),
        Math.max(x1, x2),
        Math.max(y1, y2)
      ];
    }
  }
  geotiffimage.default = GeoTIFFImage;
  return geotiffimage;
}
var dataview64 = {};
var hasRequiredDataview64;
function requireDataview64() {
  if (hasRequiredDataview64)
    return dataview64;
  hasRequiredDataview64 = 1;
  Object.defineProperty(dataview64, "__esModule", { value: true });
  const float16_1 = requireLib();
  class DataView64 {
    constructor(arrayBuffer) {
      this._dataView = new DataView(arrayBuffer);
    }
    get buffer() {
      return this._dataView.buffer;
    }
    getUint64(offset, littleEndian) {
      const left = this.getUint32(offset, littleEndian);
      const right = this.getUint32(offset + 4, littleEndian);
      let combined;
      if (littleEndian) {
        combined = left + 2 ** 32 * right;
        if (!Number.isSafeInteger(combined)) {
          throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
        }
        return combined;
      }
      combined = 2 ** 32 * left + right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      }
      return combined;
    }
    // adapted from https://stackoverflow.com/a/55338384/8060591
    getInt64(offset, littleEndian) {
      let value = 0;
      const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 128) > 0;
      let carrying = true;
      for (let i = 0; i < 8; i++) {
        let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));
        if (isNegative) {
          if (carrying) {
            if (byte !== 0) {
              byte = ~(byte - 1) & 255;
              carrying = false;
            }
          } else {
            byte = ~byte & 255;
          }
        }
        value += byte * 256 ** i;
      }
      if (isNegative) {
        value = -value;
      }
      return value;
    }
    getUint8(offset, littleEndian) {
      return this._dataView.getUint8(offset, littleEndian);
    }
    getInt8(offset, littleEndian) {
      return this._dataView.getInt8(offset, littleEndian);
    }
    getUint16(offset, littleEndian) {
      return this._dataView.getUint16(offset, littleEndian);
    }
    getInt16(offset, littleEndian) {
      return this._dataView.getInt16(offset, littleEndian);
    }
    getUint32(offset, littleEndian) {
      return this._dataView.getUint32(offset, littleEndian);
    }
    getInt32(offset, littleEndian) {
      return this._dataView.getInt32(offset, littleEndian);
    }
    getFloat16(offset, littleEndian) {
      return (0, float16_1.getFloat16)(this._dataView, offset, littleEndian);
    }
    getFloat32(offset, littleEndian) {
      return this._dataView.getFloat32(offset, littleEndian);
    }
    getFloat64(offset, littleEndian) {
      return this._dataView.getFloat64(offset, littleEndian);
    }
  }
  dataview64.default = DataView64;
  return dataview64;
}
var dataslice = {};
var hasRequiredDataslice;
function requireDataslice() {
  if (hasRequiredDataslice)
    return dataslice;
  hasRequiredDataslice = 1;
  Object.defineProperty(dataslice, "__esModule", { value: true });
  class DataSlice {
    constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {
      this._dataView = new DataView(arrayBuffer);
      this._sliceOffset = sliceOffset;
      this._littleEndian = littleEndian;
      this._bigTiff = bigTiff;
    }
    get sliceOffset() {
      return this._sliceOffset;
    }
    get sliceTop() {
      return this._sliceOffset + this.buffer.byteLength;
    }
    get littleEndian() {
      return this._littleEndian;
    }
    get bigTiff() {
      return this._bigTiff;
    }
    get buffer() {
      return this._dataView.buffer;
    }
    covers(offset, length) {
      return this.sliceOffset <= offset && this.sliceTop >= offset + length;
    }
    readUint8(offset) {
      return this._dataView.getUint8(offset - this._sliceOffset, this._littleEndian);
    }
    readInt8(offset) {
      return this._dataView.getInt8(offset - this._sliceOffset, this._littleEndian);
    }
    readUint16(offset) {
      return this._dataView.getUint16(offset - this._sliceOffset, this._littleEndian);
    }
    readInt16(offset) {
      return this._dataView.getInt16(offset - this._sliceOffset, this._littleEndian);
    }
    readUint32(offset) {
      return this._dataView.getUint32(offset - this._sliceOffset, this._littleEndian);
    }
    readInt32(offset) {
      return this._dataView.getInt32(offset - this._sliceOffset, this._littleEndian);
    }
    readFloat32(offset) {
      return this._dataView.getFloat32(offset - this._sliceOffset, this._littleEndian);
    }
    readFloat64(offset) {
      return this._dataView.getFloat64(offset - this._sliceOffset, this._littleEndian);
    }
    readUint64(offset) {
      const left = this.readUint32(offset);
      const right = this.readUint32(offset + 4);
      let combined;
      if (this._littleEndian) {
        combined = left + 2 ** 32 * right;
        if (!Number.isSafeInteger(combined)) {
          throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
        }
        return combined;
      }
      combined = 2 ** 32 * left + right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      }
      return combined;
    }
    // adapted from https://stackoverflow.com/a/55338384/8060591
    readInt64(offset) {
      let value = 0;
      const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 128) > 0;
      let carrying = true;
      for (let i = 0; i < 8; i++) {
        let byte = this._dataView.getUint8(offset + (this._littleEndian ? i : 7 - i));
        if (isNegative) {
          if (carrying) {
            if (byte !== 0) {
              byte = ~(byte - 1) & 255;
              carrying = false;
            }
          } else {
            byte = ~byte & 255;
          }
        }
        value += byte * 256 ** i;
      }
      if (isNegative) {
        value = -value;
      }
      return value;
    }
    readOffset(offset) {
      if (this._bigTiff) {
        return this.readUint64(offset);
      }
      return this.readUint32(offset);
    }
  }
  dataslice.default = DataSlice;
  return dataslice;
}
var pool = {};
var decoder = {};
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  browser = Worker;
  return browser;
}
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder)
    return decoder;
  hasRequiredDecoder = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(decoder, "__esModule", { value: true });
  decoder.create = void 0;
  const web_worker_1 = __importDefault(requireBrowser());
  function create2() {
    const source = 'function e(e,t,r,n,i,a,o){try{var s=e[a](o),f=s.value}catch(e){return void r(e)}s.done?t(f):Promise.resolve(f).then(n,i)}function t(t){return function(){var r=this,n=arguments;return new Promise((function(i,a){var o=t.apply(r,n);function s(t){e(o,i,a,s,f,"next",t)}function f(t){e(o,i,a,s,f,"throw",t)}s(void 0)}))}}function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}var n={exports:{}};!function(e){var t=function(e){var t,n=Object.prototype,i=n.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},o=a.iterator||"@@iterator",s=a.asyncIterator||"@@asyncIterator",f=a.toStringTag||"@@toStringTag";function l(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{l({},"")}catch(e){l=function(e,t,r){return e[t]=r}}function u(e,t,r,n){var i=t&&t.prototype instanceof y?t:y,a=Object.create(i.prototype),o=new T(n||[]);return a._invoke=function(e,t,r){var n=h;return function(i,a){if(n===p)throw new Error("Generator is already running");if(n===m){if("throw"===i)throw a;return E()}for(r.method=i,r.arg=a;;){var o=r.delegate;if(o){var s=I(o,r);if(s){if(s===v)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=m,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=p;var f=c(e,t,r);if("normal"===f.type){if(n=r.done?m:d,f.arg===v)continue;return{value:f.arg,done:r.done}}"throw"===f.type&&(n=m,r.method="throw",r.arg=f.arg)}}}(e,r,o),a}function c(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}e.wrap=u;var h="suspendedStart",d="suspendedYield",p="executing",m="completed",v={};function y(){}function w(){}function g(){}var b={};l(b,o,(function(){return this}));var k=Object.getPrototypeOf,x=k&&k(k(D([])));x&&x!==n&&i.call(x,o)&&(b=x);var _=g.prototype=y.prototype=Object.create(b);function A(e){["next","throw","return"].forEach((function(t){l(e,t,(function(e){return this._invoke(t,e)}))}))}function P(e,t){function n(a,o,s,f){var l=c(e[a],e,o);if("throw"!==l.type){var u=l.arg,h=u.value;return h&&"object"===r(h)&&i.call(h,"__await")?t.resolve(h.__await).then((function(e){n("next",e,s,f)}),(function(e){n("throw",e,s,f)})):t.resolve(h).then((function(e){u.value=e,s(u)}),(function(e){return n("throw",e,s,f)}))}f(l.arg)}var a;this._invoke=function(e,r){function i(){return new t((function(t,i){n(e,r,t,i)}))}return a=a?a.then(i,i):i()}}function I(e,r){var n=e.iterator[r.method];if(n===t){if(r.delegate=null,"throw"===r.method){if(e.iterator.return&&(r.method="return",r.arg=t,I(e,r),"throw"===r.method))return v;r.method="throw",r.arg=new TypeError("The iterator does not provide a \'throw\' method")}return v}var i=c(n,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,v;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,v):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,v)}function U(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function S(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function T(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(U,this),this.reset(!0)}function D(e){if(e){var r=e[o];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var n=-1,a=function r(){for(;++n<e.length;)if(i.call(e,n))return r.value=e[n],r.done=!1,r;return r.value=t,r.done=!0,r};return a.next=a}}return{next:E}}function E(){return{value:t,done:!0}}return w.prototype=g,l(_,"constructor",g),l(g,"constructor",w),w.displayName=l(g,f,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===w||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,g):(e.__proto__=g,l(e,f,"GeneratorFunction")),e.prototype=Object.create(_),e},e.awrap=function(e){return{__await:e}},A(P.prototype),l(P.prototype,s,(function(){return this})),e.AsyncIterator=P,e.async=function(t,r,n,i,a){void 0===a&&(a=Promise);var o=new P(u(t,r,n,i),a);return e.isGeneratorFunction(r)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},A(_),l(_,f,"Generator"),l(_,o,(function(){return this})),l(_,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},e.values=D,T.prototype={constructor:T,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(S),!e)for(var r in this)"t"===r.charAt(0)&&i.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function n(n,i){return s.type="throw",s.arg=e,r.next=n,i&&(r.method="next",r.arg=t),!!i}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],s=o.completion;if("root"===o.tryLoc)return n("end");if(o.tryLoc<=this.prev){var f=i.call(o,"catchLoc"),l=i.call(o,"finallyLoc");if(f&&l){if(this.prev<o.catchLoc)return n(o.catchLoc,!0);if(this.prev<o.finallyLoc)return n(o.finallyLoc)}else if(f){if(this.prev<o.catchLoc)return n(o.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return n(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&i.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var a=n;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=e,o.arg=t,a?(this.method="next",this.next=a.finallyLoc,v):this.complete(o)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),v},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),S(r),v}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var i=n.arg;S(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:D(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),v}},e}(e.exports);try{regeneratorRuntime=t}catch(e){"object"===("undefined"==typeof globalThis?"undefined":r(globalThis))?globalThis.regeneratorRuntime=t:Function("r","regeneratorRuntime = r")(t)}}(n);var i=n.exports,a=new Map;function o(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){return a.set(e,t)}))}function s(e){return f.apply(this,arguments)}function f(){return(f=t(i.mark((function e(t){var r,n;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=a.get(t.Compression)){e.next=3;break}throw new Error("Unknown compression method identifier: ".concat(t.Compression));case 3:return e.next=5,r();case 5:return n=e.sent,e.abrupt("return",new n(t));case 7:case"end":return e.stop()}}),e)})))).apply(this,arguments)}o([void 0,1],(function(){return Promise.resolve().then((function(){return _})).then((function(e){return e.default}))})),o(5,(function(){return Promise.resolve().then((function(){return S})).then((function(e){return e.default}))})),o(6,(function(){throw new Error("old style JPEG compression is not supported.")})),o(7,(function(){return Promise.resolve().then((function(){return L})).then((function(e){return e.default}))})),o([8,32946],(function(){return Promise.resolve().then((function(){return Ne})).then((function(e){return e.default}))})),o(32773,(function(){return Promise.resolve().then((function(){return Ye})).then((function(e){return e.default}))})),o(34887,(function(){return Promise.resolve().then((function(){return ut})).then((function(e){return e.default}))})),o(50001,(function(){return Promise.resolve().then((function(){return dt})).then((function(e){return e.default}))}));var l=globalThis;function u(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function c(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function h(e,t,r){return t&&c(e.prototype,t),r&&c(e,r),e}function d(e,t){return d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},d(e,t)}function p(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&d(e,t)}function m(e,t){if(t&&("object"===r(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return e}(e)}function v(e){return v=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},v(e)}function y(e,t){var r=e.length-t,n=0;do{for(var i=t;i>0;i--)e[n+t]+=e[n],n++;r-=t}while(r>0)}function w(e,t,r){for(var n=0,i=e.length,a=i/r;i>t;){for(var o=t;o>0;--o)e[n+t]+=e[n],++n;i-=t}for(var s=e.slice(),f=0;f<a;++f)for(var l=0;l<r;++l)e[r*f+l]=s[(r-l-1)*a+f]}function g(e,t,r,n,i,a){if(!t||1===t)return e;for(var o=0;o<i.length;++o){if(i[o]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(i[o]!==i[0])throw new Error("When decoding with predictor, all samples must have the same size.")}for(var s=i[0]/8,f=2===a?1:i.length,l=0;l<n&&!(l*f*r*s>=e.byteLength);++l){var u=void 0;if(2===t){switch(i[0]){case 8:u=new Uint8Array(e,l*f*r*s,f*r*s);break;case 16:u=new Uint16Array(e,l*f*r*s,f*r*s/2);break;case 32:u=new Uint32Array(e,l*f*r*s,f*r*s/4);break;default:throw new Error("Predictor 2 not allowed with ".concat(i[0]," bits per sample."))}y(u,f)}else 3===t&&w(u=new Uint8Array(e,l*f*r*s,f*r*s),f,s)}return e}l.addEventListener("message",function(){var e=t(i.mark((function e(t){var r,n,a,o,f,u;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return r=t.data,n=r.id,a=r.fileDirectory,o=r.buffer,e.next=3,s(a);case 3:return f=e.sent,e.next=6,f.decode(a,o);case 6:u=e.sent,l.postMessage({decoded:u,id:n},[u]);case 8:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}());var b=function(){function e(){u(this,e)}var r;return h(e,[{key:"decode",value:(r=t(i.mark((function e(t,r){var n,a,o,s,f;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.decodeBlock(r);case 2:if(n=e.sent,1===(a=t.Predictor||1)){e.next=9;break}return o=!t.StripOffsets,s=o?t.TileWidth:t.ImageWidth,f=o?t.TileLength:t.RowsPerStrip||t.ImageLength,e.abrupt("return",g(n,a,s,f,t.BitsPerSample,t.PlanarConfiguration));case 9:return e.abrupt("return",n);case 10:case"end":return e.stop()}}),e,this)}))),function(e,t){return r.apply(this,arguments)})}]),e}();function k(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var x=function(e){p(r,b);var t=k(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return e}}]),r}(),_=Object.freeze({__proto__:null,default:x});function A(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}function P(e,t){for(var r=t.length-1;r>=0;r--)e.push(t[r]);return e}function I(e){for(var t=new Uint16Array(4093),r=new Uint8Array(4093),n=0;n<=257;n++)t[n]=4096,r[n]=n;var i=258,a=9,o=0;function s(){i=258,a=9}function f(e){var t=function(e,t,r){var n=t%8,i=Math.floor(t/8),a=8-n,o=t+r-8*(i+1),s=8*(i+2)-(t+r),f=8*(i+2)-t;if(s=Math.max(0,s),i>=e.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),257;var l=e[i]&Math.pow(2,8-n)-1,u=l<<=r-a;if(i+1<e.length){var c=e[i+1]>>>s;u+=c<<=Math.max(0,r-f)}if(o>8&&i+2<e.length){var h=8*(i+3)-(t+r);u+=e[i+2]>>>h}return u}(e,o,a);return o+=a,t}function l(e,n){return r[i]=n,t[i]=e,++i-1}function u(e){for(var n=[],i=e;4096!==i;i=t[i])n.push(r[i]);return n}var c=[];s();for(var h,d=new Uint8Array(e),p=f(d);257!==p;){if(256===p){for(s(),p=f(d);256===p;)p=f(d);if(257===p)break;if(p>256)throw new Error("corrupted code at scanline ".concat(p));P(c,u(p)),h=p}else if(p<i){var m=u(p);P(c,m),l(h,m[m.length-1]),h=p}else{var v=u(h);if(!v)throw new Error("Bogus entry. Not in dictionary, ".concat(h," / ").concat(i,", position: ").concat(o));P(c,v),c.push(v[v.length-1]),l(h,v[v.length-1]),h=p}i+1>=Math.pow(2,a)&&(12===a?h=void 0:a++),p=f(d)}return new Uint8Array(c)}var U=function(e){p(r,b);var t=A(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return I(e).buffer}}]),r}(),S=Object.freeze({__proto__:null,default:U});function T(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var D=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function E(e,t){for(var r=0,n=[],i=16;i>0&&!e[i-1];)--i;n.push({children:[],index:0});for(var a,o=n[0],s=0;s<i;s++){for(var f=0;f<e[s];f++){for((o=n.pop()).children[o.index]=t[r];o.index>0;)o=n.pop();for(o.index++,n.push(o);n.length<=s;)n.push(a={children:[],index:0}),o.children[o.index]=a.children,o=a;r++}s+1<i&&(n.push(a={children:[],index:0}),o.children[o.index]=a.children,o=a)}return n[0].children}function B(e,t,n,i,a,o,s,f,l){var u=n.mcusPerLine,c=n.progressive,h=t,d=t,p=0,m=0;function v(){if(m>0)return m--,p>>m&1;if(255===(p=e[d++])){var t=e[d++];if(t)throw new Error("unexpected marker: ".concat((p<<8|t).toString(16)))}return m=7,p>>>7}function y(e){for(var t,n=e;null!==(t=v());){if("number"==typeof(n=n[t]))return n;if("object"!==r(n))throw new Error("invalid huffman sequence")}return null}function w(e){for(var t=e,r=0;t>0;){var n=v();if(null===n)return;r=r<<1|n,--t}return r}function g(e){var t=w(e);return t>=1<<e-1?t:t+(-1<<e)+1}var b=0;var k,x=0;function _(e,t,r,n,i){var a=r%u,o=(r/u|0)*e.v+n,s=a*e.h+i;t(e,e.blocks[o][s])}function A(e,t,r){var n=r/e.blocksPerLine|0,i=r%e.blocksPerLine;t(e,e.blocks[n][i])}var P,I,U,S,T,E,B=i.length;E=c?0===o?0===f?function(e,t){var r=y(e.huffmanTableDC),n=0===r?0:g(r)<<l;e.pred+=n,t[0]=e.pred}:function(e,t){t[0]|=v()<<l}:0===f?function(e,t){if(b>0)b--;else for(var r=o,n=s;r<=n;){var i=y(e.huffmanTableAC),a=15&i,f=i>>4;if(0===a){if(f<15){b=w(f)+(1<<f)-1;break}r+=16}else t[D[r+=f]]=g(a)*(1<<l),r++}}:function(e,t){for(var r=o,n=s,i=0;r<=n;){var a=D[r],f=t[a]<0?-1:1;switch(x){case 0:var u=y(e.huffmanTableAC),c=15&u;if(i=u>>4,0===c)i<15?(b=w(i)+(1<<i),x=4):(i=16,x=1);else{if(1!==c)throw new Error("invalid ACn encoding");k=g(c),x=i?2:3}continue;case 1:case 2:t[a]?t[a]+=(v()<<l)*f:0==--i&&(x=2===x?3:0);break;case 3:t[a]?t[a]+=(v()<<l)*f:(t[a]=k<<l,x=0);break;case 4:t[a]&&(t[a]+=(v()<<l)*f)}r++}4===x&&0==--b&&(x=0)}:function(e,t){var r=y(e.huffmanTableDC),n=0===r?0:g(r);e.pred+=n,t[0]=e.pred;for(var i=1;i<64;){var a=y(e.huffmanTableAC),o=15&a,s=a>>4;if(0===o){if(s<15)break;i+=16}else t[D[i+=s]]=g(o),i++}};var O,M,C=0;M=1===B?i[0].blocksPerLine*i[0].blocksPerColumn:u*n.mcusPerColumn;for(var L=a||M;C<M;){for(I=0;I<B;I++)i[I].pred=0;if(b=0,1===B)for(P=i[0],T=0;T<L;T++)A(P,E,C),C++;else for(T=0;T<L;T++){for(I=0;I<B;I++){var R=P=i[I],V=R.h,G=R.v;for(U=0;U<G;U++)for(S=0;S<V;S++)_(P,E,C,U,S)}if(++C===M)break}if(m=0,(O=e[d]<<8|e[d+1])<65280)throw new Error("marker was not found");if(!(O>=65488&&O<=65495))break;d+=2}return d-h}function O(e,t){var r=[],n=t.blocksPerLine,i=t.blocksPerColumn,a=n<<3,o=new Int32Array(64),s=new Uint8Array(64);function f(e,r,n){var i,a,o,s,f,l,u,c,h,d,p=t.quantizationTable,m=n;for(d=0;d<64;d++)m[d]=e[d]*p[d];for(d=0;d<8;++d){var v=8*d;0!==m[1+v]||0!==m[2+v]||0!==m[3+v]||0!==m[4+v]||0!==m[5+v]||0!==m[6+v]||0!==m[7+v]?(i=5793*m[0+v]+128>>8,a=5793*m[4+v]+128>>8,o=m[2+v],s=m[6+v],f=2896*(m[1+v]-m[7+v])+128>>8,c=2896*(m[1+v]+m[7+v])+128>>8,l=m[3+v]<<4,h=i-a+1>>1,i=i+a+1>>1,a=h,h=3784*o+1567*s+128>>8,o=1567*o-3784*s+128>>8,s=h,h=f-(u=m[5+v]<<4)+1>>1,f=f+u+1>>1,u=h,h=c+l+1>>1,l=c-l+1>>1,c=h,h=i-s+1>>1,i=i+s+1>>1,s=h,h=a-o+1>>1,a=a+o+1>>1,o=h,h=2276*f+3406*c+2048>>12,f=3406*f-2276*c+2048>>12,c=h,h=799*l+4017*u+2048>>12,l=4017*l-799*u+2048>>12,u=h,m[0+v]=i+c,m[7+v]=i-c,m[1+v]=a+u,m[6+v]=a-u,m[2+v]=o+l,m[5+v]=o-l,m[3+v]=s+f,m[4+v]=s-f):(h=5793*m[0+v]+512>>10,m[0+v]=h,m[1+v]=h,m[2+v]=h,m[3+v]=h,m[4+v]=h,m[5+v]=h,m[6+v]=h,m[7+v]=h)}for(d=0;d<8;++d){var y=d;0!==m[8+y]||0!==m[16+y]||0!==m[24+y]||0!==m[32+y]||0!==m[40+y]||0!==m[48+y]||0!==m[56+y]?(i=5793*m[0+y]+2048>>12,a=5793*m[32+y]+2048>>12,o=m[16+y],s=m[48+y],f=2896*(m[8+y]-m[56+y])+2048>>12,c=2896*(m[8+y]+m[56+y])+2048>>12,l=m[24+y],h=i-a+1>>1,i=i+a+1>>1,a=h,h=3784*o+1567*s+2048>>12,o=1567*o-3784*s+2048>>12,s=h,h=f-(u=m[40+y])+1>>1,f=f+u+1>>1,u=h,h=c+l+1>>1,l=c-l+1>>1,c=h,h=i-s+1>>1,i=i+s+1>>1,s=h,h=a-o+1>>1,a=a+o+1>>1,o=h,h=2276*f+3406*c+2048>>12,f=3406*f-2276*c+2048>>12,c=h,h=799*l+4017*u+2048>>12,l=4017*l-799*u+2048>>12,u=h,m[0+y]=i+c,m[56+y]=i-c,m[8+y]=a+u,m[48+y]=a-u,m[16+y]=o+l,m[40+y]=o-l,m[24+y]=s+f,m[32+y]=s-f):(h=5793*n[d+0]+8192>>14,m[0+y]=h,m[8+y]=h,m[16+y]=h,m[24+y]=h,m[32+y]=h,m[40+y]=h,m[48+y]=h,m[56+y]=h)}for(d=0;d<64;++d){var w=128+(m[d]+8>>4);r[d]=w<0?0:w>255?255:w}}for(var l=0;l<i;l++){for(var u=l<<3,c=0;c<8;c++)r.push(new Uint8Array(a));for(var h=0;h<n;h++){f(t.blocks[l][h],s,o);for(var d=0,p=h<<3,m=0;m<8;m++)for(var v=r[u+m],y=0;y<8;y++)v[p+y]=s[d++]}}return r}var M=function(){function e(){u(this,e),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return h(e,[{key:"resetFrames",value:function(){this.frames=[]}},{key:"parse",value:function(e){var t=0;function r(){var r=e[t]<<8|e[t+1];return t+=2,r}function n(e){var t,r,n=0,i=0;for(r in e.components)e.components.hasOwnProperty(r)&&(n<(t=e.components[r]).h&&(n=t.h),i<t.v&&(i=t.v));var a=Math.ceil(e.samplesPerLine/8/n),o=Math.ceil(e.scanLines/8/i);for(r in e.components)if(e.components.hasOwnProperty(r)){t=e.components[r];for(var s=Math.ceil(Math.ceil(e.samplesPerLine/8)*t.h/n),f=Math.ceil(Math.ceil(e.scanLines/8)*t.v/i),l=a*t.h,u=o*t.v,c=[],h=0;h<u;h++){for(var d=[],p=0;p<l;p++)d.push(new Int32Array(64));c.push(d)}t.blocksPerLine=s,t.blocksPerColumn=f,t.blocks=c}e.maxH=n,e.maxV=i,e.mcusPerLine=a,e.mcusPerColumn=o}var i,a,o=r();if(65496!==o)throw new Error("SOI not found");for(o=r();65497!==o;){switch(o){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var s=(i=void 0,a=void 0,i=r(),a=e.subarray(t,t+i-2),t+=a.length,a);65504===o&&74===s[0]&&70===s[1]&&73===s[2]&&70===s[3]&&0===s[4]&&(this.jfif={version:{major:s[5],minor:s[6]},densityUnits:s[7],xDensity:s[8]<<8|s[9],yDensity:s[10]<<8|s[11],thumbWidth:s[12],thumbHeight:s[13],thumbData:s.subarray(14,14+3*s[12]*s[13])}),65518===o&&65===s[0]&&100===s[1]&&111===s[2]&&98===s[3]&&101===s[4]&&0===s[5]&&(this.adobe={version:s[6],flags0:s[7]<<8|s[8],flags1:s[9]<<8|s[10],transformCode:s[11]});break;case 65499:for(var f=r()+t-2;t<f;){var l=e[t++],u=new Int32Array(64);if(l>>4==0)for(var c=0;c<64;c++){u[D[c]]=e[t++]}else{if(l>>4!=1)throw new Error("DQT: invalid table spec");for(var h=0;h<64;h++){u[D[h]]=r()}}this.quantizationTables[15&l]=u}break;case 65472:case 65473:case 65474:r();for(var d={extended:65473===o,progressive:65474===o,precision:e[t++],scanLines:r(),samplesPerLine:r(),components:{},componentsOrder:[]},p=e[t++],m=void 0,v=0;v<p;v++){m=e[t];var y=e[t+1]>>4,w=15&e[t+1],g=e[t+2];d.componentsOrder.push(m),d.components[m]={h:y,v:w,quantizationIdx:g},t+=3}n(d),this.frames.push(d);break;case 65476:for(var b=r(),k=2;k<b;){for(var x=e[t++],_=new Uint8Array(16),A=0,P=0;P<16;P++,t++)_[P]=e[t],A+=_[P];for(var I=new Uint8Array(A),U=0;U<A;U++,t++)I[U]=e[t];k+=17+A,x>>4==0?this.huffmanTablesDC[15&x]=E(_,I):this.huffmanTablesAC[15&x]=E(_,I)}break;case 65501:r(),this.resetInterval=r();break;case 65498:r();for(var S=e[t++],T=[],O=this.frames[0],M=0;M<S;M++){var C=O.components[e[t++]],L=e[t++];C.huffmanTableDC=this.huffmanTablesDC[L>>4],C.huffmanTableAC=this.huffmanTablesAC[15&L],T.push(C)}var R=e[t++],V=e[t++],G=e[t++],F=B(e,t,O,T,this.resetInterval,R,V,G>>4,15&G);t+=F;break;case 65535:255!==e[t]&&t--;break;default:if(255===e[t-3]&&e[t-2]>=192&&e[t-2]<=254){t-=3;break}throw new Error("unknown JPEG marker ".concat(o.toString(16)))}o=r()}}},{key:"getResult",value:function(){var e=this.frames;if(0===this.frames.length)throw new Error("no frames were decoded");this.frames.length>1&&console.warn("more than one frame is not supported");for(var t=0;t<this.frames.length;t++)for(var r=this.frames[t].components,n=0,i=Object.keys(r);n<i.length;n++){var a=i[n];r[a].quantizationTable=this.quantizationTables[r[a].quantizationIdx],delete r[a].quantizationIdx}for(var o=e[0],s=o.components,f=o.componentsOrder,l=[],u=o.samplesPerLine,c=o.scanLines,h=0;h<f.length;h++){var d=s[f[h]];l.push({lines:O(0,d),scaleX:d.h/o.maxH,scaleY:d.v/o.maxV})}for(var p=new Uint8Array(u*c*l.length),m=0,v=0;v<c;++v)for(var y=0;y<u;++y)for(var w=0;w<l.length;++w){var g=l[w];p[m]=g.lines[0|v*g.scaleY][0|y*g.scaleX],++m}return p}}]),e}(),C=function(e){p(r,b);var t=T(r);function r(e){var n;return u(this,r),(n=t.call(this)).reader=new M,e.JPEGTables&&n.reader.parse(e.JPEGTables),n}return h(r,[{key:"decodeBlock",value:function(e){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(e)),this.reader.getResult().buffer}}]),r}(),L=Object.freeze({__proto__:null,default:C});function R(e){for(var t=e.length;--t>=0;)e[t]=0}R(new Array(576)),R(new Array(60)),R(new Array(512)),R(new Array(256)),R(new Array(29)),R(new Array(30));var V=function(e,t,r,n){for(var i=65535&e|0,a=e>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{a=a+(i=i+t[n++]|0)|0}while(--o);i%=65521,a%=65521}return i|a<<16|0},G=new Uint32Array(function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}()),F=function(e,t,r,n){var i=G,a=n+r;e^=-1;for(var o=n;o<a;o++)e=e>>>8^i[255&(e^t[o])];return-1^e},z={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},j={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},N=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},Z=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var n=t.shift();if(n){if("object"!==r(n))throw new TypeError(n+"must be non-object");for(var i in n)N(n,i)&&(e[i]=n[i])}}return e},K=function(e){for(var t=0,r=0,n=e.length;r<n;r++)t+=e[r].length;for(var i=new Uint8Array(t),a=0,o=0,s=e.length;a<s;a++){var f=e[a];i.set(f,o),o+=f.length}return i},H=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){H=!1}for(var Y=new Uint8Array(256),X=0;X<256;X++)Y[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;Y[254]=Y[254]=1;var W=function(e){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);var t,r,n,i,a,o=e.length,s=0;for(i=0;i<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<o&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),s+=r<128?1:r<2048?2:r<65536?3:4;for(t=new Uint8Array(s),a=0,i=0;a<s;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<o&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[a++]=r:r<2048?(t[a++]=192|r>>>6,t[a++]=128|63&r):r<65536?(t[a++]=224|r>>>12,t[a++]=128|r>>>6&63,t[a++]=128|63&r):(t[a++]=240|r>>>18,t[a++]=128|r>>>12&63,t[a++]=128|r>>>6&63,t[a++]=128|63&r);return t},q=function(e,t){var r,n,i=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));var a=new Array(2*i);for(n=0,r=0;r<i;){var o=e[r++];if(o<128)a[n++]=o;else{var s=Y[o];if(s>4)a[n++]=65533,r+=s-1;else{for(o&=2===s?31:3===s?15:7;s>1&&r<i;)o=o<<6|63&e[r++],s--;s>1?a[n++]=65533:o<65536?a[n++]=o:(o-=65536,a[n++]=55296|o>>10&1023,a[n++]=56320|1023&o)}}}return function(e,t){if(t<65534&&e.subarray&&H)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}(a,n)},J=function(e,t){(t=t||e.length)>e.length&&(t=e.length);for(var r=t-1;r>=0&&128==(192&e[r]);)r--;return r<0||0===r?t:r+Y[e[r]]>t?r:t};var Q=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},$=function(e,t){var r,n,i,a,o,s,f,l,u,c,h,d,p,m,v,y,w,g,b,k,x,_,A,P,I=e.state;r=e.next_in,A=e.input,n=r+(e.avail_in-5),i=e.next_out,P=e.output,a=i-(t-e.avail_out),o=i+(e.avail_out-257),s=I.dmax,f=I.wsize,l=I.whave,u=I.wnext,c=I.window,h=I.hold,d=I.bits,p=I.lencode,m=I.distcode,v=(1<<I.lenbits)-1,y=(1<<I.distbits)-1;e:do{d<15&&(h+=A[r++]<<d,d+=8,h+=A[r++]<<d,d+=8),w=p[h&v];t:for(;;){if(h>>>=g=w>>>24,d-=g,0===(g=w>>>16&255))P[i++]=65535&w;else{if(!(16&g)){if(0==(64&g)){w=p[(65535&w)+(h&(1<<g)-1)];continue t}if(32&g){I.mode=12;break e}e.msg="invalid literal/length code",I.mode=30;break e}b=65535&w,(g&=15)&&(d<g&&(h+=A[r++]<<d,d+=8),b+=h&(1<<g)-1,h>>>=g,d-=g),d<15&&(h+=A[r++]<<d,d+=8,h+=A[r++]<<d,d+=8),w=m[h&y];r:for(;;){if(h>>>=g=w>>>24,d-=g,!(16&(g=w>>>16&255))){if(0==(64&g)){w=m[(65535&w)+(h&(1<<g)-1)];continue r}e.msg="invalid distance code",I.mode=30;break e}if(k=65535&w,d<(g&=15)&&(h+=A[r++]<<d,(d+=8)<g&&(h+=A[r++]<<d,d+=8)),(k+=h&(1<<g)-1)>s){e.msg="invalid distance too far back",I.mode=30;break e}if(h>>>=g,d-=g,k>(g=i-a)){if((g=k-g)>l&&I.sane){e.msg="invalid distance too far back",I.mode=30;break e}if(x=0,_=c,0===u){if(x+=f-g,g<b){b-=g;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}}else if(u<g){if(x+=f+u-g,(g-=u)<b){b-=g;do{P[i++]=c[x++]}while(--g);if(x=0,u<b){b-=g=u;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}}}else if(x+=u-g,g<b){b-=g;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}for(;b>2;)P[i++]=_[x++],P[i++]=_[x++],P[i++]=_[x++],b-=3;b&&(P[i++]=_[x++],b>1&&(P[i++]=_[x++]))}else{x=i-k;do{P[i++]=P[x++],P[i++]=P[x++],P[i++]=P[x++],b-=3}while(b>2);b&&(P[i++]=P[x++],b>1&&(P[i++]=P[x++]))}break}}break}}while(r<n&&i<o);r-=b=d>>3,h&=(1<<(d-=b<<3))-1,e.next_in=r,e.next_out=i,e.avail_in=r<n?n-r+5:5-(r-n),e.avail_out=i<o?o-i+257:257-(i-o),I.hold=h,I.bits=d},ee=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),te=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),re=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ne=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),ie=function(e,t,r,n,i,a,o,s){var f,l,u,c,h,d,p,m,v,y=s.bits,w=0,g=0,b=0,k=0,x=0,_=0,A=0,P=0,I=0,U=0,S=null,T=0,D=new Uint16Array(16),E=new Uint16Array(16),B=null,O=0;for(w=0;w<=15;w++)D[w]=0;for(g=0;g<n;g++)D[t[r+g]]++;for(x=y,k=15;k>=1&&0===D[k];k--);if(x>k&&(x=k),0===k)return i[a++]=20971520,i[a++]=20971520,s.bits=1,0;for(b=1;b<k&&0===D[b];b++);for(x<b&&(x=b),P=1,w=1;w<=15;w++)if(P<<=1,(P-=D[w])<0)return-1;if(P>0&&(0===e||1!==k))return-1;for(E[1]=0,w=1;w<15;w++)E[w+1]=E[w]+D[w];for(g=0;g<n;g++)0!==t[r+g]&&(o[E[t[r+g]]++]=g);if(0===e?(S=B=o,d=19):1===e?(S=ee,T-=257,B=te,O-=257,d=256):(S=re,B=ne,d=-1),U=0,g=0,w=b,h=a,_=x,A=0,u=-1,c=(I=1<<x)-1,1===e&&I>852||2===e&&I>592)return 1;for(;;){p=w-A,o[g]<d?(m=0,v=o[g]):o[g]>d?(m=B[O+o[g]],v=S[T+o[g]]):(m=96,v=0),f=1<<w-A,b=l=1<<_;do{i[h+(U>>A)+(l-=f)]=p<<24|m<<16|v|0}while(0!==l);for(f=1<<w-1;U&f;)f>>=1;if(0!==f?(U&=f-1,U+=f):U=0,g++,0==--D[w]){if(w===k)break;w=t[r+o[g]]}if(w>x&&(U&c)!==u){for(0===A&&(A=x),h+=b,P=1<<(_=w-A);_+A<k&&!((P-=D[_+A])<=0);)_++,P<<=1;if(I+=1<<_,1===e&&I>852||2===e&&I>592)return 1;i[u=U&c]=x<<24|_<<16|h-a|0}}return 0!==U&&(i[h+U]=w-A<<24|64<<16|0),s.bits=x,0},ae=j.Z_FINISH,oe=j.Z_BLOCK,se=j.Z_TREES,fe=j.Z_OK,le=j.Z_STREAM_END,ue=j.Z_NEED_DICT,ce=j.Z_STREAM_ERROR,he=j.Z_DATA_ERROR,de=j.Z_MEM_ERROR,pe=j.Z_BUF_ERROR,me=j.Z_DEFLATED,ve=function(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)};function ye(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var we,ge,be=function(e){if(!e||!e.state)return ce;var t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=1,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,fe},ke=function(e){if(!e||!e.state)return ce;var t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,be(e)},xe=function(e,t){var r;if(!e||!e.state)return ce;var n=e.state;return t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?ce:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,ke(e))},_e=function(e,t){if(!e)return ce;var r=new ye;e.state=r,r.window=null;var n=xe(e,t);return n!==fe&&(e.state=null),n},Ae=!0,Pe=function(e){if(Ae){we=new Int32Array(512),ge=new Int32Array(32);for(var t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(ie(1,e.lens,0,288,we,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;ie(2,e.lens,0,32,ge,0,e.work,{bits:5}),Ae=!1}e.lencode=we,e.lenbits=9,e.distcode=ge,e.distbits=5},Ie=function(e,t,r,n){var i,a=e.state;return null===a.window&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Uint8Array(a.wsize)),n>=a.wsize?(a.window.set(t.subarray(r-a.wsize,r),0),a.wnext=0,a.whave=a.wsize):((i=a.wsize-a.wnext)>n&&(i=n),a.window.set(t.subarray(r-n,r-n+i),a.wnext),(n-=i)?(a.window.set(t.subarray(r-n,r),0),a.wnext=n,a.whave=a.wsize):(a.wnext+=i,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=i))),0},Ue={inflateReset:ke,inflateReset2:xe,inflateResetKeep:be,inflateInit:function(e){return _e(e,15)},inflateInit2:_e,inflate:function(e,t){var r,n,i,a,o,s,f,l,u,c,h,d,p,m,v,y,w,g,b,k,x,_,A,P,I=0,U=new Uint8Array(4),S=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return ce;12===(r=e.state).mode&&(r.mode=13),o=e.next_out,i=e.output,f=e.avail_out,a=e.next_in,n=e.input,s=e.avail_in,l=r.hold,u=r.bits,c=s,h=f,_=fe;e:for(;;)switch(r.mode){case 1:if(0===r.wrap){r.mode=13;break}for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(2&r.wrap&&35615===l){r.check=0,U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0),l=0,u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&l)<<8)+(l>>8))%31){e.msg="incorrect header check",r.mode=30;break}if((15&l)!==me){e.msg="unknown compression method",r.mode=30;break}if(u-=4,x=8+(15&(l>>>=4)),0===r.wbits)r.wbits=x;else if(x>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<r.wbits,e.adler=r.check=1,r.mode=512&l?10:12,l=0,u=0;break;case 2:for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(r.flags=l,(255&r.flags)!==me){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=l>>8&1),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0,r.mode=3;case 3:for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.head&&(r.head.time=l),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,U[2]=l>>>16&255,U[3]=l>>>24&255,r.check=F(r.check,U,4,0)),l=0,u=0,r.mode=4;case 4:for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.head&&(r.head.xflags=255&l,r.head.os=l>>8),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0,r.mode=5;case 5:if(1024&r.flags){for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.length=l,r.head&&(r.head.extra_len=l),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&((d=r.length)>s&&(d=s),d&&(r.head&&(x=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Uint8Array(r.head.extra_len)),r.head.extra.set(n.subarray(a,a+d),x)),512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===s)break e;d=0;do{x=n[a+d++],r.head&&x&&r.length<65536&&(r.head.name+=String.fromCharCode(x))}while(x&&d<s);if(512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,x)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===s)break e;d=0;do{x=n[a+d++],r.head&&x&&r.length<65536&&(r.head.comment+=String.fromCharCode(x))}while(x&&d<s);if(512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,x)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}l=0,u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}e.adler=r.check=ve(l),l=0,u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,ue;e.adler=r.check=1,r.mode=12;case 12:if(t===oe||t===se)break e;case 13:if(r.last){l>>>=7&u,u-=7&u,r.mode=27;break}for(;u<3;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}switch(r.last=1&l,u-=1,3&(l>>>=1)){case 0:r.mode=14;break;case 1:if(Pe(r),r.mode=20,t===se){l>>>=2,u-=2;break e}break;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30}l>>>=2,u-=2;break;case 14:for(l>>>=7&u,u-=7&u;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if((65535&l)!=(l>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&l,l=0,u=0,r.mode=15,t===se)break e;case 15:r.mode=16;case 16:if(d=r.length){if(d>s&&(d=s),d>f&&(d=f),0===d)break e;i.set(n.subarray(a,a+d),o),s-=d,a+=d,f-=d,o+=d,r.length-=d;break}r.mode=12;break;case 17:for(;u<14;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(r.nlen=257+(31&l),l>>>=5,u-=5,r.ndist=1+(31&l),l>>>=5,u-=5,r.ncode=4+(15&l),l>>>=4,u-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;u<3;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.lens[S[r.have++]]=7&l,l>>>=3,u-=3}for(;r.have<19;)r.lens[S[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,A={bits:r.lenbits},_=ie(0,r.lens,0,19,r.lencode,0,r.work,A),r.lenbits=A.bits,_){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;y=(I=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(w<16)l>>>=v,u-=v,r.lens[r.have++]=w;else{if(16===w){for(P=v+2;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l>>>=v,u-=v,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}x=r.lens[r.have-1],d=3+(3&l),l>>>=2,u-=2}else if(17===w){for(P=v+3;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}u-=v,x=0,d=3+(7&(l>>>=v)),l>>>=3,u-=3}else{for(P=v+7;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}u-=v,x=0,d=11+(127&(l>>>=v)),l>>>=7,u-=7}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;d--;)r.lens[r.have++]=x}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,A={bits:r.lenbits},_=ie(1,r.lens,0,r.nlen,r.lencode,0,r.work,A),r.lenbits=A.bits,_){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,A={bits:r.distbits},_=ie(2,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,A),r.distbits=A.bits,_){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,t===se)break e;case 20:r.mode=21;case 21:if(s>=6&&f>=258){e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,$(e,h),o=e.next_out,i=e.output,f=e.avail_out,a=e.next_in,n=e.input,s=e.avail_in,l=r.hold,u=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;y=(I=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(y&&0==(240&y)){for(g=v,b=y,k=w;y=(I=r.lencode[k+((l&(1<<g+b)-1)>>g)])>>>16&255,w=65535&I,!(g+(v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}l>>>=g,u-=g,r.back+=g}if(l>>>=v,u-=v,r.back+=v,r.length=w,0===y){r.mode=26;break}if(32&y){r.back=-1,r.mode=12;break}if(64&y){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&y,r.mode=22;case 22:if(r.extra){for(P=r.extra;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.length+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;y=(I=r.distcode[l&(1<<r.distbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(0==(240&y)){for(g=v,b=y,k=w;y=(I=r.distcode[k+((l&(1<<g+b)-1)>>g)])>>>16&255,w=65535&I,!(g+(v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}l>>>=g,u-=g,r.back+=g}if(l>>>=v,u-=v,r.back+=v,64&y){e.msg="invalid distance code",r.mode=30;break}r.offset=w,r.extra=15&y,r.mode=24;case 24:if(r.extra){for(P=r.extra;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.offset+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===f)break e;if(d=h-f,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}d>r.wnext?(d-=r.wnext,p=r.wsize-d):p=r.wnext-d,d>r.length&&(d=r.length),m=r.window}else m=i,p=o-r.offset,d=r.length;d>f&&(d=f),f-=d,r.length-=d;do{i[o++]=m[p++]}while(--d);0===r.length&&(r.mode=21);break;case 26:if(0===f)break e;i[o++]=r.length,f--,r.mode=21;break;case 27:if(r.wrap){for(;u<32;){if(0===s)break e;s--,l|=n[a++]<<u,u+=8}if(h-=f,e.total_out+=h,r.total+=h,h&&(e.adler=r.check=r.flags?F(r.check,i,h,o-h):V(r.check,i,h,o-h)),h=f,(r.flags?l:ve(l))!==r.check){e.msg="incorrect data check",r.mode=30;break}l=0,u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}l=0,u=0}r.mode=29;case 29:_=le;break e;case 30:_=he;break e;case 31:return de;default:return ce}return e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,(r.wsize||h!==e.avail_out&&r.mode<30&&(r.mode<27||t!==ae))&&Ie(e,e.output,e.next_out,h-e.avail_out),c-=e.avail_in,h-=e.avail_out,e.total_in+=c,e.total_out+=h,r.total+=h,r.wrap&&h&&(e.adler=r.check=r.flags?F(r.check,i,h,e.next_out-h):V(r.check,i,h,e.next_out-h)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0===c&&0===h||t===ae)&&_===fe&&(_=pe),_},inflateEnd:function(e){if(!e||!e.state)return ce;var t=e.state;return t.window&&(t.window=null),e.state=null,fe},inflateGetHeader:function(e,t){if(!e||!e.state)return ce;var r=e.state;return 0==(2&r.wrap)?ce:(r.head=t,t.done=!1,fe)},inflateSetDictionary:function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?ce:11===r.mode&&V(1,t,n,0)!==r.check?he:Ie(e,t,n,n)?(r.mode=31,de):(r.havedict=1,fe):ce},inflateInfo:"pako inflate (from Nodeca project)"};var Se=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},Te=Object.prototype.toString,De=j.Z_NO_FLUSH,Ee=j.Z_FINISH,Be=j.Z_OK,Oe=j.Z_STREAM_END,Me=j.Z_NEED_DICT,Ce=j.Z_STREAM_ERROR,Le=j.Z_DATA_ERROR,Re=j.Z_MEM_ERROR;function Ve(e){this.options=Z({chunkSize:65536,windowBits:15,to:""},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Q,this.strm.avail_out=0;var r=Ue.inflateInit2(this.strm,t.windowBits);if(r!==Be)throw new Error(z[r]);if(this.header=new Se,Ue.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=W(t.dictionary):"[object ArrayBuffer]"===Te.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=Ue.inflateSetDictionary(this.strm,t.dictionary))!==Be))throw new Error(z[r])}function Ge(e,t){var r=new Ve(t);if(r.push(e),r.err)throw r.msg||z[r.err];return r.result}Ve.prototype.push=function(e,t){var r,n,i,a=this.strm,o=this.options.chunkSize,s=this.options.dictionary;if(this.ended)return!1;for(n=t===~~t?t:!0===t?Ee:De,"[object ArrayBuffer]"===Te.call(e)?a.input=new Uint8Array(e):a.input=e,a.next_in=0,a.avail_in=a.input.length;;){for(0===a.avail_out&&(a.output=new Uint8Array(o),a.next_out=0,a.avail_out=o),(r=Ue.inflate(a,n))===Me&&s&&((r=Ue.inflateSetDictionary(a,s))===Be?r=Ue.inflate(a,n):r===Le&&(r=Me));a.avail_in>0&&r===Oe&&a.state.wrap>0&&0!==e[a.next_in];)Ue.inflateReset(a),r=Ue.inflate(a,n);switch(r){case Ce:case Le:case Me:case Re:return this.onEnd(r),this.ended=!0,!1}if(i=a.avail_out,a.next_out&&(0===a.avail_out||r===Oe))if("string"===this.options.to){var f=J(a.output,a.next_out),l=a.next_out-f,u=q(a.output,f);a.next_out=l,a.avail_out=o-l,l&&a.output.set(a.output.subarray(f,f+l),0),this.onData(u)}else this.onData(a.output.length===a.next_out?a.output:a.output.subarray(0,a.next_out));if(r!==Be||0!==i){if(r===Oe)return r=Ue.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===a.avail_in)break}}return!0},Ve.prototype.onData=function(e){this.chunks.push(e)},Ve.prototype.onEnd=function(e){e===Be&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=K(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Fe={Inflate:Ve,inflate:Ge,inflateRaw:function(e,t){return(t=t||{}).raw=!0,Ge(e,t)},ungzip:Ge,constants:j}.inflate;function ze(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var je=function(e){p(r,b);var t=ze(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return Fe(new Uint8Array(e)).buffer}}]),r}(),Ne=Object.freeze({__proto__:null,default:je});function Ze(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var Ke,He=function(e){p(r,b);var t=Ze(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){for(var t=new DataView(e),r=[],n=0;n<e.byteLength;++n){var i=t.getInt8(n);if(i<0){var a=t.getUint8(n+1);i=-i;for(var o=0;o<=i;++o)r.push(a);n+=1}else{for(var s=0;s<=i;++s)r.push(t.getUint8(n+s+1));n+=i+1}}return new Uint8Array(r).buffer}}]),r}(),Ye=Object.freeze({__proto__:null,default:He}),Xe={exports:{}};Ke=Xe,\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\nfunction(){var e,t,r,n,i,a,o,s,f,l,u,c,h,d,p,m,v=(e={defaultNoDataValue:-34027999387901484e22,decode:function(a,o){var s=(o=o||{}).encodedMaskData||null===o.encodedMaskData,f=i(a,o.inputOffset||0,s),l=null!==o.noDataValue?o.noDataValue:e.defaultNoDataValue,u=t(f,o.pixelType||Float32Array,o.encodedMaskData,l,o.returnMask),c={width:f.width,height:f.height,pixelData:u.resultPixels,minValue:u.minValue,maxValue:f.pixels.maxValue,noDataValue:l};return u.resultMask&&(c.maskData=u.resultMask),o.returnEncodedMask&&f.mask&&(c.encodedMaskData=f.mask.bitset?f.mask.bitset:null),o.returnFileInfo&&(c.fileInfo=r(f),o.computeUsedBitDepths&&(c.fileInfo.bitDepths=n(f))),c}},t=function(e,t,r,n,i){var o,s,f,l=0,u=e.pixels.numBlocksX,c=e.pixels.numBlocksY,h=Math.floor(e.width/u),d=Math.floor(e.height/c),p=2*e.maxZError,m=Number.MAX_VALUE;r=r||(e.mask?e.mask.bitset:null),s=new t(e.width*e.height),i&&r&&(f=new Uint8Array(e.width*e.height));for(var v,y,w=new Float32Array(h*d),g=0;g<=c;g++){var b=g!==c?d:e.height%c;if(0!==b)for(var k=0;k<=u;k++){var x=k!==u?h:e.width%u;if(0!==x){var _,A,P,I,U=g*e.width*d+k*h,S=e.width-x,T=e.pixels.blocks[l];if(T.encoding<2?(0===T.encoding?_=T.rawData:(a(T.stuffedData,T.bitsPerPixel,T.numValidPixels,T.offset,p,w,e.pixels.maxValue),_=w),A=0):P=2===T.encoding?0:T.offset,r)for(y=0;y<b;y++){for(7&U&&(I=r[U>>3],I<<=7&U),v=0;v<x;v++)7&U||(I=r[U>>3]),128&I?(f&&(f[U]=1),m=m>(o=T.encoding<2?_[A++]:P)?o:m,s[U++]=o):(f&&(f[U]=0),s[U++]=n),I<<=1;U+=S}else if(T.encoding<2)for(y=0;y<b;y++){for(v=0;v<x;v++)m=m>(o=_[A++])?o:m,s[U++]=o;U+=S}else for(m=m>P?P:m,y=0;y<b;y++){for(v=0;v<x;v++)s[U++]=P;U+=S}if(1===T.encoding&&A!==T.numValidPixels)throw"Block and Mask do not match";l++}}}return{resultPixels:s,resultMask:f,minValue:m}},r=function(e){return{fileIdentifierString:e.fileIdentifierString,fileVersion:e.fileVersion,imageType:e.imageType,height:e.height,width:e.width,maxZError:e.maxZError,eofOffset:e.eofOffset,mask:e.mask?{numBlocksX:e.mask.numBlocksX,numBlocksY:e.mask.numBlocksY,numBytes:e.mask.numBytes,maxValue:e.mask.maxValue}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,numBytes:e.pixels.numBytes,maxValue:e.pixels.maxValue,noDataValue:e.noDataValue}}},n=function(e){for(var t=e.pixels.numBlocksX*e.pixels.numBlocksY,r={},n=0;n<t;n++){var i=e.pixels.blocks[n];0===i.encoding?r.float32=!0:1===i.encoding?r[i.bitsPerPixel]=!0:r[0]=!0}return Object.keys(r)},i=function(e,t,r){var n={},i=new Uint8Array(e,t,10);if(n.fileIdentifierString=String.fromCharCode.apply(null,i),"CntZImage"!==n.fileIdentifierString.trim())throw"Unexpected file identifier string: "+n.fileIdentifierString;t+=10;var a=new DataView(e,t,24);if(n.fileVersion=a.getInt32(0,!0),n.imageType=a.getInt32(4,!0),n.height=a.getUint32(8,!0),n.width=a.getUint32(12,!0),n.maxZError=a.getFloat64(16,!0),t+=24,!r)if(a=new DataView(e,t,16),n.mask={},n.mask.numBlocksY=a.getUint32(0,!0),n.mask.numBlocksX=a.getUint32(4,!0),n.mask.numBytes=a.getUint32(8,!0),n.mask.maxValue=a.getFloat32(12,!0),t+=16,n.mask.numBytes>0){var o=new Uint8Array(Math.ceil(n.width*n.height/8)),s=(a=new DataView(e,t,n.mask.numBytes)).getInt16(0,!0),f=2,l=0;do{if(s>0)for(;s--;)o[l++]=a.getUint8(f++);else{var u=a.getUint8(f++);for(s=-s;s--;)o[l++]=u}s=a.getInt16(f,!0),f+=2}while(f<n.mask.numBytes);if(-32768!==s||l<o.length)throw"Unexpected end of mask RLE encoding";n.mask.bitset=o,t+=n.mask.numBytes}else 0==(n.mask.numBytes|n.mask.numBlocksY|n.mask.maxValue)&&(n.mask.bitset=new Uint8Array(Math.ceil(n.width*n.height/8)));a=new DataView(e,t,16),n.pixels={},n.pixels.numBlocksY=a.getUint32(0,!0),n.pixels.numBlocksX=a.getUint32(4,!0),n.pixels.numBytes=a.getUint32(8,!0),n.pixels.maxValue=a.getFloat32(12,!0),t+=16;var c=n.pixels.numBlocksX,h=n.pixels.numBlocksY,d=c+(n.width%c>0?1:0),p=h+(n.height%h>0?1:0);n.pixels.blocks=new Array(d*p);for(var m=0,v=0;v<p;v++)for(var y=0;y<d;y++){var w=0,g=e.byteLength-t;a=new DataView(e,t,Math.min(10,g));var b={};n.pixels.blocks[m++]=b;var k=a.getUint8(0);if(w++,b.encoding=63&k,b.encoding>3)throw"Invalid block encoding ("+b.encoding+")";if(2!==b.encoding){if(0!==k&&2!==k){if(k>>=6,b.offsetType=k,2===k)b.offset=a.getInt8(1),w++;else if(1===k)b.offset=a.getInt16(1,!0),w+=2;else{if(0!==k)throw"Invalid block offset type";b.offset=a.getFloat32(1,!0),w+=4}if(1===b.encoding)if(k=a.getUint8(w),w++,b.bitsPerPixel=63&k,k>>=6,b.numValidPixelsType=k,2===k)b.numValidPixels=a.getUint8(w),w++;else if(1===k)b.numValidPixels=a.getUint16(w,!0),w+=2;else{if(0!==k)throw"Invalid valid pixel count type";b.numValidPixels=a.getUint32(w,!0),w+=4}}var x;if(t+=w,3!==b.encoding)if(0===b.encoding){var _=(n.pixels.numBytes-1)/4;if(_!==Math.floor(_))throw"uncompressed block has invalid length";x=new ArrayBuffer(4*_),new Uint8Array(x).set(new Uint8Array(e,t,4*_));var A=new Float32Array(x);b.rawData=A,t+=4*_}else if(1===b.encoding){var P=Math.ceil(b.numValidPixels*b.bitsPerPixel/8),I=Math.ceil(P/4);x=new ArrayBuffer(4*I),new Uint8Array(x).set(new Uint8Array(e,t,P)),b.stuffedData=new Uint32Array(x),t+=P}}else t++}return n.eofOffset=t,n},a=function(e,t,r,n,i,a,o){var s,f,l,u=(1<<t)-1,c=0,h=0,d=Math.ceil((o-n)/i),p=4*e.length-Math.ceil(t*r/8);for(e[e.length-1]<<=8*p,s=0;s<r;s++){if(0===h&&(l=e[c++],h=32),h>=t)f=l>>>h-t&u,h-=t;else{var m=t-h;f=(l&u)<<m&u,f+=(l=e[c++])>>>(h=32-m)}a[s]=f<d?n+f*i:o}return a},e),y=(o=function(e,t,r,n,i,a,o,s){var f,l,u,c,h,d=(1<<r)-1,p=0,m=0,v=4*e.length-Math.ceil(r*n/8);if(e[e.length-1]<<=8*v,i)for(f=0;f<n;f++)0===m&&(u=e[p++],m=32),m>=r?(l=u>>>m-r&d,m-=r):(l=(u&d)<<(c=r-m)&d,l+=(u=e[p++])>>>(m=32-c)),t[f]=i[l];else for(h=Math.ceil((s-a)/o),f=0;f<n;f++)0===m&&(u=e[p++],m=32),m>=r?(l=u>>>m-r&d,m-=r):(l=(u&d)<<(c=r-m)&d,l+=(u=e[p++])>>>(m=32-c)),t[f]=l<h?a+l*o:s},s=function(e,t,r,n,i,a){var o,s=(1<<t)-1,f=0,l=0,u=0,c=0,h=0,d=[],p=4*e.length-Math.ceil(t*r/8);e[e.length-1]<<=8*p;var m=Math.ceil((a-n)/i);for(l=0;l<r;l++)0===c&&(o=e[f++],c=32),c>=t?(h=o>>>c-t&s,c-=t):(h=(o&s)<<(u=t-c)&s,h+=(o=e[f++])>>>(c=32-u)),d[l]=h<m?n+h*i:a;return d.unshift(n),d},f=function(e,t,r,n,i,a,o,s){var f,l,u,c,h=(1<<r)-1,d=0,p=0,m=0;if(i)for(f=0;f<n;f++)0===p&&(u=e[d++],p=32,m=0),p>=r?(l=u>>>m&h,p-=r,m+=r):(l=u>>>m&h,p=32-(c=r-p),l|=((u=e[d++])&(1<<c)-1)<<r-c,m=c),t[f]=i[l];else{var v=Math.ceil((s-a)/o);for(f=0;f<n;f++)0===p&&(u=e[d++],p=32,m=0),p>=r?(l=u>>>m&h,p-=r,m+=r):(l=u>>>m&h,p=32-(c=r-p),l|=((u=e[d++])&(1<<c)-1)<<r-c,m=c),t[f]=l<v?a+l*o:s}return t},l=function(e,t,r,n,i,a){var o,s=(1<<t)-1,f=0,l=0,u=0,c=0,h=0,d=0,p=[],m=Math.ceil((a-n)/i);for(l=0;l<r;l++)0===c&&(o=e[f++],c=32,d=0),c>=t?(h=o>>>d&s,c-=t,d+=t):(h=o>>>d&s,c=32-(u=t-c),h|=((o=e[f++])&(1<<u)-1)<<t-u,d=u),p[l]=h<m?n+h*i:a;return p.unshift(n),p},u=function(e,t,r,n){var i,a,o,s,f=(1<<r)-1,l=0,u=0,c=4*e.length-Math.ceil(r*n/8);for(e[e.length-1]<<=8*c,i=0;i<n;i++)0===u&&(o=e[l++],u=32),u>=r?(a=o>>>u-r&f,u-=r):(a=(o&f)<<(s=r-u)&f,a+=(o=e[l++])>>>(u=32-s)),t[i]=a;return t},c=function(e,t,r,n){var i,a,o,s,f=(1<<r)-1,l=0,u=0,c=0;for(i=0;i<n;i++)0===u&&(o=e[l++],u=32,c=0),u>=r?(a=o>>>c&f,u-=r,c+=r):(a=o>>>c&f,u=32-(s=r-u),a|=((o=e[l++])&(1<<s)-1)<<r-s,c=s),t[i]=a;return t},h={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(e){for(var t=65535,r=65535,n=e.length,i=Math.floor(n/2),a=0;i;){var o=i>=359?359:i;i-=o;do{t+=e[a++]<<8,r+=t+=e[a++]}while(--o);t=(65535&t)+(t>>>16),r=(65535&r)+(r>>>16)}return 1&n&&(r+=t+=e[a]<<8),((r=(65535&r)+(r>>>16))<<16|(t=(65535&t)+(t>>>16)))>>>0},readHeaderInfo:function(e,t){var r=t.ptr,n=new Uint8Array(e,r,6),i={};if(i.fileIdentifierString=String.fromCharCode.apply(null,n),0!==i.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+i.fileIdentifierString;r+=6;var a,o=new DataView(e,r,8),s=o.getInt32(0,!0);if(i.fileVersion=s,r+=4,s>=3&&(i.checksum=o.getUint32(4,!0),r+=4),o=new DataView(e,r,12),i.height=o.getUint32(0,!0),i.width=o.getUint32(4,!0),r+=8,s>=4?(i.numDims=o.getUint32(8,!0),r+=4):i.numDims=1,o=new DataView(e,r,40),i.numValidPixel=o.getUint32(0,!0),i.microBlockSize=o.getInt32(4,!0),i.blobSize=o.getInt32(8,!0),i.imageType=o.getInt32(12,!0),i.maxZError=o.getFloat64(16,!0),i.zMin=o.getFloat64(24,!0),i.zMax=o.getFloat64(32,!0),r+=40,t.headerInfo=i,t.ptr=r,s>=3&&(a=s>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(e,r-a,i.blobSize-14))!==i.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(e,t){var r=t.headerInfo,n=this.getDataTypeArray(r.imageType),i=r.numDims*this.getDataTypeSize(r.imageType),a=this.readSubArray(e,t.ptr,n,i),o=this.readSubArray(e,t.ptr+i,n,i);t.ptr+=2*i;var s,f=!0;for(s=0;s<r.numDims;s++)if(a[s]!==o[s]){f=!1;break}return r.minValues=a,r.maxValues=o,f},readSubArray:function(e,t,r,n){var i;if(r===Uint8Array)i=new Uint8Array(e,t,n);else{var a=new ArrayBuffer(n);new Uint8Array(a).set(new Uint8Array(e,t,n)),i=new r(a)}return i},readMask:function(e,t){var r,n,i=t.ptr,a=t.headerInfo,o=a.width*a.height,s=a.numValidPixel,f=new DataView(e,i,4),l={};if(l.numBytes=f.getUint32(0,!0),i+=4,(0===s||o===s)&&0!==l.numBytes)throw"invalid mask";if(0===s)r=new Uint8Array(Math.ceil(o/8)),l.bitset=r,n=new Uint8Array(o),t.pixels.resultMask=n,i+=l.numBytes;else if(l.numBytes>0){r=new Uint8Array(Math.ceil(o/8));var u=(f=new DataView(e,i,l.numBytes)).getInt16(0,!0),c=2,h=0,d=0;do{if(u>0)for(;u--;)r[h++]=f.getUint8(c++);else for(d=f.getUint8(c++),u=-u;u--;)r[h++]=d;u=f.getInt16(c,!0),c+=2}while(c<l.numBytes);if(-32768!==u||h<r.length)throw"Unexpected end of mask RLE encoding";n=new Uint8Array(o);var p=0,m=0;for(m=0;m<o;m++)7&m?(p=r[m>>3],p<<=7&m):p=r[m>>3],128&p&&(n[m]=1);t.pixels.resultMask=n,l.bitset=r,i+=l.numBytes}return t.ptr=i,t.mask=l,!0},readDataOneSweep:function(e,t,r,n){var i,a=t.ptr,o=t.headerInfo,s=o.numDims,f=o.width*o.height,l=o.imageType,u=o.numValidPixel*h.getDataTypeSize(l)*s,c=t.pixels.resultMask;if(r===Uint8Array)i=new Uint8Array(e,a,u);else{var d=new ArrayBuffer(u);new Uint8Array(d).set(new Uint8Array(e,a,u)),i=new r(d)}if(i.length===f*s)t.pixels.resultPixels=n?h.swapDimensionOrder(i,f,s,r,!0):i;else{t.pixels.resultPixels=new r(f*s);var p=0,m=0,v=0,y=0;if(s>1){if(n){for(m=0;m<f;m++)if(c[m])for(y=m,v=0;v<s;v++,y+=f)t.pixels.resultPixels[y]=i[p++]}else for(m=0;m<f;m++)if(c[m])for(y=m*s,v=0;v<s;v++)t.pixels.resultPixels[y+v]=i[p++]}else for(m=0;m<f;m++)c[m]&&(t.pixels.resultPixels[m]=i[p++])}return a+=u,t.ptr=a,!0},readHuffmanTree:function(e,t){var r=this.HUFFMAN_LUT_BITS_MAX,n=new DataView(e,t.ptr,16);if(t.ptr+=16,n.getInt32(0,!0)<2)throw"unsupported Huffman version";var i=n.getInt32(4,!0),a=n.getInt32(8,!0),o=n.getInt32(12,!0);if(a>=o)return!1;var s=new Uint32Array(o-a);h.decodeBits(e,t,s);var f,l,u,c,p=[];for(f=a;f<o;f++)p[l=f-(f<i?0:i)]={first:s[f-a],second:null};var m=e.byteLength-t.ptr,v=Math.ceil(m/4),y=new ArrayBuffer(4*v);new Uint8Array(y).set(new Uint8Array(e,t.ptr,m));var w,g=new Uint32Array(y),b=0,k=0;for(w=g[0],f=a;f<o;f++)(c=p[l=f-(f<i?0:i)].first)>0&&(p[l].second=w<<b>>>32-c,32-b>=c?32===(b+=c)&&(b=0,w=g[++k]):(b+=c-32,w=g[++k],p[l].second|=w>>>32-b));var x=0,_=0,A=new d;for(f=0;f<p.length;f++)void 0!==p[f]&&(x=Math.max(x,p[f].first));_=x>=r?r:x;var P,I,U,S,T,D=[];for(f=a;f<o;f++)if((c=p[l=f-(f<i?0:i)].first)>0)if(P=[c,l],c<=_)for(I=p[l].second<<_-c,U=1<<_-c,u=0;u<U;u++)D[I|u]=P;else for(I=p[l].second,T=A,S=c-1;S>=0;S--)I>>>S&1?(T.right||(T.right=new d),T=T.right):(T.left||(T.left=new d),T=T.left),0!==S||T.val||(T.val=P[1]);return{decodeLut:D,numBitsLUTQick:_,numBitsLUT:x,tree:A,stuffedData:g,srcPtr:k,bitPos:b}},readHuffman:function(e,t,r,n){var i,a,o,s,f,l,u,c,d,p=t.headerInfo.numDims,m=t.headerInfo.height,v=t.headerInfo.width,y=v*m,w=this.readHuffmanTree(e,t),g=w.decodeLut,b=w.tree,k=w.stuffedData,x=w.srcPtr,_=w.bitPos,A=w.numBitsLUTQick,P=w.numBitsLUT,I=0===t.headerInfo.imageType?128:0,U=t.pixels.resultMask,S=0;_>0&&(x++,_=0);var T,D=k[x],E=1===t.encodeMode,B=new r(y*p),O=B;if(p<2||E){for(T=0;T<p;T++)if(p>1&&(O=new r(B.buffer,y*T,y),S=0),t.headerInfo.numValidPixel===v*m)for(c=0,l=0;l<m;l++)for(u=0;u<v;u++,c++){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,E?(o+=u>0?S:l>0?O[c-v]:S,o&=255,O[c]=o,S=o):O[c]=o}else for(c=0,l=0;l<m;l++)for(u=0;u<v;u++,c++)if(U[c]){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,E?(u>0&&U[c-1]?o+=S:l>0&&U[c-v]?o+=O[c-v]:o+=S,o&=255,O[c]=o,S=o):O[c]=o}}else for(c=0,l=0;l<m;l++)for(u=0;u<v;u++)if(c=l*v+u,!U||U[c])for(T=0;T<p;T++,c+=y){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,O[c]=o}t.ptr=t.ptr+4*(x+1)+(_>0?4:0),t.pixels.resultPixels=B,p>1&&!n&&(t.pixels.resultPixels=h.swapDimensionOrder(B,y,p,r))},decodeBits:function(e,t,r,n,i){var a=t.headerInfo,h=a.fileVersion,d=0,p=e.byteLength-t.ptr>=5?5:e.byteLength-t.ptr,m=new DataView(e,t.ptr,p),v=m.getUint8(0);d++;var y=v>>6,w=0===y?4:3-y,g=(32&v)>0,b=31&v,k=0;if(1===w)k=m.getUint8(d),d++;else if(2===w)k=m.getUint16(d,!0),d+=2;else{if(4!==w)throw"Invalid valid pixel count type";k=m.getUint32(d,!0),d+=4}var x,_,A,P,I,U,S,T,D,E=2*a.maxZError,B=a.numDims>1?a.maxValues[i]:a.zMax;if(g){for(t.counter.lut++,T=m.getUint8(d),d++,P=Math.ceil((T-1)*b/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),A=new Uint8Array(_),t.ptr+=d,A.set(new Uint8Array(e,t.ptr,P)),S=new Uint32Array(_),t.ptr+=P,D=0;T-1>>>D;)D++;P=Math.ceil(k*D/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),(A=new Uint8Array(_)).set(new Uint8Array(e,t.ptr,P)),x=new Uint32Array(_),t.ptr+=P,U=h>=3?l(S,b,T-1,n,E,B):s(S,b,T-1,n,E,B),h>=3?f(x,r,D,k,U):o(x,r,D,k,U)}else t.counter.bitstuffer++,D=b,t.ptr+=d,D>0&&(P=Math.ceil(k*D/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),(A=new Uint8Array(_)).set(new Uint8Array(e,t.ptr,P)),x=new Uint32Array(_),t.ptr+=P,h>=3?null==n?c(x,r,D,k):f(x,r,D,k,!1,n,E,B):null==n?u(x,r,D,k):o(x,r,D,k,!1,n,E,B))},readTiles:function(e,t,r,n){var i=t.headerInfo,a=i.width,o=i.height,s=a*o,f=i.microBlockSize,l=i.imageType,u=h.getDataTypeSize(l),c=Math.ceil(a/f),d=Math.ceil(o/f);t.pixels.numBlocksY=d,t.pixels.numBlocksX=c,t.pixels.ptr=0;var p,m,v,y,w,g,b,k,x,_,A=0,P=0,I=0,U=0,S=0,T=0,D=0,E=0,B=0,O=0,M=0,C=0,L=0,R=0,V=0,G=new r(f*f),F=o%f||f,z=a%f||f,j=i.numDims,N=t.pixels.resultMask,Z=t.pixels.resultPixels,K=i.fileVersion>=5?14:15,H=i.zMax;for(I=0;I<d;I++)for(S=I!==d-1?f:F,U=0;U<c;U++)for(O=I*a*f+U*f,M=a-(T=U!==c-1?f:z),k=0;k<j;k++){if(j>1?(_=Z,O=I*a*f+U*f,Z=new r(t.pixels.resultPixels.buffer,s*k*u,s),H=i.maxValues[k]):_=null,D=e.byteLength-t.ptr,m={},V=0,E=(p=new DataView(e,t.ptr,Math.min(10,D))).getUint8(0),V++,x=i.fileVersion>=5?4&E:0,B=E>>6&255,(E>>2&K)!=(U*f>>3&K))throw"integrity issue";if(x&&0===k)throw"integrity issue";if((w=3&E)>3)throw t.ptr+=V,"Invalid block encoding ("+w+")";if(2!==w)if(0===w){if(x)throw"integrity issue";if(t.counter.uncompressed++,t.ptr+=V,C=(C=S*T*u)<(L=e.byteLength-t.ptr)?C:L,v=new ArrayBuffer(C%u==0?C:C+u-C%u),new Uint8Array(v).set(new Uint8Array(e,t.ptr,C)),y=new r(v),R=0,N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=y[R++]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O++]=y[R++];O+=M}t.ptr+=R*u}else if(g=h.getDataTypeUsed(x&&l<6?4:l,B),b=h.getOnePixel(m,V,g,p),V+=h.getDataTypeSize(g),3===w)if(t.ptr+=V,t.counter.constantoffset++,N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=x?Math.min(H,_[O]+b):b),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O]=x?Math.min(H,_[O]+b):b,O++;O+=M}else if(t.ptr+=V,h.decodeBits(e,t,G,b,k),V=0,x)if(N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=G[V++]+_[O]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O]=G[V++]+_[O],O++;O+=M}else if(N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=G[V++]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O++]=G[V++];O+=M}else{if(x)if(N)for(A=0;A<S;A++)for(P=0;P<T;P++)N[O]&&(Z[O]=_[O]),O++;else for(A=0;A<S;A++)for(P=0;P<T;P++)Z[O]=_[O],O++;t.counter.constant++,t.ptr+=V}}j>1&&!n&&(t.pixels.resultPixels=h.swapDimensionOrder(t.pixels.resultPixels,s,j,r))},formatFileInfo:function(e){return{fileIdentifierString:e.headerInfo.fileIdentifierString,fileVersion:e.headerInfo.fileVersion,imageType:e.headerInfo.imageType,height:e.headerInfo.height,width:e.headerInfo.width,numValidPixel:e.headerInfo.numValidPixel,microBlockSize:e.headerInfo.microBlockSize,blobSize:e.headerInfo.blobSize,maxZError:e.headerInfo.maxZError,pixelType:h.getPixelType(e.headerInfo.imageType),eofOffset:e.eofOffset,mask:e.mask?{numBytes:e.mask.numBytes}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,maxValue:e.headerInfo.zMax,minValue:e.headerInfo.zMin,noDataValue:e.noDataValue}}},constructConstantSurface:function(e,t){var r=e.headerInfo.zMax,n=e.headerInfo.zMin,i=e.headerInfo.maxValues,a=e.headerInfo.numDims,o=e.headerInfo.height*e.headerInfo.width,s=0,f=0,l=0,u=e.pixels.resultMask,c=e.pixels.resultPixels;if(u)if(a>1){if(t)for(s=0;s<a;s++)for(l=s*o,r=i[s],f=0;f<o;f++)u[f]&&(c[l+f]=r);else for(f=0;f<o;f++)if(u[f])for(l=f*a,s=0;s<a;s++)c[l+a]=i[s]}else for(f=0;f<o;f++)u[f]&&(c[f]=r);else if(a>1&&n!==r)if(t)for(s=0;s<a;s++)for(l=s*o,r=i[s],f=0;f<o;f++)c[l+f]=r;else for(f=0;f<o;f++)for(l=f*a,s=0;s<a;s++)c[l+s]=i[s];else for(f=0;f<o*a;f++)c[f]=r},getDataTypeArray:function(e){var t;switch(e){case 0:t=Int8Array;break;case 1:t=Uint8Array;break;case 2:t=Int16Array;break;case 3:t=Uint16Array;break;case 4:t=Int32Array;break;case 5:t=Uint32Array;break;case 6:default:t=Float32Array;break;case 7:t=Float64Array}return t},getPixelType:function(e){var t;switch(e){case 0:t="S8";break;case 1:t="U8";break;case 2:t="S16";break;case 3:t="U16";break;case 4:t="S32";break;case 5:t="U32";break;case 6:default:t="F32";break;case 7:t="F64"}return t},isValidPixelValue:function(e,t){if(null==t)return!1;var r;switch(e){case 0:r=t>=-128&&t<=127;break;case 1:r=t>=0&&t<=255;break;case 2:r=t>=-32768&&t<=32767;break;case 3:r=t>=0&&t<=65536;break;case 4:r=t>=-2147483648&&t<=2147483647;break;case 5:r=t>=0&&t<=4294967296;break;case 6:r=t>=-34027999387901484e22&&t<=34027999387901484e22;break;case 7:r=t>=-17976931348623157e292&&t<=17976931348623157e292;break;default:r=!1}return r},getDataTypeSize:function(e){var t=0;switch(e){case 0:case 1:t=1;break;case 2:case 3:t=2;break;case 4:case 5:case 6:t=4;break;case 7:t=8;break;default:t=e}return t},getDataTypeUsed:function(e,t){var r=e;switch(e){case 2:case 4:r=e-t;break;case 3:case 5:r=e-2*t;break;case 6:r=0===t?e:1===t?2:1;break;case 7:r=0===t?e:e-2*t+1;break;default:r=e}return r},getOnePixel:function(e,t,r,n){var i=0;switch(r){case 0:i=n.getInt8(t);break;case 1:i=n.getUint8(t);break;case 2:i=n.getInt16(t,!0);break;case 3:i=n.getUint16(t,!0);break;case 4:i=n.getInt32(t,!0);break;case 5:i=n.getUInt32(t,!0);break;case 6:i=n.getFloat32(t,!0);break;case 7:i=n.getFloat64(t,!0);break;default:throw"the decoder does not understand this pixel type"}return i},swapDimensionOrder:function(e,t,r,n,i){var a=0,o=0,s=0,f=0,l=e;if(r>1)if(l=new n(t*r),i)for(a=0;a<t;a++)for(f=a,s=0;s<r;s++,f+=t)l[f]=e[o++];else for(a=0;a<t;a++)for(f=a,s=0;s<r;s++,f+=t)l[o++]=e[f];return l}},d=function(e,t,r){this.val=e,this.left=t,this.right=r},{decode:function(e,t){var r=(t=t||{}).noDataValue,n=0,i={};i.ptr=t.inputOffset||0,i.pixels={},h.readHeaderInfo(e,i);var a=i.headerInfo,o=a.fileVersion,s=h.getDataTypeArray(a.imageType);if(o>5)throw"unsupported lerc version 2."+o;h.readMask(e,i),a.numValidPixel===a.width*a.height||i.pixels.resultMask||(i.pixels.resultMask=t.maskData);var f=a.width*a.height;i.pixels.resultPixels=new s(f*a.numDims),i.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var l,u=!t.returnPixelInterleavedDims;if(0!==a.numValidPixel)if(a.zMax===a.zMin)h.constructConstantSurface(i,u);else if(o>=4&&h.checkMinMaxRanges(e,i))h.constructConstantSurface(i,u);else{var c=new DataView(e,i.ptr,2),d=c.getUint8(0);if(i.ptr++,d)h.readDataOneSweep(e,i,s,u);else if(o>1&&a.imageType<=1&&Math.abs(a.maxZError-.5)<1e-5){var p=c.getUint8(1);if(i.ptr++,i.encodeMode=p,p>2||o<4&&p>1)throw"Invalid Huffman flag "+p;p?h.readHuffman(e,i,s,u):h.readTiles(e,i,s,u)}else h.readTiles(e,i,s,u)}i.eofOffset=i.ptr,t.inputOffset?(l=i.headerInfo.blobSize+t.inputOffset-i.ptr,Math.abs(l)>=1&&(i.eofOffset=t.inputOffset+i.headerInfo.blobSize)):(l=i.headerInfo.blobSize-i.ptr,Math.abs(l)>=1&&(i.eofOffset=i.headerInfo.blobSize));var m={width:a.width,height:a.height,pixelData:i.pixels.resultPixels,minValue:a.zMin,maxValue:a.zMax,validPixelCount:a.numValidPixel,dimCount:a.numDims,dimStats:{minValues:a.minValues,maxValues:a.maxValues},maskData:i.pixels.resultMask};if(i.pixels.resultMask&&h.isValidPixelValue(a.imageType,r)){var v=i.pixels.resultMask;for(n=0;n<f;n++)v[n]||(m.pixelData[n]=r);m.noDataValue=r}return i.noDataValue=r,t.returnFileInfo&&(m.fileInfo=h.formatFileInfo(i)),m},getBandCount:function(e){for(var t=0,r=0,n={ptr:0,pixels:{}};r<e.byteLength-58;)h.readHeaderInfo(e,n),r+=n.headerInfo.blobSize,t++,n.ptr=r;return t}}),w=(p=new ArrayBuffer(4),m=new Uint8Array(p),new Uint32Array(p)[0]=1,1===m[0]),g={decode:function(e,t){if(!w)throw"Big endian system is not supported.";var r,n,i=(t=t||{}).inputOffset||0,a=new Uint8Array(e,i,10),o=String.fromCharCode.apply(null,a);if("CntZImage"===o.trim())r=v,n=1;else{if("Lerc2"!==o.substring(0,5))throw"Unexpected file identifier string: "+o;r=y,n=2}for(var s,f,l,u,c,h,d=0,p=e.byteLength-10,m=[],g={width:0,height:0,pixels:[],pixelType:t.pixelType,mask:null,statistics:[]},b=0;i<p;){var k=r.decode(e,{inputOffset:i,encodedMaskData:s,maskData:l,returnMask:0===d,returnEncodedMask:0===d,returnFileInfo:!0,returnPixelInterleavedDims:t.returnPixelInterleavedDims,pixelType:t.pixelType||null,noDataValue:t.noDataValue||null});i=k.fileInfo.eofOffset,l=k.maskData,0===d&&(s=k.encodedMaskData,g.width=k.width,g.height=k.height,g.dimCount=k.dimCount||1,g.pixelType=k.pixelType||k.fileInfo.pixelType,g.mask=l),n>1&&(l&&m.push(l),k.fileInfo.mask&&k.fileInfo.mask.numBytes>0&&b++),d++,g.pixels.push(k.pixelData),g.statistics.push({minValue:k.minValue,maxValue:k.maxValue,noDataValue:k.noDataValue,dimStats:k.dimStats})}if(n>1&&b>1){for(h=g.width*g.height,g.bandMasks=m,(l=new Uint8Array(h)).set(m[0]),u=1;u<m.length;u++)for(f=m[u],c=0;c<h;c++)l[c]=l[c]&f[c];g.maskData=l}return g}};Ke.exports?Ke.exports=g:this.Lerc=g}();var We=Xe.exports,qe={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},Je={};for(var Qe in qe)qe.hasOwnProperty(Qe)&&(Je[qe[Qe]]=parseInt(Qe,10));Je.BitsPerSample,Je.ExtraSamples,Je.SampleFormat,Je.StripByteCounts,Je.StripOffsets,Je.StripRowCounts,Je.TileByteCounts,Je.TileOffsets,Je.SubIFDs;var $e={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},et={};for(var tt in $e)$e.hasOwnProperty(tt)&&(et[$e[tt]]=parseInt(tt,10));var rt=1,nt=0,it=1,at={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},ot={};for(var st in at)at.hasOwnProperty(st)&&(ot[at[st]]=parseInt(st,10));function ft(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var lt=function(e){p(r,b);var t=ft(r);function r(e){var n;return u(this,r),(n=t.call(this)).planarConfiguration=void 0!==e.PlanarConfiguration?e.PlanarConfiguration:1,n.samplesPerPixel=void 0!==e.SamplesPerPixel?e.SamplesPerPixel:1,n.addCompression=e.LercParameters[rt],n}return h(r,[{key:"decodeBlock",value:function(e){switch(this.addCompression){case nt:break;case it:e=Fe(new Uint8Array(e)).buffer;break;default:throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression))}return We.decode(e,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),r}(),ut=Object.freeze({__proto__:null,default:lt});function ct(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var ht=function(e){p(a,b);var r,n=ct(a);function a(){var e;if(u(this,a),e=n.call(this),"undefined"==typeof createImageBitmap)throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");if("undefined"==typeof document&&"undefined"==typeof OffscreenCanvas)throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");return e}return h(a,[{key:"decode",value:(r=t(i.mark((function e(t,r){var n,a,o,s;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=new Blob([r]),e.next=3,createImageBitmap(n);case 3:return a=e.sent,"undefined"!=typeof document?((o=document.createElement("canvas")).width=a.width,o.height=a.height):o=new OffscreenCanvas(a.width,a.height),(s=o.getContext("2d")).drawImage(a,0,0),e.abrupt("return",s.getImageData(0,0,a.width,a.height).data.buffer);case 8:case"end":return e.stop()}}),e)}))),function(e,t){return r.apply(this,arguments)})}]),a}(),dt=Object.freeze({__proto__:null,default:ht});';
    return new web_worker_1.default(typeof Blob === "undefined" ? "data:application/javascript;base64," + Buffer.from(source, "binary").toString("base64") : URL.createObjectURL(new Blob([source], { type: "application/javascript" })));
  }
  decoder.create = create2;
  return decoder;
}
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool)
    return pool;
  hasRequiredPool = 1;
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(pool, "__esModule", { value: true });
  const index_js_1 = requireCompression();
  const defaultPoolSize = typeof navigator !== "undefined" ? navigator.hardwareConcurrency || 2 : 2;
  class Pool {
    /**
     * @constructor
     * @param {Number} [size] The size of the pool. Defaults to the number of CPUs
     *                      available. When this parameter is `null` or 0, then the
     *                      decoding will be done in the main thread.
     * @param {function(): Worker} [createWorker] A function that creates the decoder worker.
     * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`
     * function is expected to return a `Worker` compatible with Web Workers. For code that
     * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.
     *
     * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:
     * ```js
     * import { addDecoder, getDecoder } from 'geotiff';
     * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));
     * self.addEventListener('message', async (e) => {
     *   const { id, fileDirectory, buffer } = e.data;
     *   const decoder = await getDecoder(fileDirectory);
     *   const decoded = await decoder.decode(fileDirectory, buffer);
     *   self.postMessage({ decoded, id }, [decoded]);
     * });
     * ```
     * The way the above code is built into a worker by the `createWorker()` function
     * depends on the used bundler. For most bundlers, something like this will work:
     * ```js
     * function createWorker() {
     *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));
     * }
     * ```
     */
    constructor(size = defaultPoolSize, createWorker) {
      this.workers = null;
      this._awaitingDecoder = null;
      this.size = size;
      this.messageId = 0;
      if (size) {
        this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {
          Promise.resolve().then(() => __importStar(requireDecoder())).then((module) => {
            resolve(module.create);
          });
        });
        this._awaitingDecoder.then((create2) => {
          this._awaitingDecoder = null;
          this.workers = [];
          for (let i = 0; i < size; i++) {
            this.workers.push({ worker: create2(), idle: true });
          }
        });
      }
    }
    /**
     * Decode the given block of bytes with the set compression method.
     * @param {ArrayBuffer} buffer the array buffer of bytes to decode.
     * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`
     */
    async decode(fileDirectory, buffer2) {
      if (this._awaitingDecoder) {
        await this._awaitingDecoder;
      }
      return this.size === 0 ? (0, index_js_1.getDecoder)(fileDirectory).then((decoder2) => decoder2.decode(fileDirectory, buffer2)) : new Promise((resolve) => {
        const worker = this.workers.find((candidate) => candidate.idle) || this.workers[Math.floor(Math.random() * this.size)];
        worker.idle = false;
        const id = this.messageId++;
        const onMessage = (e) => {
          if (e.data.id === id) {
            worker.idle = true;
            resolve(e.data.decoded);
            worker.worker.removeEventListener("message", onMessage);
          }
        };
        worker.worker.addEventListener("message", onMessage);
        worker.worker.postMessage({ fileDirectory, buffer: buffer2, id }, [buffer2]);
      });
    }
    destroy() {
      if (this.workers) {
        this.workers.forEach((worker) => {
          worker.worker.terminate();
        });
        this.workers = null;
      }
    }
  }
  pool.default = Pool;
  return pool;
}
var remote = {};
var httputils = {};
var hasRequiredHttputils;
function requireHttputils() {
  if (hasRequiredHttputils)
    return httputils;
  hasRequiredHttputils = 1;
  Object.defineProperty(httputils, "__esModule", { value: true });
  httputils.parseByteRanges = httputils.parseContentRange = httputils.parseContentType = void 0;
  const CRLFCRLF = "\r\n\r\n";
  function itemsToObject(items) {
    if (typeof Object.fromEntries !== "undefined") {
      return Object.fromEntries(items);
    }
    const obj = {};
    for (const [key, value] of items) {
      obj[key.toLowerCase()] = value;
    }
    return obj;
  }
  function parseHeaders(text) {
    const items = text.split("\r\n").map((line) => {
      const kv = line.split(":").map((str) => str.trim());
      kv[0] = kv[0].toLowerCase();
      return kv;
    });
    return itemsToObject(items);
  }
  function parseContentType(rawContentType) {
    const [type, ...rawParams] = rawContentType.split(";").map((s) => s.trim());
    const paramsItems = rawParams.map((param) => param.split("="));
    return { type, params: itemsToObject(paramsItems) };
  }
  httputils.parseContentType = parseContentType;
  function parseContentRange(rawContentRange) {
    let start2;
    let end;
    let total;
    if (rawContentRange) {
      [, start2, end, total] = rawContentRange.match(/bytes (\d+)-(\d+)\/(\d+)/);
      start2 = parseInt(start2, 10);
      end = parseInt(end, 10);
      total = parseInt(total, 10);
    }
    return { start: start2, end, total };
  }
  httputils.parseContentRange = parseContentRange;
  function parseByteRanges(responseArrayBuffer, boundary) {
    let offset = null;
    const decoder2 = new TextDecoder("ascii");
    const out = [];
    const startBoundary = `--${boundary}`;
    const endBoundary = `${startBoundary}--`;
    for (let i = 0; i < 10; ++i) {
      const text = decoder2.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));
      if (text === startBoundary) {
        offset = i;
      }
    }
    if (offset === null) {
      throw new Error("Could not find initial boundary");
    }
    while (offset < responseArrayBuffer.byteLength) {
      const text = decoder2.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset)));
      if (text.length === 0 || text.startsWith(endBoundary)) {
        break;
      }
      if (!text.startsWith(startBoundary)) {
        throw new Error("Part does not start with boundary");
      }
      const innerText = text.substr(startBoundary.length + 2);
      if (innerText.length === 0) {
        break;
      }
      const endOfHeaders = innerText.indexOf(CRLFCRLF);
      const headers = parseHeaders(innerText.substr(0, endOfHeaders));
      const { start: start2, end, total } = parseContentRange(headers["content-range"]);
      const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;
      const length = parseInt(end, 10) + 1 - parseInt(start2, 10);
      out.push({
        headers,
        data: responseArrayBuffer.slice(startOfData, startOfData + length),
        offset: start2,
        length,
        fileSize: total
      });
      offset = startOfData + length + 4;
    }
    return out;
  }
  httputils.parseByteRanges = parseByteRanges;
  return httputils;
}
var basesource = {};
var hasRequiredBasesource;
function requireBasesource() {
  if (hasRequiredBasesource)
    return basesource;
  hasRequiredBasesource = 1;
  Object.defineProperty(basesource, "__esModule", { value: true });
  basesource.BaseSource = void 0;
  class BaseSource {
    /**
     *
     * @param {Slice[]} slices
     * @returns {ArrayBuffer[]}
     */
    async fetch(slices, signal = void 0) {
      return Promise.all(slices.map((slice) => this.fetchSlice(slice, signal)));
    }
    /**
     *
     * @param {Slice} slice
     * @returns {ArrayBuffer}
     */
    async fetchSlice(slice) {
      throw new Error(`fetching of slice ${slice} not possible, not implemented`);
    }
    /**
     * Returns the filesize if already determined and null otherwise
     */
    get fileSize() {
      return null;
    }
    async close() {
    }
  }
  basesource.BaseSource = BaseSource;
  return basesource;
}
var blockedsource = {};
class QuickLRU extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(cache2) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache2) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache2) {
    const item = cache2.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value,
        expiry
      });
    } else {
      this._set(key, { value, expiry });
    }
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.oldCache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this._entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
}
const quickLru = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: QuickLRU
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(quickLru);
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.AggregateError = utils.CustomAggregateError = utils.AbortError = utils.zip = utils.wait = utils.parseContentRange = utils.toArrayRecursively = utils.toArray = utils.times = utils.range = utils.invert = utils.forEach = utils.endsWith = utils.chunk = utils.assign = void 0;
  function assign2(target, source) {
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
  }
  utils.assign = assign2;
  function chunk(iterable, length) {
    const results = [];
    const lengthOfIterable = iterable.length;
    for (let i = 0; i < lengthOfIterable; i += length) {
      const chunked = [];
      for (let ci = i; ci < i + length; ci++) {
        chunked.push(iterable[ci]);
      }
      results.push(chunked);
    }
    return results;
  }
  utils.chunk = chunk;
  function endsWith(string, expectedEnding) {
    if (string.length < expectedEnding.length) {
      return false;
    }
    const actualEnding = string.substr(string.length - expectedEnding.length);
    return actualEnding === expectedEnding;
  }
  utils.endsWith = endsWith;
  function forEach2(iterable, func) {
    const { length } = iterable;
    for (let i = 0; i < length; i++) {
      func(iterable[i], i);
    }
  }
  utils.forEach = forEach2;
  function invert2(oldObj) {
    const newObj = {};
    for (const key in oldObj) {
      if (oldObj.hasOwnProperty(key)) {
        const value = oldObj[key];
        newObj[value] = key;
      }
    }
    return newObj;
  }
  utils.invert = invert2;
  function range(n) {
    const results = [];
    for (let i = 0; i < n; i++) {
      results.push(i);
    }
    return results;
  }
  utils.range = range;
  function times(numTimes, func) {
    const results = [];
    for (let i = 0; i < numTimes; i++) {
      results.push(func(i));
    }
    return results;
  }
  utils.times = times;
  function toArray(iterable) {
    const results = [];
    const { length } = iterable;
    for (let i = 0; i < length; i++) {
      results.push(iterable[i]);
    }
    return results;
  }
  utils.toArray = toArray;
  function toArrayRecursively(input) {
    if (input.length) {
      return toArray(input).map(toArrayRecursively);
    }
    return input;
  }
  utils.toArrayRecursively = toArrayRecursively;
  function parseContentRange(headerValue) {
    if (!headerValue) {
      return null;
    }
    if (typeof headerValue !== "string") {
      throw new Error("invalid argument");
    }
    const parseInt2 = (number) => Number.parseInt(number, 10);
    let matches = headerValue.match(/^(\w*) /);
    const unit = matches && matches[1];
    matches = headerValue.match(/(\d+)-(\d+)\/(\d+|\*)/);
    if (matches) {
      return {
        unit,
        first: parseInt2(matches[1]),
        last: parseInt2(matches[2]),
        length: matches[3] === "*" ? null : parseInt2(matches[3])
      };
    }
    matches = headerValue.match(/(\d+|\*)/);
    if (matches) {
      return {
        unit,
        first: null,
        last: null,
        length: matches[1] === "*" ? null : parseInt2(matches[1])
      };
    }
    return null;
  }
  utils.parseContentRange = parseContentRange;
  async function wait(milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
  }
  utils.wait = wait;
  function zip(a, b) {
    const A2 = Array.isArray(a) ? a : Array.from(a);
    const B = Array.isArray(b) ? b : Array.from(b);
    return A2.map((k, i) => [k, B[i]]);
  }
  utils.zip = zip;
  class AbortError extends Error {
    constructor(params2) {
      super(params2);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, AbortError);
      }
      this.name = "AbortError";
    }
  }
  utils.AbortError = AbortError;
  class CustomAggregateError extends Error {
    constructor(errors, message) {
      super(message);
      this.errors = errors;
      this.message = message;
      this.name = "AggregateError";
    }
  }
  utils.CustomAggregateError = CustomAggregateError;
  utils.AggregateError = CustomAggregateError;
  return utils;
}
var hasRequiredBlockedsource;
function requireBlockedsource() {
  if (hasRequiredBlockedsource)
    return blockedsource;
  hasRequiredBlockedsource = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(blockedsource, "__esModule", { value: true });
  blockedsource.BlockedSource = void 0;
  const quick_lru_1 = __importDefault(require$$0$1);
  const basesource_js_1 = requireBasesource();
  const utils_js_1 = requireUtils();
  class Block {
    /**
     *
     * @param {number} offset
     * @param {number} length
     * @param {ArrayBuffer} [data]
     */
    constructor(offset, length, data = null) {
      this.offset = offset;
      this.length = length;
      this.data = data;
    }
    /**
     * @returns {number} the top byte border
     */
    get top() {
      return this.offset + this.length;
    }
  }
  class BlockGroup {
    /**
     *
     * @param {number} offset
     * @param {number} length
     * @param {number[]} blockIds
     */
    constructor(offset, length, blockIds) {
      this.offset = offset;
      this.length = length;
      this.blockIds = blockIds;
    }
  }
  class BlockedSource extends basesource_js_1.BaseSource {
    /**
     *
     * @param {Source} source The underlying source that shall be blocked and cached
     * @param {object} options
     */
    constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {
      super();
      this.source = source;
      this.blockSize = blockSize;
      this.blockCache = new quick_lru_1.default({ maxSize: cacheSize });
      this.blockRequests = /* @__PURE__ */ new Map();
      this.blockIdsToFetch = /* @__PURE__ */ new Set();
      this.abortedBlockIds = /* @__PURE__ */ new Set();
    }
    get fileSize() {
      return this.source.fileSize;
    }
    /**
     *
     * @param {basesource/Slice[]} slices
     */
    async fetch(slices, signal) {
      const blockRequests = [];
      const missingBlockIds = [];
      const allBlockIds = [];
      for (const { offset, length } of slices) {
        let top = offset + length;
        const { fileSize } = this;
        if (fileSize !== null) {
          top = Math.min(top, fileSize);
        }
        const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;
        for (let current = firstBlockOffset; current < top; current += this.blockSize) {
          const blockId = Math.floor(current / this.blockSize);
          if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {
            this.blockIdsToFetch.add(blockId);
            missingBlockIds.push(blockId);
          }
          if (this.blockRequests.has(blockId)) {
            blockRequests.push(this.blockRequests.get(blockId));
          }
          allBlockIds.push(blockId);
        }
      }
      await (0, utils_js_1.wait)();
      this.fetchBlocks(signal);
      const missingRequests = [];
      for (const blockId of missingBlockIds) {
        if (this.blockRequests.has(blockId)) {
          missingRequests.push(this.blockRequests.get(blockId));
        }
      }
      await Promise.allSettled(blockRequests);
      await Promise.allSettled(missingRequests);
      const abortedBlockRequests = [];
      const abortedBlockIds = allBlockIds.filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));
      abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));
      if (abortedBlockIds.length > 0 && signal && !signal.aborted) {
        this.fetchBlocks(null);
        for (const blockId of abortedBlockIds) {
          const block = this.blockRequests.get(blockId);
          if (!block) {
            throw new Error(`Block ${blockId} is not in the block requests`);
          }
          abortedBlockRequests.push(block);
        }
        await Promise.allSettled(abortedBlockRequests);
      }
      if (signal && signal.aborted) {
        throw new utils_js_1.AbortError("Request was aborted");
      }
      const blocks = allBlockIds.map((id) => this.blockCache.get(id));
      const failedBlocks = blocks.filter((i) => !i);
      if (failedBlocks.length) {
        throw new utils_js_1.AggregateError(failedBlocks, "Request failed");
      }
      const requiredBlocks = new Map((0, utils_js_1.zip)(allBlockIds, blocks));
      return this.readSliceData(slices, requiredBlocks);
    }
    /**
     *
     * @param {AbortSignal} signal
     */
    fetchBlocks(signal) {
      if (this.blockIdsToFetch.size > 0) {
        const groups = this.groupBlocks(this.blockIdsToFetch);
        const groupRequests = this.source.fetch(groups, signal);
        for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {
          const group = groups[groupIndex];
          for (const blockId of group.blockIds) {
            this.blockRequests.set(blockId, (async () => {
              try {
                const response = (await groupRequests)[groupIndex];
                const blockOffset = blockId * this.blockSize;
                const o = blockOffset - response.offset;
                const t = Math.min(o + this.blockSize, response.data.byteLength);
                const data = response.data.slice(o, t);
                const block = new Block(blockOffset, data.byteLength, data, blockId);
                this.blockCache.set(blockId, block);
                this.abortedBlockIds.delete(blockId);
              } catch (err) {
                if (err.name === "AbortError") {
                  err.signal = signal;
                  this.blockCache.delete(blockId);
                  this.abortedBlockIds.add(blockId);
                } else {
                  throw err;
                }
              } finally {
                this.blockRequests.delete(blockId);
              }
            })());
          }
        }
        this.blockIdsToFetch.clear();
      }
    }
    /**
     *
     * @param {Set} blockIds
     * @returns {BlockGroup[]}
     */
    groupBlocks(blockIds) {
      const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);
      if (sortedBlockIds.length === 0) {
        return [];
      }
      let current = [];
      let lastBlockId = null;
      const groups = [];
      for (const blockId of sortedBlockIds) {
        if (lastBlockId === null || lastBlockId + 1 === blockId) {
          current.push(blockId);
          lastBlockId = blockId;
        } else {
          groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
          current = [blockId];
          lastBlockId = blockId;
        }
      }
      groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
      return groups;
    }
    /**
     *
     * @param {Slice[]} slices
     * @param {Map} blocks
     */
    readSliceData(slices, blocks) {
      return slices.map((slice) => {
        let top = slice.offset + slice.length;
        if (this.fileSize !== null) {
          top = Math.min(this.fileSize, top);
        }
        const blockIdLow = Math.floor(slice.offset / this.blockSize);
        const blockIdHigh = Math.floor(top / this.blockSize);
        const sliceData = new ArrayBuffer(slice.length);
        const sliceView = new Uint8Array(sliceData);
        for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {
          const block = blocks.get(blockId);
          const delta = block.offset - slice.offset;
          const topDelta = block.top - top;
          let blockInnerOffset = 0;
          let rangeInnerOffset = 0;
          let usedBlockLength;
          if (delta < 0) {
            blockInnerOffset = -delta;
          } else if (delta > 0) {
            rangeInnerOffset = delta;
          }
          if (topDelta < 0) {
            usedBlockLength = block.length - blockInnerOffset;
          } else {
            usedBlockLength = top - block.offset - blockInnerOffset;
          }
          const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);
          sliceView.set(blockView, rangeInnerOffset);
        }
        return sliceData;
      });
    }
  }
  blockedsource.BlockedSource = BlockedSource;
  return blockedsource;
}
var fetch$1 = {};
var base = {};
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase)
    return base;
  hasRequiredBase = 1;
  Object.defineProperty(base, "__esModule", { value: true });
  base.BaseClient = base.BaseResponse = void 0;
  class BaseResponse {
    /**
     * Returns whether the response has an ok'ish status code
     */
    get ok() {
      return this.status >= 200 && this.status <= 299;
    }
    /**
     * Returns the status code of the response
     */
    get status() {
      throw new Error("not implemented");
    }
    /**
     * Returns the value of the specified header
     * @param {string} headerName the header name
     * @returns {string} the header value
     */
    getHeader(headerName) {
      throw new Error("not implemented");
    }
    /**
     * @returns {ArrayBuffer} the response data of the request
     */
    async getData() {
      throw new Error("not implemented");
    }
  }
  base.BaseResponse = BaseResponse;
  class BaseClient {
    constructor(url) {
      this.url = url;
    }
    /**
     * Send a request with the options
     * @param {object} [options]
     */
    async request({ headers, credentials, signal } = {}) {
      throw new Error("request is not implemented");
    }
  }
  base.BaseClient = BaseClient;
  return base;
}
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch)
    return fetch$1;
  hasRequiredFetch = 1;
  Object.defineProperty(fetch$1, "__esModule", { value: true });
  fetch$1.FetchClient = void 0;
  const base_js_1 = requireBase();
  class FetchResponse extends base_js_1.BaseResponse {
    /**
     * BaseResponse facade for fetch API Response
     * @param {Response} response
     */
    constructor(response) {
      super();
      this.response = response;
    }
    get status() {
      return this.response.status;
    }
    getHeader(name) {
      return this.response.headers.get(name);
    }
    async getData() {
      const data = this.response.arrayBuffer ? await this.response.arrayBuffer() : (await this.response.buffer()).buffer;
      return data;
    }
  }
  class FetchClient extends base_js_1.BaseClient {
    constructor(url, credentials) {
      super(url);
      this.credentials = credentials;
    }
    async request({ headers, credentials, signal } = {}) {
      const response = await fetch(this.url, {
        headers,
        credentials,
        signal
      });
      return new FetchResponse(response);
    }
  }
  fetch$1.FetchClient = FetchClient;
  return fetch$1;
}
var xhr = {};
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  Object.defineProperty(xhr, "__esModule", { value: true });
  xhr.XHRClient = void 0;
  const base_js_1 = requireBase();
  const utils_js_1 = requireUtils();
  class XHRResponse extends base_js_1.BaseResponse {
    /**
     * BaseResponse facade for XMLHttpRequest
     * @param {XMLHttpRequest} xhr
     * @param {ArrayBuffer} data
     */
    constructor(xhr2, data) {
      super();
      this.xhr = xhr2;
      this.data = data;
    }
    get status() {
      return this.xhr.status;
    }
    getHeader(name) {
      return this.xhr.getResponseHeader(name);
    }
    async getData() {
      return this.data;
    }
  }
  class XHRClient extends base_js_1.BaseClient {
    constructRequest(headers, signal) {
      return new Promise((resolve, reject) => {
        const xhr2 = new XMLHttpRequest();
        xhr2.open("GET", this.url);
        xhr2.responseType = "arraybuffer";
        for (const [key, value] of Object.entries(headers)) {
          xhr2.setRequestHeader(key, value);
        }
        xhr2.onload = () => {
          const data = xhr2.response;
          resolve(new XHRResponse(xhr2, data));
        };
        xhr2.onerror = reject;
        xhr2.onabort = () => reject(new utils_js_1.AbortError("Request aborted"));
        xhr2.send();
        if (signal) {
          if (signal.aborted) {
            xhr2.abort();
          }
          signal.addEventListener("abort", () => xhr2.abort());
        }
      });
    }
    async request({ headers, signal } = {}) {
      const response = await this.constructRequest(headers, signal);
      return response;
    }
  }
  xhr.XHRClient = XHRClient;
  return xhr;
}
var http = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredHttp;
function requireHttp() {
  if (hasRequiredHttp)
    return http;
  hasRequiredHttp = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(http, "__esModule", { value: true });
  http.HttpClient = void 0;
  const http_1 = __importDefault(require$$0);
  const https_1 = __importDefault(require$$0);
  const url_1 = __importDefault(require$$0);
  const base_js_1 = requireBase();
  const utils_js_1 = requireUtils();
  class HttpResponse extends base_js_1.BaseResponse {
    /**
     * BaseResponse facade for node HTTP/HTTPS API Response
     * @param {http.ServerResponse} response
     */
    constructor(response, dataPromise) {
      super();
      this.response = response;
      this.dataPromise = dataPromise;
    }
    get status() {
      return this.response.statusCode;
    }
    getHeader(name) {
      return this.response.headers[name];
    }
    async getData() {
      const data = await this.dataPromise;
      return data;
    }
  }
  class HttpClient extends base_js_1.BaseClient {
    constructor(url) {
      super(url);
      this.parsedUrl = url_1.default.parse(this.url);
      this.httpApi = this.parsedUrl.protocol === "http:" ? http_1.default : https_1.default;
    }
    constructRequest(headers, signal) {
      return new Promise((resolve, reject) => {
        const request = this.httpApi.get({
          ...this.parsedUrl,
          headers
        }, (response) => {
          const dataPromise = new Promise((resolveData) => {
            const chunks = [];
            response.on("data", (chunk) => {
              chunks.push(chunk);
            });
            response.on("end", () => {
              const data = Buffer.concat(chunks).buffer;
              resolveData(data);
            });
            response.on("error", reject);
          });
          resolve(new HttpResponse(response, dataPromise));
        });
        request.on("error", reject);
        if (signal) {
          if (signal.aborted) {
            request.destroy(new utils_js_1.AbortError("Request aborted"));
          }
          signal.addEventListener("abort", () => request.destroy(new utils_js_1.AbortError("Request aborted")));
        }
      });
    }
    async request({ headers, signal } = {}) {
      const response = await this.constructRequest(headers, signal);
      return response;
    }
  }
  http.HttpClient = HttpClient;
  return http;
}
var hasRequiredRemote;
function requireRemote() {
  if (hasRequiredRemote)
    return remote;
  hasRequiredRemote = 1;
  Object.defineProperty(remote, "__esModule", { value: true });
  remote.makeRemoteSource = remote.makeHttpSource = remote.makeXHRSource = remote.makeFetchSource = void 0;
  const httputils_js_1 = requireHttputils();
  const basesource_js_1 = requireBasesource();
  const blockedsource_js_1 = requireBlockedsource();
  const fetch_js_1 = requireFetch();
  const xhr_js_1 = requireXhr();
  const http_js_1 = requireHttp();
  class RemoteSource extends basesource_js_1.BaseSource {
    /**
     *
     * @param {BaseClient} client
     * @param {object} headers
     * @param {numbers} maxRanges
     * @param {boolean} allowFullFile
     */
    constructor(client, headers, maxRanges, allowFullFile) {
      super();
      this.client = client;
      this.headers = headers;
      this.maxRanges = maxRanges;
      this.allowFullFile = allowFullFile;
      this._fileSize = null;
    }
    /**
     *
     * @param {Slice[]} slices
     */
    async fetch(slices, signal) {
      if (this.maxRanges >= slices.length) {
        return this.fetchSlices(slices, signal);
      } else if (this.maxRanges > 0 && slices.length > 1)
        ;
      return Promise.all(slices.map((slice) => this.fetchSlice(slice, signal)));
    }
    async fetchSlices(slices, signal) {
      const response = await this.client.request({
        headers: {
          ...this.headers,
          Range: `bytes=${slices.map(({ offset, length }) => `${offset}-${offset + length}`).join(",")}`
        },
        signal
      });
      if (!response.ok) {
        throw new Error("Error fetching data.");
      } else if (response.status === 206) {
        const { type, params: params2 } = (0, httputils_js_1.parseContentType)(response.getHeader("content-type"));
        if (type === "multipart/byteranges") {
          const byteRanges = (0, httputils_js_1.parseByteRanges)(await response.getData(), params2.boundary);
          this._fileSize = byteRanges[0].fileSize || null;
          return byteRanges;
        }
        const data = await response.getData();
        const { start: start2, end, total } = (0, httputils_js_1.parseContentRange)(response.getHeader("content-range"));
        this._fileSize = total || null;
        const first = [{
          data,
          offset: start2,
          length: end - start2
        }];
        if (slices.length > 1) {
          const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));
          return first.concat(others);
        }
        return first;
      } else {
        if (!this.allowFullFile) {
          throw new Error("Server responded with full file");
        }
        const data = await response.getData();
        this._fileSize = data.byteLength;
        return [{
          data,
          offset: 0,
          length: data.byteLength
        }];
      }
    }
    async fetchSlice(slice, signal) {
      const { offset, length } = slice;
      const response = await this.client.request({
        headers: {
          ...this.headers,
          Range: `bytes=${offset}-${offset + length}`
        },
        signal
      });
      if (!response.ok) {
        throw new Error("Error fetching data.");
      } else if (response.status === 206) {
        const data = await response.getData();
        const { total } = (0, httputils_js_1.parseContentRange)(response.getHeader("content-range"));
        this._fileSize = total || null;
        return {
          data,
          offset,
          length
        };
      } else {
        if (!this.allowFullFile) {
          throw new Error("Server responded with full file");
        }
        const data = await response.getData();
        this._fileSize = data.byteLength;
        return {
          data,
          offset: 0,
          length: data.byteLength
        };
      }
    }
    get fileSize() {
      return this._fileSize;
    }
  }
  function maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {
    if (blockSize === null) {
      return source;
    }
    return new blockedsource_js_1.BlockedSource(source, { blockSize, cacheSize });
  }
  function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {
    const client = new fetch_js_1.FetchClient(url, credentials);
    const source = new RemoteSource(client, headers, maxRanges, allowFullFile);
    return maybeWrapInBlockedSource(source, blockOptions);
  }
  remote.makeFetchSource = makeFetchSource;
  function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {
    const client = new xhr_js_1.XHRClient(url);
    const source = new RemoteSource(client, headers, maxRanges, allowFullFile);
    return maybeWrapInBlockedSource(source, blockOptions);
  }
  remote.makeXHRSource = makeXHRSource;
  function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {
    const client = new http_js_1.HttpClient(url);
    const source = new RemoteSource(client, headers, maxRanges, allowFullFile);
    return maybeWrapInBlockedSource(source, blockOptions);
  }
  remote.makeHttpSource = makeHttpSource;
  function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {
    if (typeof fetch === "function" && !forceXHR) {
      return makeFetchSource(url, clientOptions);
    }
    if (typeof XMLHttpRequest !== "undefined") {
      return makeXHRSource(url, clientOptions);
    }
    return makeHttpSource(url, clientOptions);
  }
  remote.makeRemoteSource = makeRemoteSource;
  return remote;
}
var arraybuffer = {};
var hasRequiredArraybuffer;
function requireArraybuffer() {
  if (hasRequiredArraybuffer)
    return arraybuffer;
  hasRequiredArraybuffer = 1;
  Object.defineProperty(arraybuffer, "__esModule", { value: true });
  arraybuffer.makeBufferSource = void 0;
  const basesource_js_1 = requireBasesource();
  const utils_js_1 = requireUtils();
  class ArrayBufferSource extends basesource_js_1.BaseSource {
    constructor(arrayBuffer) {
      super();
      this.arrayBuffer = arrayBuffer;
    }
    fetchSlice(slice, signal) {
      if (signal && signal.aborted) {
        throw new utils_js_1.AbortError("Request aborted");
      }
      return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);
    }
  }
  function makeBufferSource(arrayBuffer) {
    return new ArrayBufferSource(arrayBuffer);
  }
  arraybuffer.makeBufferSource = makeBufferSource;
  return arraybuffer;
}
var filereader = {};
var hasRequiredFilereader;
function requireFilereader() {
  if (hasRequiredFilereader)
    return filereader;
  hasRequiredFilereader = 1;
  Object.defineProperty(filereader, "__esModule", { value: true });
  filereader.makeFileReaderSource = void 0;
  const basesource_js_1 = requireBasesource();
  class FileReaderSource extends basesource_js_1.BaseSource {
    constructor(file2) {
      super();
      this.file = file2;
    }
    async fetchSlice(slice, signal) {
      return new Promise((resolve, reject) => {
        const blob = this.file.slice(slice.offset, slice.offset + slice.length);
        const reader = new FileReader();
        reader.onload = (event) => resolve(event.target.result);
        reader.onerror = reject;
        reader.onabort = reject;
        reader.readAsArrayBuffer(blob);
        if (signal) {
          signal.addEventListener("abort", () => reader.abort());
        }
      });
    }
  }
  function makeFileReaderSource(file2) {
    return new FileReaderSource(file2);
  }
  filereader.makeFileReaderSource = makeFileReaderSource;
  return filereader;
}
var file = {};
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile)
    return file;
  hasRequiredFile = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(file, "__esModule", { value: true });
  file.makeFileSource = void 0;
  const fs_1 = __importDefault(require$$0);
  const basesource_js_1 = requireBasesource();
  function closeAsync(fd) {
    return new Promise((resolve, reject) => {
      fs_1.default.close(fd, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  function openAsync(path, flags, mode2 = void 0) {
    return new Promise((resolve, reject) => {
      fs_1.default.open(path, flags, mode2, (err, fd) => {
        if (err) {
          reject(err);
        } else {
          resolve(fd);
        }
      });
    });
  }
  function readAsync(...args) {
    return new Promise((resolve, reject) => {
      fs_1.default.read(...args, (err, bytesRead, buffer2) => {
        if (err) {
          reject(err);
        } else {
          resolve({ bytesRead, buffer: buffer2 });
        }
      });
    });
  }
  class FileSource extends basesource_js_1.BaseSource {
    constructor(path) {
      super();
      this.path = path;
      this.openRequest = openAsync(path, "r");
    }
    async fetchSlice(slice) {
      const fd = await this.openRequest;
      const { buffer: buffer2 } = await readAsync(fd, Buffer.alloc(slice.length), 0, slice.length, slice.offset);
      return buffer2.buffer;
    }
    async close() {
      const fd = await this.openRequest;
      await closeAsync(fd);
    }
  }
  function makeFileSource(path) {
    return new FileSource(path);
  }
  file.makeFileSource = makeFileSource;
  return file;
}
var geotiffwriter = {};
var hasRequiredGeotiffwriter;
function requireGeotiffwriter() {
  if (hasRequiredGeotiffwriter)
    return geotiffwriter;
  hasRequiredGeotiffwriter = 1;
  Object.defineProperty(geotiffwriter, "__esModule", { value: true });
  geotiffwriter.writeGeotiff = void 0;
  const globals_js_1 = requireGlobals();
  const utils_js_1 = requireUtils();
  const tagName2Code = (0, utils_js_1.invert)(globals_js_1.fieldTagNames);
  const geoKeyName2Code = (0, utils_js_1.invert)(globals_js_1.geoKeyNames);
  const name2code = {};
  (0, utils_js_1.assign)(name2code, tagName2Code);
  (0, utils_js_1.assign)(name2code, geoKeyName2Code);
  const typeName2byte = (0, utils_js_1.invert)(globals_js_1.fieldTypeNames);
  const numBytesInIfd = 1e3;
  const _binBE = {
    nextZero: (data, o) => {
      let oincr = o;
      while (data[oincr] !== 0) {
        oincr++;
      }
      return oincr;
    },
    readUshort: (buff, p) => {
      return buff[p] << 8 | buff[p + 1];
    },
    readShort: (buff, p) => {
      const a = _binBE.ui8;
      a[0] = buff[p + 1];
      a[1] = buff[p + 0];
      return _binBE.i16[0];
    },
    readInt: (buff, p) => {
      const a = _binBE.ui8;
      a[0] = buff[p + 3];
      a[1] = buff[p + 2];
      a[2] = buff[p + 1];
      a[3] = buff[p + 0];
      return _binBE.i32[0];
    },
    readUint: (buff, p) => {
      const a = _binBE.ui8;
      a[0] = buff[p + 3];
      a[1] = buff[p + 2];
      a[2] = buff[p + 1];
      a[3] = buff[p + 0];
      return _binBE.ui32[0];
    },
    readASCII: (buff, p, l) => {
      return l.map((i) => String.fromCharCode(buff[p + i])).join("");
    },
    readFloat: (buff, p) => {
      const a = _binBE.ui8;
      (0, utils_js_1.times)(4, (i) => {
        a[i] = buff[p + 3 - i];
      });
      return _binBE.fl32[0];
    },
    readDouble: (buff, p) => {
      const a = _binBE.ui8;
      (0, utils_js_1.times)(8, (i) => {
        a[i] = buff[p + 7 - i];
      });
      return _binBE.fl64[0];
    },
    writeUshort: (buff, p, n) => {
      buff[p] = n >> 8 & 255;
      buff[p + 1] = n & 255;
    },
    writeUint: (buff, p, n) => {
      buff[p] = n >> 24 & 255;
      buff[p + 1] = n >> 16 & 255;
      buff[p + 2] = n >> 8 & 255;
      buff[p + 3] = n >> 0 & 255;
    },
    writeASCII: (buff, p, s) => {
      (0, utils_js_1.times)(s.length, (i) => {
        buff[p + i] = s.charCodeAt(i);
      });
    },
    ui8: new Uint8Array(8)
  };
  _binBE.fl64 = new Float64Array(_binBE.ui8.buffer);
  _binBE.writeDouble = (buff, p, n) => {
    _binBE.fl64[0] = n;
    (0, utils_js_1.times)(8, (i) => {
      buff[p + i] = _binBE.ui8[7 - i];
    });
  };
  const _writeIFD = (bin, data, _offset2, ifd) => {
    let offset = _offset2;
    const keys = Object.keys(ifd).filter((key) => {
      return key !== void 0 && key !== null && key !== "undefined";
    });
    bin.writeUshort(data, offset, keys.length);
    offset += 2;
    let eoff = offset + 12 * keys.length + 4;
    for (const key of keys) {
      let tag = null;
      if (typeof key === "number") {
        tag = key;
      } else if (typeof key === "string") {
        tag = parseInt(key, 10);
      }
      const typeName = globals_js_1.fieldTagTypes[tag];
      const typeNum = typeName2byte[typeName];
      if (typeName == null || typeName === void 0 || typeof typeName === "undefined") {
        throw new Error(`unknown type of tag: ${tag}`);
      }
      let val = ifd[key];
      if (val === void 0) {
        throw new Error(`failed to get value for key ${key}`);
      }
      if (typeName === "ASCII" && typeof val === "string" && (0, utils_js_1.endsWith)(val, "\0") === false) {
        val += "\0";
      }
      const num = val.length;
      bin.writeUshort(data, offset, tag);
      offset += 2;
      bin.writeUshort(data, offset, typeNum);
      offset += 2;
      bin.writeUint(data, offset, num);
      offset += 4;
      let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;
      let toff = offset;
      if (dlen > 4) {
        bin.writeUint(data, offset, eoff);
        toff = eoff;
      }
      if (typeName === "ASCII") {
        bin.writeASCII(data, toff, val);
      } else if (typeName === "SHORT") {
        (0, utils_js_1.times)(num, (i) => {
          bin.writeUshort(data, toff + 2 * i, val[i]);
        });
      } else if (typeName === "LONG") {
        (0, utils_js_1.times)(num, (i) => {
          bin.writeUint(data, toff + 4 * i, val[i]);
        });
      } else if (typeName === "RATIONAL") {
        (0, utils_js_1.times)(num, (i) => {
          bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 1e4));
          bin.writeUint(data, toff + 8 * i + 4, 1e4);
        });
      } else if (typeName === "DOUBLE") {
        (0, utils_js_1.times)(num, (i) => {
          bin.writeDouble(data, toff + 8 * i, val[i]);
        });
      }
      if (dlen > 4) {
        dlen += dlen & 1;
        eoff += dlen;
      }
      offset += 4;
    }
    return [offset, eoff];
  };
  const encodeIfds = (ifds) => {
    const data = new Uint8Array(numBytesInIfd);
    let offset = 4;
    const bin = _binBE;
    data[0] = 77;
    data[1] = 77;
    data[3] = 42;
    let ifdo = 8;
    bin.writeUint(data, offset, ifdo);
    offset += 4;
    ifds.forEach((ifd, i) => {
      const noffs = _writeIFD(bin, data, ifdo, ifd);
      ifdo = noffs[1];
      if (i < ifds.length - 1) {
        bin.writeUint(data, noffs[0], ifdo);
      }
    });
    if (data.slice) {
      return data.slice(0, ifdo).buffer;
    }
    const result = new Uint8Array(ifdo);
    for (let i = 0; i < ifdo; i++) {
      result[i] = data[i];
    }
    return result.buffer;
  };
  const encodeImage = (values, width, height, metadata) => {
    if (height === void 0 || height === null) {
      throw new Error(`you passed into encodeImage a width of type ${height}`);
    }
    if (width === void 0 || width === null) {
      throw new Error(`you passed into encodeImage a width of type ${width}`);
    }
    const ifd = {
      256: [width],
      257: [height],
      273: [numBytesInIfd],
      278: [height],
      305: "geotiff.js"
      // no array for ASCII(Z)
    };
    if (metadata) {
      for (const i in metadata) {
        if (metadata.hasOwnProperty(i)) {
          ifd[i] = metadata[i];
        }
      }
    }
    const prfx = new Uint8Array(encodeIfds([ifd]));
    const img = new Uint8Array(values);
    const samplesPerPixel = ifd[277];
    const data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);
    (0, utils_js_1.times)(prfx.length, (i) => {
      data[i] = prfx[i];
    });
    (0, utils_js_1.forEach)(img, (value, i) => {
      data[numBytesInIfd + i] = value;
    });
    return data.buffer;
  };
  const convertToTids = (input) => {
    const result = {};
    for (const key in input) {
      if (key !== "StripOffsets") {
        if (!name2code[key]) {
          console.error(key, "not in name2code:", Object.keys(name2code));
        }
        result[name2code[key]] = input[key];
      }
    }
    return result;
  };
  const toArray = (input) => {
    if (Array.isArray(input)) {
      return input;
    }
    return [input];
  };
  const metadataDefaults = [
    ["Compression", 1],
    ["PlanarConfiguration", 1],
    ["ExtraSamples", 0]
  ];
  function writeGeotiff(data, metadata) {
    const isFlattened = typeof data[0] === "number";
    let height;
    let numBands;
    let width;
    let flattenedValues;
    if (isFlattened) {
      height = metadata.height || metadata.ImageLength;
      width = metadata.width || metadata.ImageWidth;
      numBands = data.length / (height * width);
      flattenedValues = data;
    } else {
      numBands = data.length;
      height = data[0].length;
      width = data[0][0].length;
      flattenedValues = [];
      (0, utils_js_1.times)(height, (rowIndex) => {
        (0, utils_js_1.times)(width, (columnIndex) => {
          (0, utils_js_1.times)(numBands, (bandIndex) => {
            flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);
          });
        });
      });
    }
    metadata.ImageLength = height;
    delete metadata.height;
    metadata.ImageWidth = width;
    delete metadata.width;
    if (!metadata.BitsPerSample) {
      metadata.BitsPerSample = (0, utils_js_1.times)(numBands, () => 8);
    }
    metadataDefaults.forEach((tag) => {
      const key = tag[0];
      if (!metadata[key]) {
        const value = tag[1];
        metadata[key] = value;
      }
    });
    if (!metadata.PhotometricInterpretation) {
      metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;
    }
    if (!metadata.SamplesPerPixel) {
      metadata.SamplesPerPixel = [numBands];
    }
    if (!metadata.StripByteCounts) {
      metadata.StripByteCounts = [numBands * height * width];
    }
    if (!metadata.ModelPixelScale) {
      metadata.ModelPixelScale = [360 / width, 180 / height, 0];
    }
    if (!metadata.SampleFormat) {
      metadata.SampleFormat = (0, utils_js_1.times)(numBands, () => 1);
    }
    if (!metadata.hasOwnProperty("GeographicTypeGeoKey") && !metadata.hasOwnProperty("ProjectedCSTypeGeoKey")) {
      metadata.GeographicTypeGeoKey = 4326;
      metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0];
      metadata.GeogCitationGeoKey = "WGS 84";
      metadata.GTModelTypeGeoKey = 2;
    }
    const geoKeys = Object.keys(metadata).filter((key) => (0, utils_js_1.endsWith)(key, "GeoKey")).sort((a, b) => name2code[a] - name2code[b]);
    if (!metadata.GeoAsciiParams) {
      let geoAsciiParams = "";
      geoKeys.forEach((name) => {
        const code = Number(name2code[name]);
        const tagType = globals_js_1.fieldTagTypes[code];
        if (tagType === "ASCII") {
          geoAsciiParams += `${metadata[name].toString()}\0`;
        }
      });
      if (geoAsciiParams.length > 0) {
        metadata.GeoAsciiParams = geoAsciiParams;
      }
    }
    if (!metadata.GeoKeyDirectory) {
      const NumberOfKeys = geoKeys.length;
      const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];
      geoKeys.forEach((geoKey) => {
        const KeyID = Number(name2code[geoKey]);
        GeoKeyDirectory.push(KeyID);
        let Count;
        let TIFFTagLocation;
        let valueOffset;
        if (globals_js_1.fieldTagTypes[KeyID] === "SHORT") {
          Count = 1;
          TIFFTagLocation = 0;
          valueOffset = metadata[geoKey];
        } else if (geoKey === "GeogCitationGeoKey") {
          Count = metadata.GeoAsciiParams.length;
          TIFFTagLocation = Number(name2code.GeoAsciiParams);
          valueOffset = 0;
        } else {
          console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);
        }
        GeoKeyDirectory.push(TIFFTagLocation);
        GeoKeyDirectory.push(Count);
        GeoKeyDirectory.push(valueOffset);
      });
      metadata.GeoKeyDirectory = GeoKeyDirectory;
    }
    for (const geoKey in geoKeys) {
      if (geoKeys.hasOwnProperty(geoKey)) {
        delete metadata[geoKey];
      }
    }
    [
      "Compression",
      "ExtraSamples",
      "GeographicTypeGeoKey",
      "GTModelTypeGeoKey",
      "GTRasterTypeGeoKey",
      "ImageLength",
      "ImageWidth",
      "Orientation",
      "PhotometricInterpretation",
      "ProjectedCSTypeGeoKey",
      "PlanarConfiguration",
      "ResolutionUnit",
      "SamplesPerPixel",
      "XPosition",
      "YPosition"
    ].forEach((name) => {
      if (metadata[name]) {
        metadata[name] = toArray(metadata[name]);
      }
    });
    const encodedMetadata = convertToTids(metadata);
    const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);
    return outputImage;
  }
  geotiffwriter.writeGeotiff = writeGeotiff;
  return geotiffwriter;
}
var logging = {};
var hasRequiredLogging;
function requireLogging() {
  if (hasRequiredLogging)
    return logging;
  hasRequiredLogging = 1;
  Object.defineProperty(logging, "__esModule", { value: true });
  logging.timeEnd = logging.time = logging.error = logging.warn = logging.info = logging.log = logging.debug = logging.setLogger = void 0;
  class DummyLogger {
    log() {
    }
    debug() {
    }
    info() {
    }
    warn() {
    }
    error() {
    }
    time() {
    }
    timeEnd() {
    }
  }
  let LOGGER = new DummyLogger();
  function setLogger(logger = new DummyLogger()) {
    LOGGER = logger;
  }
  logging.setLogger = setLogger;
  function debug(...args) {
    return LOGGER.debug(...args);
  }
  logging.debug = debug;
  function log(...args) {
    return LOGGER.log(...args);
  }
  logging.log = log;
  function info(...args) {
    return LOGGER.info(...args);
  }
  logging.info = info;
  function warn(...args) {
    return LOGGER.warn(...args);
  }
  logging.warn = warn;
  function error(...args) {
    return LOGGER.error(...args);
  }
  logging.error = error;
  function time(...args) {
    return LOGGER.time(...args);
  }
  logging.time = time;
  function timeEnd(...args) {
    return LOGGER.timeEnd(...args);
  }
  logging.timeEnd = timeEnd;
  return logging;
}
var hasRequiredGeotiff;
function requireGeotiff() {
  if (hasRequiredGeotiff)
    return geotiff;
  hasRequiredGeotiff = 1;
  (function(exports2) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GeoTIFFImage = exports2.Pool = exports2.writeArrayBuffer = exports2.fromUrls = exports2.fromBlob = exports2.fromFile = exports2.fromArrayBuffer = exports2.fromUrl = exports2.MultiGeoTIFF = exports2.GeoTIFF = exports2.setLogger = exports2.addDecoder = exports2.getDecoder = exports2.BaseDecoder = exports2.rgb = exports2.globals = void 0;
    const geotiffimage_js_1 = __importDefault(requireGeotiffimage());
    exports2.GeoTIFFImage = geotiffimage_js_1.default;
    const dataview64_js_1 = __importDefault(requireDataview64());
    const dataslice_js_1 = __importDefault(requireDataslice());
    const pool_js_1 = __importDefault(requirePool());
    exports2.Pool = pool_js_1.default;
    const remote_js_1 = requireRemote();
    const arraybuffer_js_1 = requireArraybuffer();
    const filereader_js_1 = requireFilereader();
    const file_js_1 = requireFile();
    const globals_js_1 = requireGlobals();
    const geotiffwriter_js_1 = requireGeotiffwriter();
    const globals2 = __importStar(requireGlobals());
    exports2.globals = globals2;
    const rgb2 = __importStar(requireRgb());
    exports2.rgb = rgb2;
    const index_js_1 = requireCompression();
    Object.defineProperty(exports2, "getDecoder", { enumerable: true, get: function() {
      return index_js_1.getDecoder;
    } });
    Object.defineProperty(exports2, "addDecoder", { enumerable: true, get: function() {
      return index_js_1.addDecoder;
    } });
    const logging_js_1 = requireLogging();
    Object.defineProperty(exports2, "setLogger", { enumerable: true, get: function() {
      return logging_js_1.setLogger;
    } });
    var basedecoder_js_1 = requireBasedecoder();
    Object.defineProperty(exports2, "BaseDecoder", { enumerable: true, get: function() {
      return __importDefault(basedecoder_js_1).default;
    } });
    function getFieldTypeLength(fieldType) {
      switch (fieldType) {
        case globals_js_1.fieldTypes.BYTE:
        case globals_js_1.fieldTypes.ASCII:
        case globals_js_1.fieldTypes.SBYTE:
        case globals_js_1.fieldTypes.UNDEFINED:
          return 1;
        case globals_js_1.fieldTypes.SHORT:
        case globals_js_1.fieldTypes.SSHORT:
          return 2;
        case globals_js_1.fieldTypes.LONG:
        case globals_js_1.fieldTypes.SLONG:
        case globals_js_1.fieldTypes.FLOAT:
        case globals_js_1.fieldTypes.IFD:
          return 4;
        case globals_js_1.fieldTypes.RATIONAL:
        case globals_js_1.fieldTypes.SRATIONAL:
        case globals_js_1.fieldTypes.DOUBLE:
        case globals_js_1.fieldTypes.LONG8:
        case globals_js_1.fieldTypes.SLONG8:
        case globals_js_1.fieldTypes.IFD8:
          return 8;
        default:
          throw new RangeError(`Invalid field type: ${fieldType}`);
      }
    }
    function parseGeoKeyDirectory(fileDirectory) {
      const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;
      if (!rawGeoKeyDirectory) {
        return null;
      }
      const geoKeyDirectory = {};
      for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {
        const key = globals_js_1.geoKeyNames[rawGeoKeyDirectory[i]];
        const location = rawGeoKeyDirectory[i + 1] ? globals_js_1.fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;
        const count = rawGeoKeyDirectory[i + 2];
        const offset = rawGeoKeyDirectory[i + 3];
        let value = null;
        if (!location) {
          value = offset;
        } else {
          value = fileDirectory[location];
          if (typeof value === "undefined" || value === null) {
            throw new Error(`Could not get value of geoKey '${key}'.`);
          } else if (typeof value === "string") {
            value = value.substring(offset, offset + count - 1);
          } else if (value.subarray) {
            value = value.subarray(offset, offset + count);
            if (count === 1) {
              value = value[0];
            }
          }
        }
        geoKeyDirectory[key] = value;
      }
      return geoKeyDirectory;
    }
    function getValues2(dataSlice, fieldType, count, offset) {
      let values = null;
      let readMethod = null;
      const fieldTypeLength = getFieldTypeLength(fieldType);
      switch (fieldType) {
        case globals_js_1.fieldTypes.BYTE:
        case globals_js_1.fieldTypes.ASCII:
        case globals_js_1.fieldTypes.UNDEFINED:
          values = new Uint8Array(count);
          readMethod = dataSlice.readUint8;
          break;
        case globals_js_1.fieldTypes.SBYTE:
          values = new Int8Array(count);
          readMethod = dataSlice.readInt8;
          break;
        case globals_js_1.fieldTypes.SHORT:
          values = new Uint16Array(count);
          readMethod = dataSlice.readUint16;
          break;
        case globals_js_1.fieldTypes.SSHORT:
          values = new Int16Array(count);
          readMethod = dataSlice.readInt16;
          break;
        case globals_js_1.fieldTypes.LONG:
        case globals_js_1.fieldTypes.IFD:
          values = new Uint32Array(count);
          readMethod = dataSlice.readUint32;
          break;
        case globals_js_1.fieldTypes.SLONG:
          values = new Int32Array(count);
          readMethod = dataSlice.readInt32;
          break;
        case globals_js_1.fieldTypes.LONG8:
        case globals_js_1.fieldTypes.IFD8:
          values = new Array(count);
          readMethod = dataSlice.readUint64;
          break;
        case globals_js_1.fieldTypes.SLONG8:
          values = new Array(count);
          readMethod = dataSlice.readInt64;
          break;
        case globals_js_1.fieldTypes.RATIONAL:
          values = new Uint32Array(count * 2);
          readMethod = dataSlice.readUint32;
          break;
        case globals_js_1.fieldTypes.SRATIONAL:
          values = new Int32Array(count * 2);
          readMethod = dataSlice.readInt32;
          break;
        case globals_js_1.fieldTypes.FLOAT:
          values = new Float32Array(count);
          readMethod = dataSlice.readFloat32;
          break;
        case globals_js_1.fieldTypes.DOUBLE:
          values = new Float64Array(count);
          readMethod = dataSlice.readFloat64;
          break;
        default:
          throw new RangeError(`Invalid field type: ${fieldType}`);
      }
      if (!(fieldType === globals_js_1.fieldTypes.RATIONAL || fieldType === globals_js_1.fieldTypes.SRATIONAL)) {
        for (let i = 0; i < count; ++i) {
          values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);
        }
      } else {
        for (let i = 0; i < count; i += 2) {
          values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);
          values[i + 1] = readMethod.call(dataSlice, offset + (i * fieldTypeLength + 4));
        }
      }
      if (fieldType === globals_js_1.fieldTypes.ASCII) {
        return new TextDecoder("utf-8").decode(values);
      }
      return values;
    }
    class ImageFileDirectory {
      constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {
        this.fileDirectory = fileDirectory;
        this.geoKeyDirectory = geoKeyDirectory;
        this.nextIFDByteOffset = nextIFDByteOffset;
      }
    }
    class GeoTIFFImageIndexError extends Error {
      constructor(index) {
        super(`No image at index ${index}`);
        this.index = index;
      }
    }
    class GeoTIFFBase {
      /**
       * (experimental) Reads raster data from the best fitting image. This function uses
       * the image with the lowest resolution that is still a higher resolution than the
       * requested resolution.
       * When specified, the `bbox` option is translated to the `window` option and the
       * `resX` and `resY` to `width` and `height` respectively.
       * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected
       * image is called and the result returned.
       * @see GeoTIFFImage.readRasters
       * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters
       * @returns {Promise<(TypedArray|TypedArray[])>} the decoded arrays as a promise
       */
      async readRasters(options = {}) {
        const { window: imageWindow, width, height } = options;
        let { resX, resY, bbox } = options;
        const firstImage = await this.getImage();
        let usedImage = firstImage;
        const imageCount = await this.getImageCount();
        const imgBBox = firstImage.getBoundingBox();
        if (imageWindow && bbox) {
          throw new Error('Both "bbox" and "window" passed.');
        }
        if (width || height) {
          if (imageWindow) {
            const [oX, oY] = firstImage.getOrigin();
            const [rX, rY] = firstImage.getResolution();
            bbox = [
              oX + imageWindow[0] * rX,
              oY + imageWindow[1] * rY,
              oX + imageWindow[2] * rX,
              oY + imageWindow[3] * rY
            ];
          }
          const usedBBox = bbox || imgBBox;
          if (width) {
            if (resX) {
              throw new Error("Both width and resX passed");
            }
            resX = (usedBBox[2] - usedBBox[0]) / width;
          }
          if (height) {
            if (resY) {
              throw new Error("Both width and resY passed");
            }
            resY = (usedBBox[3] - usedBBox[1]) / height;
          }
        }
        if (resX || resY) {
          const allImages = [];
          for (let i = 0; i < imageCount; ++i) {
            const image = await this.getImage(i);
            const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;
            if (i === 0 || subfileType === 2 || newSubfileType & 1) {
              allImages.push(image);
            }
          }
          allImages.sort((a, b) => a.getWidth() - b.getWidth());
          for (let i = 0; i < allImages.length; ++i) {
            const image = allImages[i];
            const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();
            const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();
            usedImage = image;
            if (resX && resX > imgResX || resY && resY > imgResY) {
              break;
            }
          }
        }
        let wnd = imageWindow;
        if (bbox) {
          const [oX, oY] = firstImage.getOrigin();
          const [imageResX, imageResY] = usedImage.getResolution(firstImage);
          wnd = [
            Math.round((bbox[0] - oX) / imageResX),
            Math.round((bbox[1] - oY) / imageResY),
            Math.round((bbox[2] - oX) / imageResX),
            Math.round((bbox[3] - oY) / imageResY)
          ];
          wnd = [
            Math.min(wnd[0], wnd[2]),
            Math.min(wnd[1], wnd[3]),
            Math.max(wnd[0], wnd[2]),
            Math.max(wnd[1], wnd[3])
          ];
        }
        return usedImage.readRasters({ ...options, window: wnd });
      }
    }
    class GeoTIFF extends GeoTIFFBase {
      /**
       * @constructor
       * @param {*} source The datasource to read from.
       * @param {boolean} littleEndian Whether the image uses little endian.
       * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.
       * @param {number} firstIFDOffset The numeric byte-offset from the start of the image
       *                                to the first IFD.
       * @param {GeoTIFFOptions} [options] further options.
       */
      constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {
        super();
        this.source = source;
        this.littleEndian = littleEndian;
        this.bigTiff = bigTiff;
        this.firstIFDOffset = firstIFDOffset;
        this.cache = options.cache || false;
        this.ifdRequests = [];
        this.ghostValues = null;
      }
      async getSlice(offset, size) {
        const fallbackSize = this.bigTiff ? 4048 : 1024;
        return new dataslice_js_1.default((await this.source.fetch([{
          offset,
          length: typeof size !== "undefined" ? size : fallbackSize
        }]))[0], offset, this.littleEndian, this.bigTiff);
      }
      /**
       * Instructs to parse an image file directory at the given file offset.
       * As there is no way to ensure that a location is indeed the start of an IFD,
       * this function must be called with caution (e.g only using the IFD offsets from
       * the headers or other IFDs).
       * @param {number} offset the offset to parse the IFD at
       * @returns {Promise<ImageFileDirectory>} the parsed IFD
       */
      async parseFileDirectoryAt(offset) {
        const entrySize = this.bigTiff ? 20 : 12;
        const offsetSize = this.bigTiff ? 8 : 2;
        let dataSlice = await this.getSlice(offset);
        const numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset);
        const byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);
        if (!dataSlice.covers(offset, byteSize)) {
          dataSlice = await this.getSlice(offset, byteSize);
        }
        const fileDirectory = {};
        let i = offset + (this.bigTiff ? 8 : 2);
        for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {
          const fieldTag = dataSlice.readUint16(i);
          const fieldType = dataSlice.readUint16(i + 2);
          const typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);
          let fieldValues;
          let value;
          const fieldTypeLength = getFieldTypeLength(fieldType);
          const valueOffset = i + (this.bigTiff ? 12 : 8);
          if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {
            fieldValues = getValues2(dataSlice, fieldType, typeCount, valueOffset);
          } else {
            const actualOffset = dataSlice.readOffset(valueOffset);
            const length = getFieldTypeLength(fieldType) * typeCount;
            if (dataSlice.covers(actualOffset, length)) {
              fieldValues = getValues2(dataSlice, fieldType, typeCount, actualOffset);
            } else {
              const fieldDataSlice = await this.getSlice(actualOffset, length);
              fieldValues = getValues2(fieldDataSlice, fieldType, typeCount, actualOffset);
            }
          }
          if (typeCount === 1 && globals_js_1.arrayFields.indexOf(fieldTag) === -1 && !(fieldType === globals_js_1.fieldTypes.RATIONAL || fieldType === globals_js_1.fieldTypes.SRATIONAL)) {
            value = fieldValues[0];
          } else {
            value = fieldValues;
          }
          fileDirectory[globals_js_1.fieldTagNames[fieldTag]] = value;
        }
        const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);
        const nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);
        return new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset);
      }
      async requestIFD(index) {
        if (this.ifdRequests[index]) {
          return this.ifdRequests[index];
        } else if (index === 0) {
          this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);
          return this.ifdRequests[index];
        } else if (!this.ifdRequests[index - 1]) {
          try {
            this.ifdRequests[index - 1] = this.requestIFD(index - 1);
          } catch (e) {
            if (e instanceof GeoTIFFImageIndexError) {
              throw new GeoTIFFImageIndexError(index);
            }
            throw e;
          }
        }
        this.ifdRequests[index] = (async () => {
          const previousIfd = await this.ifdRequests[index - 1];
          if (previousIfd.nextIFDByteOffset === 0) {
            throw new GeoTIFFImageIndexError(index);
          }
          return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);
        })();
        return this.ifdRequests[index];
      }
      /**
       * Get the n-th internal subfile of an image. By default, the first is returned.
       *
       * @param {number} [index=0] the index of the image to return.
       * @returns {Promise<GeoTIFFImage>} the image at the given index
       */
      async getImage(index = 0) {
        const ifd = await this.requestIFD(index);
        return new geotiffimage_js_1.default(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);
      }
      /**
       * Returns the count of the internal subfiles.
       *
       * @returns {Promise<number>} the number of internal subfile images
       */
      async getImageCount() {
        let index = 0;
        let hasNext = true;
        while (hasNext) {
          try {
            await this.requestIFD(index);
            ++index;
          } catch (e) {
            if (e instanceof GeoTIFFImageIndexError) {
              hasNext = false;
            } else {
              throw e;
            }
          }
        }
        return index;
      }
      /**
       * Get the values of the COG ghost area as a parsed map.
       * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference
       * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found
       */
      async getGhostValues() {
        const offset = this.bigTiff ? 16 : 8;
        if (this.ghostValues) {
          return this.ghostValues;
        }
        const detectionString = "GDAL_STRUCTURAL_METADATA_SIZE=";
        const heuristicAreaSize = detectionString.length + 100;
        let slice = await this.getSlice(offset, heuristicAreaSize);
        if (detectionString === getValues2(slice, globals_js_1.fieldTypes.ASCII, detectionString.length, offset)) {
          const valuesString = getValues2(slice, globals_js_1.fieldTypes.ASCII, heuristicAreaSize, offset);
          const firstLine = valuesString.split("\n")[0];
          const metadataSize = Number(firstLine.split("=")[1].split(" ")[0]) + firstLine.length;
          if (metadataSize > heuristicAreaSize) {
            slice = await this.getSlice(offset, metadataSize);
          }
          const fullString = getValues2(slice, globals_js_1.fieldTypes.ASCII, metadataSize, offset);
          this.ghostValues = {};
          fullString.split("\n").filter((line) => line.length > 0).map((line) => line.split("=")).forEach(([key, value]) => {
            this.ghostValues[key] = value;
          });
        }
        return this.ghostValues;
      }
      /**
       * Parse a (Geo)TIFF file from the given source.
       *
       * @param {*} source The source of data to parse from.
       * @param {GeoTIFFOptions} [options] Additional options.
       * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
       *                               to be aborted
       */
      static async fromSource(source, options, signal) {
        const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];
        const dataView = new dataview64_js_1.default(headerData);
        const BOM = dataView.getUint16(0, 0);
        let littleEndian;
        if (BOM === 18761) {
          littleEndian = true;
        } else if (BOM === 19789) {
          littleEndian = false;
        } else {
          throw new TypeError("Invalid byte order value.");
        }
        const magicNumber = dataView.getUint16(2, littleEndian);
        let bigTiff;
        if (magicNumber === 42) {
          bigTiff = false;
        } else if (magicNumber === 43) {
          bigTiff = true;
          const offsetByteSize = dataView.getUint16(4, littleEndian);
          if (offsetByteSize !== 8) {
            throw new Error("Unsupported offset byte-size.");
          }
        } else {
          throw new TypeError("Invalid magic number.");
        }
        const firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);
        return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);
      }
      /**
       * Closes the underlying file buffer
       * N.B. After the GeoTIFF has been completely processed it needs
       * to be closed but only if it has been constructed from a file.
       */
      close() {
        if (typeof this.source.close === "function") {
          return this.source.close();
        }
        return false;
      }
    }
    exports2.GeoTIFF = GeoTIFF;
    exports2.default = GeoTIFF;
    class MultiGeoTIFF extends GeoTIFFBase {
      /**
       * Construct a new MultiGeoTIFF from a main and several overview files.
       * @param {GeoTIFF} mainFile The main GeoTIFF file.
       * @param {GeoTIFF[]} overviewFiles An array of overview files.
       */
      constructor(mainFile, overviewFiles) {
        super();
        this.mainFile = mainFile;
        this.overviewFiles = overviewFiles;
        this.imageFiles = [mainFile].concat(overviewFiles);
        this.fileDirectoriesPerFile = null;
        this.fileDirectoriesPerFileParsing = null;
        this.imageCount = null;
      }
      async parseFileDirectoriesPerFile() {
        const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map((file2) => file2.parseFileDirectoryAt(file2.firstIFDOffset)));
        this.fileDirectoriesPerFile = await Promise.all(requests);
        return this.fileDirectoriesPerFile;
      }
      /**
       * Get the n-th internal subfile of an image. By default, the first is returned.
       *
       * @param {number} [index=0] the index of the image to return.
       * @returns {Promise<GeoTIFFImage>} the image at the given index
       */
      async getImage(index = 0) {
        await this.getImageCount();
        await this.parseFileDirectoriesPerFile();
        let visited = 0;
        let relativeIndex = 0;
        for (let i = 0; i < this.imageFiles.length; i++) {
          const imageFile = this.imageFiles[i];
          for (let ii = 0; ii < this.imageCounts[i]; ii++) {
            if (index === visited) {
              const ifd = await imageFile.requestIFD(relativeIndex);
              return new geotiffimage_js_1.default(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source);
            }
            visited++;
            relativeIndex++;
          }
          relativeIndex = 0;
        }
        throw new RangeError("Invalid image index");
      }
      /**
       * Returns the count of the internal subfiles.
       *
       * @returns {Promise<number>} the number of internal subfile images
       */
      async getImageCount() {
        if (this.imageCount !== null) {
          return this.imageCount;
        }
        const requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map((file2) => file2.getImageCount()));
        this.imageCounts = await Promise.all(requests);
        this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);
        return this.imageCount;
      }
    }
    exports2.MultiGeoTIFF = MultiGeoTIFF;
    async function fromUrl(url, options = {}, signal) {
      return GeoTIFF.fromSource((0, remote_js_1.makeRemoteSource)(url, options), signal);
    }
    exports2.fromUrl = fromUrl;
    async function fromArrayBuffer(arrayBuffer, signal) {
      return GeoTIFF.fromSource((0, arraybuffer_js_1.makeBufferSource)(arrayBuffer), signal);
    }
    exports2.fromArrayBuffer = fromArrayBuffer;
    async function fromFile(path, signal) {
      return GeoTIFF.fromSource((0, file_js_1.makeFileSource)(path), signal);
    }
    exports2.fromFile = fromFile;
    async function fromBlob(blob, signal) {
      return GeoTIFF.fromSource((0, filereader_js_1.makeFileReaderSource)(blob), signal);
    }
    exports2.fromBlob = fromBlob;
    async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {
      const mainFile = await GeoTIFF.fromSource((0, remote_js_1.makeRemoteSource)(mainUrl, options), signal);
      const overviewFiles = await Promise.all(overviewUrls.map((url) => GeoTIFF.fromSource((0, remote_js_1.makeRemoteSource)(url, options))));
      return new MultiGeoTIFF(mainFile, overviewFiles);
    }
    exports2.fromUrls = fromUrls;
    function writeArrayBuffer(values, metadata) {
      return (0, geotiffwriter_js_1.writeGeotiff)(values, metadata);
    }
    exports2.writeArrayBuffer = writeArrayBuffer;
  })(geotiff);
  return geotiff;
}
var hasRequiredCOGProvider;
function requireCOGProvider() {
  if (hasRequiredCOGProvider)
    return COGProvider;
  hasRequiredCOGProvider = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(COGProvider, "__esModule", {
    value: true
  });
  COGProvider.default = void 0;
  var _regenerator = _interopRequireDefault2(requireRegenerator());
  var _asyncToGenerator2 = _interopRequireDefault2(requireAsyncToGenerator());
  var _slicedToArray2 = _interopRequireDefault2(requireSlicedToArray());
  var _three2 = require$$8$1;
  var _geotiff = requireGeotiff();
  var _Cache = _interopRequireDefault2(requireCache());
  var _c3DEngine2 = _interopRequireDefault2(requireC3DEngine());
  var _ColorLayer = _interopRequireDefault2(requireColorLayer());
  function getMinMax(v, nodata) {
    var min = Infinity;
    var max = -Infinity;
    for (var i = 0, l = v.length; i < l; i++) {
      var value = v[i];
      if (value !== nodata) {
        min = Math.min(value, min);
        max = Math.max(value, max);
      }
    }
    return {
      min,
      max
    };
  }
  function makeWindowFromExtent(layer, extent2, resolution) {
    var _layer$origin = (0, _slicedToArray2.default)(layer.origin, 2), oX = _layer$origin[0], oY = _layer$origin[1];
    var _resolution = (0, _slicedToArray2.default)(resolution, 2), imageResX = _resolution[0], imageResY = _resolution[1];
    var ext = extent2._values;
    var wnd = [Math.round((ext[0] - oX) / imageResX), Math.round((ext[2] - oY) / imageResY), Math.round((ext[1] - oX) / imageResX), Math.round((ext[3] - oY) / imageResY)];
    return [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];
  }
  function processSmallestOverview() {
    return _processSmallestOverview.apply(this, arguments);
  }
  function _processSmallestOverview() {
    _processSmallestOverview = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(layer, levelImage) {
      var arrayData, _getMinMax, min, max, result, _processData2, data, width, height, key;
      return _regenerator.default.wrap(function(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return levelImage.image.readRasters({
                window: makeWindowFromExtent(layer, layer.extent, levelImage.resolution),
                fillValue: layer.nodata
              });
            case 2:
              arrayData = _context2.sent;
              _getMinMax = getMinMax(arrayData[0], layer.nodata), min = _getMinMax.min, max = _getMinMax.max;
              layer.dataMin = min;
              layer.dataMax = max;
              result = {
                pitch: new _three2.Vector4(0, 0, 1, 1),
                texture: new _three2.Texture()
              };
              _processData2 = processData(layer, arrayData), data = _processData2.data, width = _processData2.width, height = _processData2.height;
              result.texture.image = _c3DEngine2.default.bufferToImage(data, width, height);
              result.texture.extent = layer.extent;
              key = "".concat(layer.id).concat(layer.extent._values.join(","));
              _Cache.default.set(key, result);
            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee);
    }));
    return _processSmallestOverview.apply(this, arguments);
  }
  function getImages() {
    return _getImages.apply(this, arguments);
  }
  function _getImages() {
    _getImages = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(layer) {
      var tiff, count, firstImage, image, levelImage, i;
      return _regenerator.default.wrap(function(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return (0, _geotiff.fromUrl)(layer.source.url);
            case 2:
              tiff = _context2.sent;
              _context2.next = 5;
              return tiff.getImageCount();
            case 5:
              count = _context2.sent;
              _context2.next = 8;
              return tiff.getImage();
            case 8:
              firstImage = _context2.sent;
              layer.origin = firstImage.getOrigin();
              layer.nodata = firstImage.getGDALNoData();
              layer.images = [{
                image: firstImage,
                width: firstImage.getWidth(),
                height: firstImage.getHeight(),
                resolution: firstImage.getResolution()
              }];
              i = 1;
            case 13:
              if (!(i < count)) {
                _context2.next = 22;
                break;
              }
              _context2.next = 16;
              return tiff.getImage(i);
            case 16:
              image = _context2.sent;
              levelImage = {
                image,
                width: image.getWidth(),
                height: image.getHeight(),
                resolution: image.getResolution(firstImage)
              };
              layer.images.push(levelImage);
            case 19:
              i++;
              _context2.next = 13;
              break;
            case 22:
              if (!(image.getSamplesPerPixel() === 1)) {
                _context2.next = 25;
                break;
              }
              _context2.next = 25;
              return processSmallestOverview(layer, levelImage);
            case 25:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _getImages.apply(this, arguments);
  }
  function preprocessDataLayer(layer) {
    layer.pool = new _geotiff.Pool();
    layer.imageSize = {
      w: 256,
      h: 256
    };
    layer.dimension = layer.extent.dimensions();
    return getImages(layer);
  }
  function getPossibleTextureImprovements(layer, extent2, texture) {
    if (texture && texture.extent && texture.extent.isInside(extent2)) {
      return null;
    }
    var overviewCount = layer.images.length - 1;
    var extentDimension = extent2.dimensions();
    var widthRatio = extentDimension.x / layer.dimension.x;
    var heightRatio = extentDimension.y / layer.dimension.y;
    var level = overviewCount;
    var levelImage = layer.images[level];
    var tileWidth = levelImage.width * widthRatio;
    var tileHeight = levelImage.height * heightRatio;
    while (level > 0 && tileWidth < layer.imageSize.w && tileHeight < layer.imageSize.h) {
      level--;
      levelImage = layer.images[level];
      tileWidth = levelImage.width * widthRatio;
      tileHeight = levelImage.height * heightRatio;
    }
    return {
      extent: extent2,
      levelImage
    };
  }
  function processData(layer, arrayData) {
    var width = arrayData.width, height = arrayData.height;
    var data = new Uint8ClampedArray(width * height * 4);
    if (arrayData.length === 3) {
      var _arrayData = (0, _slicedToArray2.default)(arrayData, 3), r = _arrayData[0], g = _arrayData[1], b = _arrayData[2];
      for (var i = 0, l = r.length; i < l; i++) {
        var i4 = i * 4;
        data[i4 + 0] = r[i];
        data[i4 + 1] = g[i];
        data[i4 + 2] = b[i];
        data[i4 + 3] = 255;
      }
    } else {
      if (arrayData.length !== 1) {
        console.warn("Band selection isn't implemented yet.", "Processing the first one as if it was a 1-band file.");
      }
      var _arrayData2 = (0, _slicedToArray2.default)(arrayData, 1), v = _arrayData2[0];
      var nodata = layer.nodata;
      var dataMin = layer.dataMin;
      var dataFactor = 255 / (layer.dataMax - dataMin);
      for (var _i = 0, _l = v.length; _i < _l; _i++) {
        var vi = v[_i];
        var value = Math.round((vi - dataMin) * dataFactor);
        var _i2 = _i * 4;
        data[_i2 + 0] = value;
        data[_i2 + 1] = value;
        data[_i2 + 2] = value;
        data[_i2 + 3] = vi === nodata ? 0 : 255;
      }
    }
    return {
      data,
      width,
      height
    };
  }
  function executeCommand(command) {
    var layer = command.layer;
    var requester = command.requester;
    var key = "".concat(layer.id).concat(requester.extent._values.join(","));
    var result = _Cache.default.get(key);
    if (result) {
      return Promise.resolve(result);
    }
    result = {
      pitch: new _three2.Vector4(0, 0, 1, 1),
      texture: new _three2.Texture()
    };
    var _command$toDownload = command.toDownload, extent2 = _command$toDownload.extent, levelImage = _command$toDownload.levelImage;
    return levelImage.image.readRasters({
      pool: layer.pool,
      // Use the pool of workers to decode faster
      window: makeWindowFromExtent(layer, extent2, levelImage.resolution),
      fillValue: layer.nodata
    }).then(function(arrayData) {
      if (layer instanceof _ColorLayer.default) {
        var _processData = processData(layer, arrayData), data = _processData.data, width = _processData.width, height = _processData.height;
        result.texture.image = _c3DEngine2.default.bufferToImage(data, width, height);
        result.texture.extent = requester.extent;
        _Cache.default.set(key, result);
        return result;
      }
      throw new Error("Elevation support for COG not yet implemented");
    }).catch(function(error) {
      if (error.toString() === "AggregateError: Request failed") {
        return result;
      }
      throw new Error(error);
    });
  }
  function tileInsideLimit(tile, layer) {
    var extent2 = tile.getExtentForLayer(layer);
    return extent2.isInside(layer.extent);
  }
  var _default2 = {
    executeCommand,
    getPossibleTextureImprovements,
    preprocessDataLayer,
    tileInsideLimit
  };
  COGProvider.default = _default2;
  return COGProvider;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler)
    return Scheduler;
  hasRequiredScheduler = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(Scheduler, "__esModule", {
    value: true
  });
  Scheduler.default = void 0;
  var _jsPriorityQueue = _interopRequireDefault2(requirePriorityQueue());
  var _TileState = _interopRequireDefault2(require$$2$1);
  var _TileProvider = _interopRequireDefault2(requireTileProvider());
  var _dTilesProvider = _interopRequireDefault2(require_3dTilesProvider());
  var _TMSProvider = _interopRequireDefault2(requireTMSProvider());
  var _PointCloudProvider = _interopRequireDefault2(requirePointCloudProvider());
  var _CustomTiledImageProvider = _interopRequireDefault2(requireCustomTiledImageProvider());
  var _OLTileProvider = _interopRequireDefault2(requireOLTileProvider());
  var _OLVectorTileProvider = _interopRequireDefault2(requireOLVectorTileProvider());
  var _OLVectorProvider = _interopRequireDefault2(requireOLVectorProvider());
  var _COGProvider = _interopRequireDefault2(requireCOGProvider());
  var _CancelledCommandException = _interopRequireDefault2(requireCancelledCommandException());
  var _Cache = _interopRequireDefault2(requireCache());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function queueOrdering(a, b) {
    var cmp = b.priority - a.priority;
    if (cmp === 0) {
      return b.timestamp - a.timestamp;
    }
    return cmp;
  }
  function drawNextLayer(storages) {
    var sum = 0;
    var selected;
    var max;
    var _iterator = _createForOfIteratorHelper2(storages), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item = _step.value;
        var st = item[1];
        if (st.q.length > 0) {
          sum += st.priority;
          st.accumulator += st.priority;
          if (!selected || st.accumulator > max) {
            selected = st;
            max = st.accumulator;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (selected) {
      selected.accumulator -= sum;
      return selected.q;
    }
    return null;
  }
  function _instanciateQueue() {
    return {
      queue: function queue(command) {
        var layer = command.layer;
        var st = this.storages.get(layer.id);
        if (!st) {
          st = {
            q: new _jsPriorityQueue.default({
              comparator: queueOrdering
            }),
            priority: 1,
            accumulator: 0
          };
          this.storages.set(layer.id, st);
        }
        st.priority = layer.priority || 1;
        st.q.queue(command);
        this.counters.pending++;
      },
      storages: /* @__PURE__ */ new Map(),
      counters: {
        // commands in progress
        executing: 0,
        // commands successfully executed
        executed: 0,
        // commands failed
        failed: 0,
        // commands cancelled
        cancelled: 0,
        // commands pending
        pending: 0
      },
      execute: function execute(cmd, provider) {
        var _this = this;
        var countersIncrement = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        this.counters.pending -= countersIncrement;
        this.counters.executing += countersIncrement;
        return provider.executeCommand(cmd).then(function(result) {
          _this.counters.executing -= countersIncrement;
          cmd.resolve(result);
          _this.counters.executed += countersIncrement;
        }, function(err) {
          _this.counters.executing -= countersIncrement;
          cmd.reject(err);
          _this.counters.failed += countersIncrement;
          if (_this.counters.failed < 3) {
            console.error(err);
          }
        });
      }
    };
  }
  function Scheduler$1() {
    this.defaultQueue = _instanciateQueue();
    this.hostQueues = /* @__PURE__ */ new Map();
    this.providers = {};
    this.maxCommandsPerHost = 6;
    this.initDefaultProviders();
  }
  Scheduler$1.prototype.constructor = Scheduler$1;
  Scheduler$1.prototype.initDefaultProviders = function() {
    this.addProtocolProvider("tile", _TileProvider.default);
    this.addProtocolProvider("3d-tiles", _dTilesProvider.default);
    this.addProtocolProvider("tms", _TMSProvider.default);
    this.addProtocolProvider("xyz", _TMSProvider.default);
    this.addProtocolProvider("potreeconverter", _PointCloudProvider.default);
    this.addProtocolProvider("customtiledimage", _CustomTiledImageProvider.default);
    this.addProtocolProvider("oltile", _OLTileProvider.default);
    this.addProtocolProvider("olvectortile", _OLVectorTileProvider.default);
    this.addProtocolProvider("olvector", _OLVectorProvider.default);
    this.addProtocolProvider("cog", _COGProvider.default);
  };
  Scheduler$1.prototype.runCommand = function(command, queue) {
    var _this2 = this;
    var recurse = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var provider = this.providers[command.layer.protocol];
    if (!provider) {
      throw new Error("No known provider for layer", command.layer.id);
    }
    return queue.execute(command, provider, recurse ? 1 : 0).then(function() {
      command.view.notifyChange(command.requester, command.redraw);
      if (recurse) {
        _this2.flush(queue, command.layer.id);
      }
      if (recurse && queue.counters.executing < _this2.maxCommandsPerHost) {
        var cmd = _this2.deQueue(queue);
        if (cmd) {
          _this2.runCommand(cmd, queue);
        }
      }
    });
  };
  Scheduler$1.prototype.execute = function(command) {
    var layer = command.layer;
    var host = layer.url ? new URL(layer.url, document.location).host : void 0;
    command.promise = new Promise(function(resolve, reject) {
      command.resolve = resolve;
      command.reject = reject;
    });
    if (host && !this.hostQueues.has(host)) {
      this.hostQueues.set(host, _instanciateQueue());
    }
    var q = host ? this.hostQueues.get(host) : this.defaultQueue;
    if (isInCache(command)) {
      this.runCommand(command, q, false);
    } else {
      q.queue(command);
    }
    this.executeNextForQueue(q);
    return command.promise;
  };
  function isInCache(command) {
    if (!command.toDownload) {
      return false;
    }
    if (command.url) {
      return !!_Cache.default.get(command.url);
    }
    if (command.tile) {
      return command.tile.getState() === _TileState.default.LOADED;
    }
    return false;
  }
  Scheduler$1.prototype.flush = function(queue, layerId) {
    var _this3 = this;
    if (layerId) {
      var flushed = [];
      var store = queue.storages.get(layerId);
      for (var i = 0; i < store.q.priv.data.length; i++) {
        var cmd = store.q.priv.data[i];
        if (isInCache(cmd)) {
          flushed.push(this.runCommand(cmd, queue, false));
          store.q.priv.data.splice(i, 1);
          store.q.length--;
          i--;
        }
      }
      if (flushed.length) {
        Promise.all(flushed).then(function() {
          _this3.executeNextForQueue(queue);
        });
      }
    }
  };
  Scheduler$1.prototype.executeNextForQueue = function(queue) {
    var _this4 = this;
    if (queue.counters.executing < this.maxCommandsPerHost) {
      Promise.resolve().then(function() {
        if (queue.counters.executing < _this4.maxCommandsPerHost) {
          var cmd = _this4.deQueue(queue);
          if (cmd) {
            _this4.runCommand(cmd, queue);
          }
        }
      });
    }
  };
  Scheduler$1.prototype.addProtocolProvider = function(protocol, provider) {
    if (typeof provider.executeCommand !== "function") {
      throw new Error("Can't add provider for ".concat(protocol, ": missing a executeCommand function."));
    }
    if (typeof provider.preprocessDataLayer !== "function") {
      throw new Error("Can't add provider for ".concat(protocol, ": missing a preprocessDataLayer function."));
    }
    this.providers[protocol] = provider;
  };
  Scheduler$1.prototype.getProtocolProvider = function(protocol) {
    return this.providers[protocol];
  };
  Scheduler$1.prototype.commandsWaitingExecutionCount = function() {
    var sum = this.defaultQueue.counters.pending + this.defaultQueue.counters.executing;
    var _iterator2 = _createForOfIteratorHelper2(this.hostQueues), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var q = _step2.value;
        sum += q[1].counters.pending + q[1].counters.executing;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return sum;
  };
  Scheduler$1.prototype.commandsRunningCount = function() {
    var sum = this.defaultQueue.counters.executing;
    var _iterator3 = _createForOfIteratorHelper2(this.hostQueues), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var q = _step3.value;
        sum += q[1].counters.executing;
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return sum;
  };
  Scheduler$1.prototype.resetCommandsCount = function(type) {
    var sum = this.defaultQueue.counters[type];
    this.defaultQueue.counters[type] = 0;
    var _iterator4 = _createForOfIteratorHelper2(this.hostQueues), _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
        var q = _step4.value;
        sum += q[1].counters[type];
        q[1].counters[type] = 0;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    return sum;
  };
  Scheduler$1.prototype.deQueue = function(queue) {
    var st = drawNextLayer(queue.storages);
    while (st && st.length > 0) {
      var cmd = st.dequeue();
      if (cmd.earlyDropFunction && cmd.earlyDropFunction(cmd)) {
        queue.counters.pending--;
        queue.counters.cancelled++;
        cmd.reject(new _CancelledCommandException.default(cmd));
      } else {
        return cmd;
      }
    }
    if (st) {
      return this.deQueue(queue);
    }
    return null;
  };
  var _default2 = Scheduler$1;
  Scheduler.default = _default2;
  return Scheduler;
}
var OlFeature2Mesh = {};
var earcutExports = {};
var earcut = {
  get exports() {
    return earcutExports;
  },
  set exports(v) {
    earcutExports = v;
  }
};
var hasRequiredEarcut;
function requireEarcut() {
  if (hasRequiredEarcut)
    return earcutExports;
  hasRequiredEarcut = 1;
  earcut.exports = earcut$1;
  earcutExports.default = earcut$1;
  function earcut$1(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList2(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked2(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList2(data, start2, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea2(data, start2, end, dim) > 0) {
      for (i = start2; i < end; i += dim)
        last = insertNode2(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start2; i -= dim)
        last = insertNode2(i, data[i], data[i + 1], last);
    }
    if (last && equals2(last, last.next)) {
      removeNode2(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints2(start2, end) {
    if (!start2)
      return start2;
    if (!end)
      end = start2;
    var p = start2, again;
    do {
      again = false;
      if (!p.steiner && (equals2(p, p.next) || area2(p.prev, p, p.next) === 0)) {
        removeNode2(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve2(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode2(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
          earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut2(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar2(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area2(a, b, c) >= 0)
      return false;
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed2(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area2(a, b, c) >= 0)
      return false;
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var minZ = zOrder2(x0, y0, minX, minY, invSize), maxZ = zOrder2(x1, y1, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections2(start2, triangles, dim) {
    var p = start2;
    do {
      var a = p.prev, b = p.next.next;
      if (!equals2(a, b) && intersects2(a, p, p.next, b) && locallyInside2(a, b) && locallyInside2(b, a)) {
        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0);
        removeNode2(p);
        removeNode2(p.next);
        p = start2 = b;
      }
      p = p.next;
    } while (p !== start2);
    return filterPoints2(p);
  }
  function splitEarcut2(start2, triangles, dim, minX, minY, invSize) {
    var a = start2;
    do {
      var b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal2(a, b)) {
          var c = splitPolygon2(a, b);
          a = filterPoints2(a, a.next);
          c = filterPoints2(c, c.next);
          earcutLinked2(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked2(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start2);
  }
  function eliminateHoles2(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start2, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start2 = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList2(data, start2, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost2(list));
    }
    queue.sort(compareX2);
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole2(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareX2(a, b) {
    return a.x - b.x;
  }
  function eliminateHole2(hole, outerNode) {
    var bridge = findHoleBridge2(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    var bridgeReverse = splitPolygon2(bridge, hole);
    filterPoints2(bridgeReverse, bridgeReverse.next);
    return filterPoints2(bridge, bridge.next);
  }
  function findHoleBridge2(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx)
            return m;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside2(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector2(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector2(m, p) {
    return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
  }
  function indexCurve2(start2, minX, minY, invSize) {
    var p = start2;
    do {
      if (p.z === 0)
        p.z = zOrder2(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start2);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked2(p);
  }
  function sortLinked2(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder2(x, y, minX, minY, invSize) {
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost2(start2) {
    var p = start2, leftmost = start2;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start2);
    return leftmost;
  }
  function pointInTriangle2(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
  }
  function isValidDiagonal2(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon2(a, b) && // dones't intersect other edges
    (locallyInside2(a, b) && locallyInside2(b, a) && middleInside2(a, b) && // locally visible
    (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || // does not create opposite-facing sectors
    equals2(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
  }
  function area2(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals2(p12, p22) {
    return p12.x === p22.x && p12.y === p22.y;
  }
  function intersects2(p12, q1, p22, q2) {
    var o1 = sign2(area2(p12, q1, p22));
    var o2 = sign2(area2(p12, q1, q2));
    var o3 = sign2(area2(p22, q2, p12));
    var o4 = sign2(area2(p22, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment2(p12, p22, q1))
      return true;
    if (o2 === 0 && onSegment2(p12, q2, q1))
      return true;
    if (o3 === 0 && onSegment2(p22, p12, q2))
      return true;
    if (o4 === 0 && onSegment2(p22, q1, q2))
      return true;
    return false;
  }
  function onSegment2(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign2(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon2(a, b) {
    var p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside2(a, b) {
    return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
  }
  function middleInside2(a, b) {
    var p = a, inside = false, px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
      if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon2(a, b) {
    var a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode2(i, x, y, last) {
    var p = new Node2(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode2(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node2(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = 0;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  earcut$1.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea2(data, 0, outerLen, dim));
    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start2 = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea2(data, start2, end, dim));
      }
    }
    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
      var a = triangles[i] * dim;
      var b = triangles[i + 1] * dim;
      var c = triangles[i + 2] * dim;
      trianglesArea += Math.abs(
        (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
      );
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };
  function signedArea2(data, start2, end, dim) {
    var sum = 0;
    for (var i = start2, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  earcut$1.flatten = function(data) {
    var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++)
          result.vertices.push(data[i][j][d]);
      }
      if (i > 0) {
        holeIndex += data[i - 1].length;
        result.holes.push(holeIndex);
      }
    }
    return result;
  };
  return earcutExports;
}
var hasRequiredOlFeature2Mesh;
function requireOlFeature2Mesh() {
  if (hasRequiredOlFeature2Mesh)
    return OlFeature2Mesh;
  hasRequiredOlFeature2Mesh = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  Object.defineProperty(OlFeature2Mesh, "__esModule", {
    value: true
  });
  OlFeature2Mesh.default = void 0;
  var _three2 = require$$8$1;
  var _earcut = _interopRequireDefault2(requireEarcut());
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function getProperty(name, options, defaultValue) {
    var property = options[name];
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }
    if (property) {
      if (typeof property === "function") {
        return property.apply(void 0, args);
      }
      return property;
    }
    if (typeof defaultValue === "function") {
      return defaultValue.apply(void 0, args);
    }
    return defaultValue;
  }
  function randomColor() {
    var color = new _three2.Color();
    color.setHex(Math.random() * 16777215);
    return color;
  }
  function fillColorArray(colors, length, r, g, b, offset) {
    for (var i = offset; i < offset + length; ++i) {
      colors[3 * i] = r;
      colors[3 * i + 1] = g;
      colors[3 * i + 2] = b;
    }
  }
  function prepareBufferGeometry(geom, color, altitude) {
    var vertices = new Float32Array(3 * geom.flatCoordinates.length / geom.stride);
    var colors = new Uint8Array(3 * geom.flatCoordinates.length);
    for (var i = 0; i < geom.flatCoordinates.length / geom.stride; i++) {
      var j = 0;
      for (; j < geom.stride; j++) {
        vertices[3 * i + j] = geom.flatCoordinates[geom.stride * i + j];
      }
      if (geom.stride === 2) {
        vertices[3 * i + 2] = Array.isArray(altitude) ? altitude[i] : altitude;
      }
    }
    fillColorArray(colors, geom.flatCoordinates.length, color.r * 255, color.g * 255, color.b * 255, 0);
    var threeGeom = new _three2.BufferGeometry();
    threeGeom.setAttribute("position", new _three2.BufferAttribute(vertices, 3));
    threeGeom.setAttribute("color", new _three2.BufferAttribute(colors, 3, true));
    threeGeom.computeBoundingSphere();
    return threeGeom;
  }
  function featureToPoint(feature, properties, options) {
    var altitude = getProperty("altitude", options, 0, properties, feature);
    var color = getProperty("color", options, randomColor, feature.getProperties());
    var geom = feature.getGeometry();
    var threeGeom = prepareBufferGeometry(geom, color, altitude);
    return new _three2.Points(threeGeom);
  }
  function featureToLine(feature, properties, options) {
    var altitude = getProperty("altitude", options, 0, properties, feature);
    var color = getProperty("color", options, randomColor, feature.getProperties());
    var geom = feature.getGeometry();
    var threeGeom = prepareBufferGeometry(geom, color, altitude);
    return new _three2.Line(threeGeom);
  }
  function featureToPolygon(feature, properties, options) {
    var altitude = getProperty("altitude", options, 0, feature);
    var color = getProperty("color", options, randomColor, feature.getProperties());
    var geom = feature.getGeometry();
    var threeGeom = prepareBufferGeometry(geom, color, altitude);
    var ends = geom.getEnds().map(function(end) {
      return end / geom.stride;
    });
    var triangles = (0, _earcut.default)(threeGeom.attributes.position.array, ends.slice(0, -1), 3);
    threeGeom.setIndex(new _three2.BufferAttribute(new Uint16Array(triangles), 1));
    return new _three2.Mesh(threeGeom);
  }
  function featureToMultiPolygon(feature, properties, options) {
    var altitude = getProperty("altitude", options, 0, feature);
    var color = getProperty("color", options, randomColor, feature.getProperties());
    var geom = feature.getGeometry();
    var threeGeom = prepareBufferGeometry(geom, color, altitude);
    var indices = [];
    var start2 = 0;
    var mapTriangle = function mapTriangle2(i) {
      return i + start2;
    };
    var normalizingEndsFn = function normalizingEndsFn2(end) {
      return end / geom.stride - start2;
    };
    var _iterator = _createForOfIteratorHelper2(geom.getEndss()), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var ends = _step.value;
        var polyNormEnd = ends[ends.length - 1] / geom.stride;
        var normalizedEnds = ends.map(normalizingEndsFn);
        var triangles = (0, _earcut.default)(threeGeom.attributes.position.array.slice(start2 * 3, polyNormEnd * 3), normalizedEnds.slice(0, -1), 3);
        indices = indices.concat(triangles.map(mapTriangle));
        start2 = polyNormEnd;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    threeGeom.setIndex(new _three2.BufferAttribute(new Uint16Array(indices), 1));
    return new _three2.Mesh(threeGeom);
  }
  function featureToMesh(feature, options) {
    var mesh;
    switch (feature.getGeometry().getType()) {
      case "Point":
      case "MultiPoint": {
        mesh = featureToPoint(feature, feature.properties, options);
        break;
      }
      case "LineString":
      case "MultiLineString": {
        mesh = featureToLine(feature, feature.properties, options);
        break;
      }
      case "Polygon":
        mesh = featureToPolygon(feature, feature.properties, options);
        break;
      case "MultiPolygon": {
        mesh = featureToMultiPolygon(feature, feature.properties, options);
        break;
      }
    }
    mesh.material.vertexColors = true;
    mesh.material.color = new _three2.Color(16777215);
    mesh.properties = feature.properties;
    return mesh;
  }
  function featuresToThree(features, options) {
    if (!features || features.length === 0)
      return null;
    if (features.length === 1) {
      return featureToMesh(features[0], options);
    }
    var group = new _three2.Group();
    group.minAltitude = Infinity;
    var _iterator2 = _createForOfIteratorHelper2(features), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var feature = _step2.value;
        var mesh = featureToMesh(feature, options);
        group.add(mesh);
        group.minAltitude = Math.min(mesh.minAltitude, group.minAltitude);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return group;
  }
  var _default2 = {
    /**
     * Return a function that converts [Features]{@link module:GeoJsonParser} to Meshes. Feature
     * collection will be converted to a
     * a Group.
     *
     * @param {object} options options controlling the conversion
     * @param {number|Function} options.altitude define the base altitude of the mesh
     * @param {number|Function} options.extrude if defined, polygons will be extruded by the
     * specified amount
     * @param {object|Function} options.color define per feature color
     * @returns {Function} the conversion function
     */
    convert: function convert() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return function _convert(collection) {
        if (!collection)
          return null;
        return featuresToThree(collection, options);
      };
    }
  };
  OlFeature2Mesh.default = _default2;
  return OlFeature2Mesh;
}
var _interopRequireDefault$1 = interopRequireDefaultExports;
var _typeof = _typeofExports;
Object.defineProperty(Instance$1, "__esModule", {
  value: true
});
var default_1$1 = Instance$1.default = Instance$1.INSTANCE_EVENTS = void 0;
var _classCallCheck2$1 = _interopRequireDefault$1(requireClassCallCheck());
var _createClass2$1 = _interopRequireDefault$1(requireCreateClass());
var _assertThisInitialized2 = _interopRequireDefault$1(requireAssertThisInitialized());
var _inherits2 = _interopRequireDefault$1(requireInherits());
var _possibleConstructorReturn2 = _interopRequireDefault$1(requirePossibleConstructorReturn());
var _getPrototypeOf2 = _interopRequireDefault$1(requireGetPrototypeOf());
var _three = require$$8$1;
var _proj = _interopRequireDefault$1(require$$9$1);
var _proj2 = require$$10$1;
var _Camera = _interopRequireDefault$1(requireCamera());
var _MainLoop = _interopRequireWildcard(requireMainLoop());
var _c3DEngine = _interopRequireDefault$1(requireC3DEngine());
var _LayerUpdateStrategy = requireLayerUpdateStrategy();
var _Layer = _interopRequireWildcard(requireLayer());
var _Entity3D = _interopRequireDefault$1(requireEntity3D());
var _Scheduler = _interopRequireDefault$1(requireScheduler());
var _Picking = _interopRequireDefault$1(requirePicking());
var _OlFeature2Mesh = _interopRequireDefault$1(requireOlFeature2Mesh());
var _ObjectRemovalHelper = _interopRequireDefault$1(requireObjectRemovalHelper());
_interopRequireDefault$1(requireEntity());
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache2 = _getRequireWildcardCache(nodeInterop);
  if (cache2 && cache2.has(obj)) {
    return cache2.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache2) {
    cache2.set(obj, newObj);
  }
  return newObj;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function() {
    var Super = (0, _getPrototypeOf2.default)(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return (0, _possibleConstructorReturn2.default)(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var INSTANCE_EVENTS = {
  /**
   * Fires when all the layers of the instance are considered initialized.
   * Initialized in this context means: all layers are ready to be
   * displayed (no pending network access, no visual improvement to be
   * expected, ...).
   * If you add new layers, the event will be fired again when all
   * layers are ready.
   *
   * @api
   * @event Instance#layers-initialized
   */
  LAYERS_INITIALIZED: "layers-initialized"
};
Instance$1.INSTANCE_EVENTS = INSTANCE_EVENTS;
var _eventCoords = new _three.Vector2();
var Instance = /* @__PURE__ */ function(_EventDispatcher) {
  (0, _inherits2.default)(Instance2, _EventDispatcher);
  var _super = _createSuper(Instance2);
  function Instance2(viewerDiv) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _classCallCheck2$1.default)(this, Instance2);
    _this = _super.call(this);
    _three.Object3D.DefaultUp.set(0, 0, 1);
    if (!viewerDiv) {
      throw new Error("Invalid viewerDiv parameter (must non be null/undefined)");
    }
    _this.referenceCrs = options.crs || "EPSG:3857";
    if (options.mainLoop) {
      _this.mainLoop = options.mainLoop;
    } else {
      var engine;
      if (options.renderer && options.renderer.domElement) {
        engine = new _c3DEngine.default(options.renderer);
      } else {
        engine = new _c3DEngine.default(viewerDiv, options.renderer);
      }
      _this.mainLoop = new _MainLoop.default(new _Scheduler.default(), engine);
    }
    _this.scene = options.scene3D || new _three.Scene();
    _this.threeObjects = new _three.Group();
    _this.scene.add(_this.threeObjects);
    _this.scene2D = new _three.Scene();
    if (!options.scene3D) {
      _this.scene.autoUpdate = false;
    }
    _this.camera = new _Camera.default(_this.referenceCrs, _this.mainLoop.gfxEngine.getWindowSize().x, _this.mainLoop.gfxEngine.getWindowSize().y, options);
    _this._frameRequesters = {};
    _this._objects = [];
    window.addEventListener("resize", function() {
      var boundingRect = viewerDiv.getBoundingClientRect();
      var newSize = new _three.Vector2(boundingRect.width, boundingRect.height);
      _this.mainLoop.gfxEngine.onWindowResize(newSize.x, newSize.y);
      _this.notifyChange(_this.camera.camera3D);
    }, false);
    _this._changeSources = /* @__PURE__ */ new Set();
    _this._delayedFrameRequesterRemoval = [];
    _this._allLayersAreReadyCallback = function() {
      var allReady = _this.getObjects().every(function(obj) {
        return obj.ready;
      }) && _this.getLayers().every(function(layer) {
        return layer.ready;
      });
      if (allReady && _this.mainLoop.scheduler.commandsWaitingExecutionCount() === 0 && _this.mainLoop.renderingState === _MainLoop.RENDERING_PAUSED) {
        _this.dispatchEvent({
          type: INSTANCE_EVENTS.LAYERS_INITIALIZED
        });
        _this.removeFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.UPDATE_END, _this._allLayersAreReadyCallback);
      }
    };
    _this.controls = null;
    _this._controlFunctions = null;
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "domElement", {
      value: _this.mainLoop.gfxEngine.renderer.domElement,
      writable: false
    });
    return _this;
  }
  (0, _createClass2$1.default)(Instance2, [{
    key: "add",
    value: function add2(object) {
      var _this2 = this;
      if (!(object instanceof _three.Object3D) && !(object instanceof _Entity3D.default)) {
        return Promise.reject(new Error("object is not an instance of THREE.Object3D or Giro3d.Entity3D"));
      }
      object._instance = this;
      return new Promise(function(resolve, reject) {
        if (!object) {
          reject(new Error("object is undefined"));
          return;
        }
        var duplicate = _this2.getObjects(function(l) {
          return l.id === object.id;
        });
        if (duplicate.length > 0) {
          reject(new Error("Invalid id '".concat(object.id, "': id already used")));
          return;
        }
        var provider = _this2.mainLoop.scheduler.getProtocolProvider(object.protocol);
        if (object.protocol && !provider) {
          reject(new Error("".concat(object.protocol, " is not a recognized protocol name.")));
          return;
        }
        object = _preprocessObject(_this2, object, provider);
        if (!object.projection) {
          object.projection = _this2.referenceCrs;
        }
        _this2._objects.push(object);
        object.whenReady.then(function(l) {
          if (typeof l.update !== "function") {
            reject(new Error("Cant add Entity3D: missing a update function"));
            return;
          }
          if (typeof l.preUpdate !== "function") {
            reject(new Error("Cant add Entity3D: missing a preUpdate function"));
            return;
          }
          if (l.object3d && !l.object3d.parent && l.object3d !== _this2.scene) {
            _this2.scene.add(l.object3d);
          }
          _this2.notifyChange(l, false);
          var updateEndFR = _this2._frameRequesters[_MainLoop.MAIN_LOOP_EVENTS.UPDATE_END];
          if (!updateEndFR || updateEndFR.indexOf(_this2._allLayersAreReadyCallback) === -1) {
            _this2.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.UPDATE_END, _this2._allLayersAreReadyCallback);
          }
          resolve(l);
        });
      });
    }
    /**
     * Removes the entity or THREE object from the scene.
     *
     * @api
     * @param {Object3D|Entity} object the object to remove.
     */
  }, {
    key: "remove",
    value: function remove(object) {
      if (object.object3d) {
        _ObjectRemovalHelper.default.removeChildrenAndCleanupRecursively(object, object.object3d);
        this.scene.remove(object.object3d);
      }
      if (typeof object.clean === "function") {
        object.clean();
      }
      this._objects.splice(this._objects.indexOf(object, 1));
      this.notifyChange(this.camera.camera3D, true);
    }
  }, {
    key: "addVector",
    value: function addVector(vector2) {
      var _this3 = this;
      return new Promise(function(resolve) {
        var source = vector2.getSource();
        var convert = _OlFeature2Mesh.default.convert({
          altitude: 1
        });
        source.on("change", function() {
          if (vector2.object3d) {
            _this3.threeObjects.remove(vector2.object3d);
            vector2.object3d.traverse(function(o) {
              if (o.material) {
                o.material.dispose();
              }
              if (o.geometry) {
                o.geometry.dispose();
              }
              o.dispose();
            });
          }
          vector2.object3d = convert(source.getFeatures());
          _this3.threeObjects.add(vector2.object3d);
          _this3.notifyChange(vector2.object3d, true);
        });
        if (source.getFeatures().length > 0) {
          vector2.object3d = convert(source.getFeatures());
          _this3.threeObjects.add(vector2.object3d);
          _this3.notifyChange(vector2.object3d, true);
          resolve(vector2);
        } else {
          source.once("change", function() {
            return resolve(vector2);
          });
          source.loadFeatures([-Infinity, -Infinity, Infinity, Infinity], void 0, _this3.referenceCrs);
        }
      });
    }
    /**
     * Notifies the scene it needs to be updated due to changes exterior to the
     * scene itself (e.g. camera movement).
     * non-interactive events (e.g: texture loaded)
     *
     * @param {*} changeSource the source of the change
     * @param {boolean} needsRedraw indicates if notified change requires a full scene redraw.
     */
  }, {
    key: "notifyChange",
    value: function notifyChange() {
      var changeSource = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      var needsRedraw = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (changeSource) {
        this._changeSources.add(changeSource);
      }
      this.mainLoop.scheduleUpdate(this, needsRedraw);
    }
    /**
     * Registers a new coordinate reference system.
     * This should be done before creating the instance.
     * This method can be called several times to add multiple CRS.
     *
     * @api
     * @static
     * @example
     * // register the CRS first...
     * Instance.registerCRS(
     *  'EPSG:102115',
     *  '+proj=utm +zone=5 +ellps=clrk66 +units=m +no_defs +type=crs');
     *
     * // ...then create the instance
     * const instance = new Instance(div, { crs: 'EPSG:102115' });
     * @param {string} name the short name, or EPSG code to identify this CRS.
     * @param {string} value the proj string describing this CRS.
     */
  }, {
    key: "getObjects",
    value: (
      /**
       * Get all opjects, with an optional filter applied.
       * The filter method allows to get only a subset of objects
       *
       * @example
       * // get all objects
       * instance.getObjects();
       * // get one layer with id
       * instance.getObjects(obj => obj.id === 'itt');
       * @param {function(Entity3D):boolean} filter the optional query filter
       * @returns {Array<Layer>} an array containing the queried layers
       */
      function getObjects(filter) {
        var result = [];
        var _iterator = _createForOfIteratorHelper(this._objects), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var obj = _step.value;
            if (!filter || filter(obj)) {
              result.push(obj);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return result;
      }
    )
    /**
     * Get all the layers attached to all the entities in this instance.
     *
     * @param {function(Layer):boolean} filter Optional filter function for attached layers
     * @returns {Array<Layer>} the layers attached to the geometry layers
     */
  }, {
    key: "getLayers",
    value: function getLayers(filter) {
      var result = [];
      var _iterator2 = _createForOfIteratorHelper(this._objects), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var obj = _step2.value;
          result = result.concat(obj.getLayers(filter));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return result;
    }
    /**
     * @param {Layer} layer the layer to test
     * @returns {Entity3D} the parent entity of the given layer or null if no owner was found.
     */
  }, {
    key: "getOwner",
    value: function getOwner(layer) {
      var _iterator3 = _createForOfIteratorHelper(this._objects), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var obj = _step3.value;
          var _iterator4 = _createForOfIteratorHelper(obj._attachedLayers), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var attached = _step4.value;
              if (attached === layer) {
                return obj;
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return null;
    }
    /**
     * @name FrameRequester
     * @description
     * Method that will be called each time the <code>MainLoop</code> updates. This
     * function will be given as parameter the delta (in ms) between this update and
     * the previous one, and whether or not we just started to render again. This
     * update is considered as the "next" update if <code>instance.notifyChange</code>
     * was called during a precedent update. If <code>instance.notifyChange</code> has
     * been called by something else (other micro/macrotask, UI events etc...), then
     * this update is considered as being the "first". It can also receive optional
     * arguments, depending on the attach point of this function.  Currently only
     * <code>BEFORE_LAYER_UPDATE / AFTER_LAYER_UPDATE</code> attach points provide
     * an additional argument: the layer being updated.
     * <br><br>
     *
     * This means that if a <code>frameRequester</code> function wants to animate something, it
     * should keep on calling <code>instance.notifyChange</code> until its task is done.
     * <br><br>
     *
     * Implementors of <code>frameRequester</code> should keep in mind that this
     * function will be potentially called at each frame, thus care should be given
     * about performance.
     * <br><br>
     *
     * Typical frameRequesters are controls, module wanting to animate moves or UI
     * elements etc... Basically anything that would want to call
     * requestAnimationFrame.
     * @param {number} dt
     * @param {boolean} updateLoopRestarted
     * @param {...*} args
     */
    /**
     * Add a frame requester to this instance.
     *
     * FrameRequesters can activate the MainLoop update by calling instance.notifyChange.
     *
     * @api
     * @param {string} when decide when the frameRequester should be called during
     * the update cycle. Can be any of {@link module:Core/Instance.INSTANCE_EVENTS INSTANCE_EVENTS}.
     * @param {FrameRequester} frameRequester this function will be called at each
     * MainLoop update with the time delta between last update, or 0 if the MainLoop
     * has just been relaunched.
     */
  }, {
    key: "addFrameRequester",
    value: function addFrameRequester(when, frameRequester) {
      if (typeof frameRequester !== "function") {
        throw new Error("frameRequester must be a function");
      }
      if (!this._frameRequesters[when]) {
        this._frameRequesters[when] = [frameRequester];
      } else {
        this._frameRequesters[when].push(frameRequester);
      }
    }
    /**
     * Remove a frameRequester.
     * The effective removal will happen either later; at worst it'll be at
     * the beginning of the next frame.
     *
     * @param {string} when attach point of this requester. Can be any of
     * {@link MAIN_LOOP_EVENTS}.
     * @param {FrameRequester} frameRequester the frameRequester to remove
     */
  }, {
    key: "removeFrameRequester",
    value: function removeFrameRequester(when, frameRequester) {
      var index = this._frameRequesters[when].indexOf(frameRequester);
      if (index >= 0) {
        this._delayedFrameRequesterRemoval.push({
          when,
          frameRequester
        });
      } else {
        console.error("Invalid call to removeFrameRequester: frameRequester isn't registered");
      }
    }
  }, {
    key: "_executeFrameRequestersRemovals",
    value: function _executeFrameRequestersRemovals() {
      var _iterator5 = _createForOfIteratorHelper(this._delayedFrameRequesterRemoval), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var toDelete = _step5.value;
          var index = this._frameRequesters[toDelete.when].indexOf(toDelete.frameRequester);
          if (index >= 0) {
            this._frameRequesters[toDelete.when].splice(index, 1);
          } else {
            console.warn("FrameReq has already been removed");
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      this._delayedFrameRequesterRemoval.length = 0;
    }
    /**
     * Execute a frameRequester.
     *
     * @param {string} when attach point of this (these) requester(s). Can be any
     * of {@link MAIN_LOOP_EVENTS}.
     * @param {number} dt delta between this update and the previous one
     * @param {boolean} updateLoopRestarted <code>true</code> if giro3d' update loop just restarted
     * @param {...*} args optional arguments
     */
  }, {
    key: "execFrameRequesters",
    value: function execFrameRequesters(when, dt, updateLoopRestarted) {
      if (!this._frameRequesters[when]) {
        return;
      }
      if (this._delayedFrameRequesterRemoval.length > 0) {
        this._executeFrameRequestersRemovals();
      }
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }
      var _iterator6 = _createForOfIteratorHelper(this._frameRequesters[when]), _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          var frameRequester = _step6.value;
          if (frameRequester.update) {
            frameRequester.update(dt, updateLoopRestarted, args);
          } else {
            frameRequester(dt, updateLoopRestarted, args);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
    /**
     * Extract view coordinates from a mouse-event / touch-event
     *
     * @param {event} event event can be a MouseEvent or a TouchEvent
     * @param {number} touchIdx finger index when using a TouchEvent (default: 0)
     * @returns {Vector2} view coordinates (in pixels, 0-0 = top-left of the view)
     */
  }, {
    key: "eventToViewCoords",
    value: function eventToViewCoords(event) {
      var touchIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (event.touches === void 0 || !event.touches.length) {
        return _eventCoords.set(event.offsetX, event.offsetY);
      }
      var br = this.mainLoop.gfxEngine.renderer.domElement.getBoundingClientRect();
      return _eventCoords.set(event.touches[touchIdx].clientX - br.x, event.touches[touchIdx].clientY - br.y);
    }
    /**
     * Extract normalized coordinates (NDC) from a mouse-event / touch-event
     *
     * @param {event} event event can be a MouseEvent or a TouchEvent
     * @param {number} touchIdx finger index when using a TouchEvent (default: 0)
     * @returns {Vector2} NDC coordinates (x and y are [-1, 1])
     */
  }, {
    key: "eventToNormalizedCoords",
    value: function eventToNormalizedCoords(event) {
      var touchIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return this.viewToNormalizedCoords(this.eventToViewCoords(event, touchIdx));
    }
    /**
     * Convert view coordinates to normalized coordinates (NDC)
     *
     * @param {Vector2} viewCoords (in pixels, 0-0 = top-left of the View)
     * @returns {Vector2} NDC coordinates (x and y are [-1, 1])
     */
  }, {
    key: "viewToNormalizedCoords",
    value: function viewToNormalizedCoords(viewCoords) {
      _eventCoords.x = 2 * (viewCoords.x / this.camera.width) - 1;
      _eventCoords.y = -2 * (viewCoords.y / this.camera.height) + 1;
      return _eventCoords;
    }
    /**
     * Convert NDC coordinates to view coordinates
     *
     * @param {Vector2} ndcCoords the NDC coordinates to convert
     * @returns {Vector2} view coordinates (in pixels, 0-0 = top-left of the View)
     */
  }, {
    key: "normalizedToViewCoords",
    value: function normalizedToViewCoords(ndcCoords) {
      _eventCoords.x = (ndcCoords.x + 1) * 0.5 * this.camera.width;
      _eventCoords.y = (ndcCoords.y - 1) * -0.5 * this.camera.height;
      return _eventCoords;
    }
    /**
     * Return objects from some layers/objects3d under the mouse in this view.
     *
     * @param {object} mouseOrEvt mouse position in window coordinates (0, 0 = top-left)
     * or MouseEvent or TouchEvent
     * @param {number} radius picking will happen in a circle centered on mouseOrEvt. Radius
     * is the radius of this circle, in pixels
     * @param {...*} where where to look for objects. Can be either: empty (= look
     * in all layers with type === 'geometry'), layer ids or layers or a mix of all
     * the above.
     * @returns {Array} an array of objects. Each element contains at least an object
     * property which is the Object3D under the cursor. Then depending on the queried
     * layer/source, there may be additionnal properties (coming from THREE.Raycaster
     * for instance).
     * @example
     * instance.pickObjectsAt({ x, y })
     * instance.pickObjectsAt({ x, y }, 1, 'wfsBuilding')
     * instance.pickObjectsAt({ x, y }, 3, 'wfsBuilding', myLayer)
     */
  }, {
    key: "pickObjectsAt",
    value: function pickObjectsAt(mouseOrEvt, radius) {
      var results = [];
      for (var _len2 = arguments.length, where = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        where[_key2 - 2] = arguments[_key2];
      }
      var sources = where.length === 0 ? this.getObjects().concat(this.threeObjects) : [].concat(where);
      var mouse = mouseOrEvt instanceof Event ? this.eventToViewCoords(mouseOrEvt) : mouseOrEvt;
      radius = radius || 0;
      var _iterator7 = _createForOfIteratorHelper(sources), _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
          var source = _step7.value;
          if (source instanceof _Entity3D.default || source instanceof _Layer.default || typeof source === "string") {
            var object = typeof source === "string" ? objectIdToObject(this, source) : source;
            var sp = object.pickObjectsAt(this, mouse, radius);
            for (var i = 0; i < sp.length; i++) {
              results.push(sp[i]);
            }
          } else if (source.isObject3D) {
            _Picking.default.pickObjectsAt(this, mouse, radius, source, results);
          } else {
            throw new Error("Invalid where arg (value = ".concat(where, "). Expected layers, layer ids or Object3Ds"));
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return results;
    }
  }, {
    key: "focusObject",
    value: function focusObject(obj) {
      if (obj instanceof Map) {
        var dim = obj.extent.dimensions();
        var positionCamera = obj.extent.center().clone();
        positionCamera._values[2] = Math.max(dim.x, dim.y);
        var lookat = positionCamera.xyz();
        lookat.z = 0;
        this.camera.camera3D.position.copy(positionCamera.xyz());
        this.camera.camera3D.lookAt(lookat);
        this.camera.camera3D.updateMatrixWorld(true);
      }
    }
    /**
     * This function allows to use three.js controls (files in `examples/{js,jsm}/controls` folder
     * of THREE.js) into giro3d 3D scene.
     *
     * Giro3d supports the controls that check the following assumptions:
     *
     * - they fire 'change' events when something happens
     * - they have an `update` method
     *
     * @param {object} controls An instance of a THREE controls
     * @api
     */
  }, {
    key: "useTHREEControls",
    value: function useTHREEControls(controls) {
      var _this4 = this;
      if (this.controls) {
        return;
      }
      this._controlFunctions = {
        frameRequester: function frameRequester() {
          return controls.update();
        },
        eventListener: function eventListener() {
          return _this4.notifyChange(_this4.camera.camera3D);
        }
      };
      if (typeof controls.addEventListener === "function") {
        controls.addEventListener("change", this._controlFunctions.eventListener);
      } else {
        throw new Error("Unsupported control class: only event dispatcher controls are supported.");
      }
      this.addFrameRequester("before_camera_update", this._controlFunctions.frameRequester);
      this.controls = controls;
    }
    /**
     * Removes a THREE controls previously added. The controls won't be disable.
     */
  }, {
    key: "removeTHREEControls",
    value: function removeTHREEControls() {
      if (!this.controls) {
        return;
      }
      this.controls.removeEventListener("change", this._controlFunctions.eventListener);
      this.removeFrameRequester("before_camera_update", this._controlFunctions.frameRequester);
      this.controls = null;
      this._controlFunctions = null;
    }
  }], [{
    key: "registerCRS",
    value: function registerCRS(name, value) {
      if (!name || name === "") {
        throw new Error("missing CRS name");
      }
      if (!value || value === "") {
        throw new Error("missing CRS PROJ string");
      }
      _proj.default.defs(name, value);
      (0, _proj2.register)(_proj.default);
    }
  }]);
  return Instance2;
}(_three.EventDispatcher);
var _syncEntityVisibility = function(entity, instance) {
  if (entity.object3d) {
    entity.object3d.visible = entity.visible;
  }
  if (entity.threejsLayer) {
    if (entity.visible) {
      instance.camera.camera3D.layers.enable(entity.threejsLayer);
    } else {
      instance.camera.camera3D.layers.disable(entity.threejsLayer);
    }
  }
};
function _preprocessObject(instance, obj, provider, parentLayer) {
  if (!(obj instanceof _Layer.default) && !(obj instanceof _Entity3D.default)) {
    var nlayer = new _Layer.default(obj.id);
    var tmp2 = obj;
    delete tmp2.id;
    obj = Object.assign(nlayer, obj);
    tmp2.id = obj.id;
  }
  obj.options = obj.options || {};
  if (!obj.updateStrategy) {
    obj.updateStrategy = {
      type: _LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC
    };
  }
  if (provider) {
    if (provider.tileInsideLimit) {
      obj.tileInsideLimit = provider.tileInsideLimit.bind(provider);
    }
    if (provider.getPossibleTextureImprovements) {
      obj.getPossibleTextureImprovements = provider.getPossibleTextureImprovements.bind(provider);
    }
    if (provider.tileTextureCount) {
      obj.tileTextureCount = provider.tileTextureCount.bind(provider);
    }
  }
  if (!obj.whenReady) {
    if (!obj.object3d) {
      obj.threejsLayer = instance.mainLoop.gfxEngine.getUniqueThreejsLayer();
    }
    var providerPreprocessing = Promise.resolve();
    if (provider && provider.preprocessDataLayer) {
      providerPreprocessing = provider.preprocessDataLayer(obj, instance, instance.mainLoop.scheduler, parentLayer);
      if (!(providerPreprocessing && providerPreprocessing.then)) {
        providerPreprocessing = Promise.resolve();
      }
    }
    obj.whenReady = providerPreprocessing.then(function() {
      obj.ready = true;
      return obj;
    });
  }
  (0, _Layer.defineLayerProperty)(obj, "visible", true, function() {
    return _syncEntityVisibility(obj, instance);
  });
  (0, _Layer.defineLayerProperty)(obj, "frozen", false);
  _syncEntityVisibility(obj, instance);
  return obj;
}
function objectIdToObject(instance, layerId) {
  var lookup = instance.getObjects(function(l) {
    return l.id === layerId;
  });
  if (!lookup.length) {
    throw new Error("Invalid layer id used as where argument (value = ".concat(layerId, ")"));
  }
  return lookup[0];
}
var _default$1 = Instance;
default_1$1 = Instance$1.default = _default$1;
var Tiles3DSource$1 = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(Tiles3DSource$1, "__esModule", {
  value: true
});
var default_1 = Tiles3DSource$1.default = void 0;
var _createClass2 = _interopRequireDefault(requireCreateClass());
var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());
var Tiles3DSource = /* @__PURE__ */ (0, _createClass2.default)(
  /**
   * @param {string} url The URL to the root tileset.
   * @param {NetworkOptions} networkOptions the network options.
   * @api
   */
  function Tiles3DSource2(url, networkOptions) {
    (0, _classCallCheck2.default)(this, Tiles3DSource2);
    this.url = url;
    this.networkOptions = networkOptions;
  }
);
var _default = Tiles3DSource;
default_1 = Tiles3DSource$1.default = _default;
const Giro3d_vue_vue_type_style_index_0_scoped_b898538f_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main = {
  name: "giro3d",
  data() {
    return {
      loadedModelIds: [],
      modelPointClouds: /* @__PURE__ */ new Map(),
      giro3dDivId: null
    };
  },
  created() {
    console.log(this.$viewer);
    this.giro3dDivId = `3d-engine-${this.$viewer.globalContext.plugins.id}`;
    this.localContextResizeSubscription = this.$viewer.globalContext.hub.on(
      "context-resize",
      this.onResize
    );
  },
  unmounted() {
    this.$viewer.globalContext.hub.off(this.localContextResizeSubscription);
  },
  async mounted() {
    const viewerDiv = document.getElementById(this.giro3dDivId);
    await this.$nextTick();
    const instance = new default_1$1(viewerDiv, {
      renderer: {
        clearColor: false
      }
    });
    const controls = new MapControls(
      instance.camera.camera3D,
      instance.domElement
    );
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    instance.useTHREEControls(controls);
    instance.notifyChange(instance.camera.camera3D);
    this.instance = instance;
    this.controls = controls;
  },
  methods: {
    onResize({ width, height }) {
      if (!this.instance) {
        return;
      }
      this.instance.mainLoop.gfxEngine.onWindowResize(width, height);
      this.instance.notifyChange(this.instance.camera.camera3D);
    },
    placeCamera(position, lookAt) {
      const { instance, controls } = this;
      instance.camera.camera3D.position.set(position.x, position.y, position.z);
      instance.camera.camera3D.lookAt(lookAt);
      controls.target.copy(lookAt);
    },
    initializeCamera(pointcloud) {
      const tmpVec3 = new Vector3();
      const bbox = pointcloud.root.bbox ? pointcloud.root.bbox : pointcloud.root.boundingVolume.box.clone().applyMatrix4(pointcloud.root.matrixWorld);
      this.instance.camera.camera3D.far = 2 * bbox.getSize(tmpVec3).length();
      const ratio = bbox.getSize(tmpVec3).x / bbox.getSize(tmpVec3).z;
      const position = bbox.min.clone().add(
        bbox.getSize(tmpVec3).multiply({ x: 0, y: 0, z: ratio * 0.5 })
      );
      const lookAt = bbox.getCenter(tmpVec3);
      lookAt.z = bbox.min.z;
      this.placeCamera(position, lookAt);
    },
    async loadModels(models) {
      this.loadedModelIds.push(...models.map((model) => model.id).filter((modelId) => !this.loadedModelIds.includes(modelId)));
      models.forEach(async (model, i) => {
        const { apiUrl, cloudId, projectId, accessToken } = this.$viewer.api;
        const tileset = await fetch(`${apiUrl}/cloud/${cloudId}/project/${projectId}/model/${model.id}/tileset?tile_format=pnts`, {
          headers: new Headers({
            accept: "*/*",
            Authorization: `Bearer ${accessToken}`
          })
        });
        const url = URL.createObjectURL(await tileset.blob());
        const pointcloud = new default_1$2(
          "pointcloud",
          new default_1(url)
        );
        this.modelPointClouds.set(model, pointcloud);
        await this.instance.add(pointcloud);
        URL.revokeObjectURL(url);
        if (i === 0) {
          this.initializeCamera(pointcloud);
        }
      });
    },
    async unloadModels(models) {
      const pointClouds = models.map((model) => this.modelPointClouds.get(model)).filter(Boolean);
      models.forEach((model) => this.modelPointClouds.delete(model));
      pointClouds.forEach((pointCloud) => {
        this.instance.remove(pointCloud);
      });
      const modelIds = models.map((model) => model.id);
      this.loadedModelIds = this.loadedModelIds.filter((id) => !modelIds.includes(id));
    }
  }
};
const _hoisted_1 = { class: "bimdata-giro3d" };
const _hoisted_2 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NoModelWindowPlaceHolder = BIMDataViewerVue.resolveComponent("NoModelWindowPlaceHolder");
  const _component_ModelsLoader = BIMDataViewerVue.resolveComponent("ModelsLoader");
  return BIMDataViewerVue.openBlock(), BIMDataViewerVue.createElementBlock("div", _hoisted_1, [
    $data.loadedModelIds.length === 0 && !_ctx.loading ? (BIMDataViewerVue.openBlock(), BIMDataViewerVue.createBlock(_component_NoModelWindowPlaceHolder, { key: 0 })) : BIMDataViewerVue.createCommentVNode("", true),
    BIMDataViewerVue.createVNode(_component_ModelsLoader, {
      types: ["POINT_CLOUD"],
      onLoadModels: $options.loadModels,
      onUnloadModels: $options.unloadModels,
      preview: ""
    }, null, 8, ["onLoadModels", "onUnloadModels"]),
    BIMDataViewerVue.createElementVNode("div", {
      id: $data.giro3dDivId,
      class: "bimdata-giro3d__viewer"
    }, null, 8, _hoisted_2)
  ]);
}
const Giro3dComponent = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-b898538f"]]);
const giro3d_plugin = {
  name: "Giro3dPlugin",
  // The name of the plugin
  component: Giro3dComponent,
  window: {
    name: "giro3d",
    label: "Giro3dPlugin.window_label",
    plugins: ["fullscreen"]
  },
  i18n: {
    en: {
      window_label: "Giro3d"
    },
    fr: {
      window_label: "Giro3d"
    }
  }
};
export {
  giro3d_plugin as default
};
